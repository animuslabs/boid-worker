import { fs, path, exists, readFileUtf8, exit, walk } from "../adapter.node";
import { DirBuilder, dts, r, t } from "./builders";
import { createClient, _edgedbJsVersion } from "../index.node";
import { getCasts } from "./queries/getCasts";
import { getScalars } from "./queries/getScalars";
import { getFunctions } from "./queries/getFunctions";
import { getOperators } from "./queries/getOperators";
import { getGlobals } from "./queries/getGlobals";
import { getTypes } from "./queries/getTypes";
import * as genutil from "./util/genutil";
import { syntax } from "./syntax";
import { generateCastMaps } from "./generators/generateCastMaps";
import { generateScalars } from "./generators/generateScalars";
import { generateObjectTypes } from "./generators/generateObjectTypes";
import { generateRuntimeSpec } from "./generators/generateRuntimeSpec";
import { generateFunctionTypes } from "./generators/generateFunctionTypes";
import { generateOperators } from "./generators/generateOperatorTypes";
import { generateGlobals } from "./generators/generateGlobals";
import { generateSetImpl } from "./generators/generateSetImpl";
const DEBUG = false;
export const configFileHeader = `// EdgeDB query builder. To update, run \`npx edgeql-js\``;
export function exitWithError(message) {
    console.error(message);
    exit(1);
    throw new Error();
}
export async function generateQB(params) {
    const { outputDir, connectionConfig, target } = params;
    let cxn;
    try {
        cxn = createClient({
            ...connectionConfig,
            concurrency: 5,
        });
    }
    catch (e) {
        return exitWithError(`Failed to connect: ${e.message}`);
    }
    const dir = new DirBuilder();
    try {
        console.log(`Introspecting database schema...`);
        const version = await cxn.queryRequiredSingle(`select sys::get_version();`);
        const [types, scalars, casts, functions, operators, globals] = await Promise.all([
            getTypes(cxn, { debug: DEBUG, version }),
            getScalars(cxn, { version }),
            getCasts(cxn, { debug: DEBUG, version }),
            getFunctions(cxn, { version }),
            getOperators(cxn, { version }),
            getGlobals(cxn, { version }),
        ]);
        const typesByName = {};
        for (const type of types.values()) {
            typesByName[type.name] = type;
            if (!type.name.includes("::"))
                continue;
        }
        const generatorParams = {
            dir,
            types,
            typesByName,
            casts,
            scalars,
            functions,
            globals,
            operators,
        };
        generateRuntimeSpec(generatorParams);
        generateCastMaps(generatorParams);
        generateScalars(generatorParams);
        generateObjectTypes(generatorParams);
        generateFunctionTypes(generatorParams);
        generateOperators(generatorParams);
        generateSetImpl(generatorParams);
        generateGlobals(generatorParams);
        const importsFile = dir.getPath("imports");
        const edgedb = "edgedb";
        importsFile.addExportStar(edgedb, { as: "edgedb" });
        importsFile.addExportFrom({ spec: true }, "./__spec__", {
            allowFileExt: true,
        });
        importsFile.addExportStar("./syntax/syntax", {
            allowFileExt: true,
            as: "syntax",
        });
        importsFile.addExportStar("./castMaps", {
            allowFileExt: true,
            as: "castMaps",
        });
        const index = dir.getPath("index");
        index.addExportStar("./syntax/external", {
            allowFileExt: true,
        });
        index.addExportStar("./types", {
            allowFileExt: true,
            modes: ["ts", "dts", "js"],
        });
        index.addImport({ $: true, _edgedbJsVersion: true }, edgedb);
        index.addExportFrom({ createClient: true }, edgedb);
        index.addImportStar("$syntax", "./syntax/syntax", { allowFileExt: true });
        index.addImportStar("$op", "./operators", { allowFileExt: true });
        index.writeln([
            r `\nif (_edgedbJsVersion !== "${_edgedbJsVersion}") {
  throw new Error(
    \`The query builder was generated by a different version of edgedb-js (v${_edgedbJsVersion})\` +
      \` than the one currently installed (v\${_edgedbJsVersion}).\\n\` +
      \`Run 'npx edgeql-js' to re-generate a compatible version.\\n\`
  );
}`,
        ]);
        const spreadModules = [
            {
                name: "$op",
                keys: ["op"],
            },
            {
                name: "$syntax",
                keys: [
                    "ASC",
                    "DESC",
                    "EMPTY_FIRST",
                    "EMPTY_LAST",
                    "alias",
                    "array",
                    "cast",
                    "detached",
                    "for",
                    "insert",
                    "is",
                    "literal",
                    "namedTuple",
                    "optional",
                    "select",
                    "set",
                    "tuple",
                    "with",
                    "withParams",
                ],
            },
            {
                name: "_default",
                module: dir.getModule("default"),
            },
            { name: "_std", module: dir.getModule("std") },
        ];
        const excludedKeys = new Set(dir._modules.keys());
        const spreadTypes = [];
        for (let { name, keys, module } of spreadModules) {
            if (module === null || module === void 0 ? void 0 : module.isEmpty()) {
                continue;
            }
            keys = keys !== null && keys !== void 0 ? keys : module.getDefaultExportKeys();
            const conflictingKeys = keys.filter(key => excludedKeys.has(key));
            let typeStr;
            if (conflictingKeys.length) {
                typeStr = `Omit<typeof ${name}, ${conflictingKeys
                    .map(genutil.quote)
                    .join(" | ")}>`;
            }
            else {
                typeStr = `typeof ${name}`;
            }
            spreadTypes.push(name === "$syntax" ? `$.util.OmitDollarPrefixed<${typeStr}>` : typeStr);
            for (const key of keys) {
                excludedKeys.add(key);
            }
        }
        index.nl();
        index.writeln([
            dts `declare `,
            `const ExportDefault`,
            t `: ${spreadTypes.reverse().join(" & \n  ")} & {`,
        ]);
        index.indented(() => {
            for (const [moduleName, internalName] of dir._modules) {
                if (dir.getModule(moduleName).isEmpty())
                    continue;
                index.writeln([
                    t `${genutil.quote(moduleName)}: typeof _${internalName};`,
                ]);
            }
        });
        index.writeln([t `}`, r ` = {`]);
        index.indented(() => {
            for (const { name, module } of [...spreadModules].reverse()) {
                if (module === null || module === void 0 ? void 0 : module.isEmpty()) {
                    continue;
                }
                index.writeln([
                    r `...${name === "$syntax" ? `$.util.omitDollarPrefixed($syntax)` : name},`,
                ]);
            }
            for (const [moduleName, internalName] of dir._modules) {
                if (dir.getModule(moduleName).isEmpty()) {
                    continue;
                }
                index.addImportDefault(`_${internalName}`, `./modules/${internalName}`, { allowFileExt: true });
                index.writeln([r `${genutil.quote(moduleName)}: _${internalName},`]);
            }
        });
        index.writeln([r `};`]);
        index.addExportDefault("ExportDefault");
        index.writeln([r `const Cardinality = $.Cardinality;`]);
        index.writeln([dts `declare `, t `type Cardinality = $.Cardinality;`]);
        index.addExport("Cardinality");
        index.writeln([
            t `export `,
            dts `declare `,
            t `type Set<
  Type extends $.BaseType,
  Card extends $.Cardinality = $.Cardinality.Many
> = $.TypeSet<Type, Card>;`,
        ]);
    }
    finally {
        await cxn.close();
    }
    const initialFiles = new Set(await walk(outputDir));
    const written = new Set();
    if (target === "ts") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".ts",
            moduleExtension: "",
            written,
        });
    }
    else if (target === "mts") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".mts",
            moduleExtension: ".mjs",
            written,
        });
    }
    else if (target === "cjs") {
        await dir.write(outputDir, {
            mode: "js",
            moduleKind: "cjs",
            fileExtension: ".js",
            moduleExtension: "",
            written,
        });
        await dir.write(outputDir, {
            mode: "dts",
            moduleKind: "esm",
            fileExtension: ".d.ts",
            moduleExtension: "",
            written,
        });
    }
    else if (target === "esm") {
        await dir.write(outputDir, {
            mode: "js",
            moduleKind: "esm",
            fileExtension: ".mjs",
            moduleExtension: ".mjs",
            written,
        });
        await dir.write(outputDir, {
            mode: "dts",
            moduleKind: "esm",
            fileExtension: ".d.ts",
            moduleExtension: "",
            written,
        });
    }
    else if (target === "deno") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".ts",
            moduleExtension: ".ts",
            written,
        });
    }
    const syntaxOutDir = path.join(outputDir, "syntax");
    if (!(await exists(syntaxOutDir))) {
        await fs.mkdir(syntaxOutDir);
    }
    const syntaxFiles = syntax[target];
    if (!syntaxFiles) {
        throw new Error(`Error: no syntax files found for target "${target}"`);
    }
    for (const f of syntaxFiles) {
        const outputPath = path.join(syntaxOutDir, f.path);
        written.add(outputPath);
        let oldContents = "";
        try {
            oldContents = await readFileUtf8(outputPath);
        }
        catch { }
        if (oldContents !== f.content) {
            await fs.writeFile(outputPath, f.content);
        }
    }
    const configPath = path.join(outputDir, "config.json");
    await fs.writeFile(configPath, `${configFileHeader}\n${JSON.stringify({ target })}\n`);
    written.add(configPath);
    for (const file of initialFiles) {
        if (written.has(file)) {
            continue;
        }
        await fs.rm(file);
    }
}

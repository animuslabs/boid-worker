import { CodeBuffer, dts, js, r, t, ts } from "../builders";
import { Cardinality } from "../enums";
import { frag, getRef, joinFrags, makePlainIdent, quote, splitName, toTSScalarType, } from "../util/genutil";
const singletonObjectTypes = new Set(["std::FreeObject"]);
export const getStringRepresentation = (type, params) => {
    var _a, _b, _c;
    const suffix = params.castSuffix || `λICastableTo`;
    if (type.name === "anytype") {
        return {
            staticType: frag `${(_a = params.anytype) !== null && _a !== void 0 ? _a : `$.BaseType`}`,
            runtimeType: [],
        };
    }
    if (type.name === "anytuple") {
        return {
            staticType: [`$.AnyTupleType`],
            runtimeType: [],
        };
    }
    if (type.name === "std::anypoint") {
        return {
            staticType: frag `${(_b = params.anytype) !== null && _b !== void 0 ? _b : getRef("std::anypoint")}`,
            runtimeType: [],
        };
    }
    if (type.name === "std::anyenum") {
        return {
            staticType: [`$.EnumType`],
            runtimeType: [],
        };
    }
    const { types, casts } = params;
    if (type.kind === "object") {
        if (type.name === "std::BaseObject") {
            return {
                staticType: ["$.ObjectType"],
                runtimeType: [getRef(type.name)],
            };
        }
        return {
            staticType: [getRef(type.name)],
            runtimeType: [getRef(type.name)],
        };
    }
    else if (type.kind === "scalar") {
        return {
            staticType: [getRef(type.name), ((_c = casts === null || casts === void 0 ? void 0 : casts[type.id]) === null || _c === void 0 ? void 0 : _c.length) ? suffix : ""],
            runtimeType: [getRef(type.name)],
        };
    }
    else if (type.kind === "array") {
        return {
            staticType: frag `$.ArrayType<${getStringRepresentation(types.get(type.array_element_id), params)
                .staticType}>`,
            runtimeType: frag `$.ArrayType(${getStringRepresentation(types.get(type.array_element_id), params)
                .runtimeType})`,
        };
    }
    else if (type.kind === "tuple") {
        const isNamed = type.tuple_elements[0].name !== "0";
        if (isNamed) {
            const itemsStatic = joinFrags(type.tuple_elements.map(it => frag `${it.name}: ${getStringRepresentation(types.get(it.target_id), params)
                .staticType}`), ", ");
            const itemsRuntime = joinFrags(type.tuple_elements.map(it => frag `${it.name}: ${getStringRepresentation(types.get(it.target_id), params)
                .runtimeType}`), ", ");
            return {
                staticType: frag `$.NamedTupleType<{${itemsStatic}}>`,
                runtimeType: frag `$.NamedTupleType({${itemsRuntime}})`,
            };
        }
        else {
            const items = type.tuple_elements
                .map(it => it.target_id)
                .map(id => types.get(id))
                .map(el => getStringRepresentation(el, params));
            return {
                staticType: frag `$.TupleType<[${joinFrags(items.map(it => it.staticType), ", ")}]>`,
                runtimeType: frag `$.TupleType([${joinFrags(items.map(it => it.runtimeType), ", ")}])`,
            };
        }
    }
    else if (type.kind === "range") {
        return {
            staticType: frag `$.RangeType<${getStringRepresentation(types.get(type.range_element_id), params)
                .staticType}>`,
            runtimeType: frag `$.RangeType(${getStringRepresentation(types.get(type.range_element_id), params)
                .runtimeType})`,
        };
    }
    else {
        throw new Error("Invalid type");
    }
};
export const generateObjectTypes = (params) => {
    var _a;
    const { dir, types } = params;
    const plainTypesCode = dir.getPath("types");
    const edgedb = "edgedb";
    plainTypesCode.addImportStar("edgedb", edgedb, {
        typeOnly: true,
    });
    const plainTypeModules = new Map();
    const getPlainTypeModule = (typeName) => {
        const { mod: tMod, name: tName } = splitName(typeName);
        if (!plainTypeModules.has(tMod)) {
            plainTypeModules.set(tMod, {
                internalName: makePlainIdent(tMod),
                buf: new CodeBuffer(),
                types: new Map(),
            });
        }
        return { tMod, tName, module: plainTypeModules.get(tMod) };
    };
    const _getTypeName = (mod) => (typeName, withModule = false) => {
        const { tMod, tName, module } = getPlainTypeModule(typeName);
        return (((mod !== tMod || withModule) && tMod !== "default"
            ? `${module.internalName}.`
            : "") + `${makePlainIdent(tName)}`);
    };
    for (const type of types.values()) {
        if (type.kind !== "object") {
            if (type.kind === "scalar" && ((_a = type.enum_values) === null || _a === void 0 ? void 0 : _a.length)) {
                const { mod: enumMod, name: enumName } = splitName(type.name);
                const getEnumTypeName = _getTypeName(enumMod);
                const { module } = getPlainTypeModule(type.name);
                module.types.set(enumName, getEnumTypeName(type.name, true));
                module.buf.writeln([t `export enum ${getEnumTypeName(type.name)} {`], ...type.enum_values.map(val => [
                    t `  ${makePlainIdent(val)} = ${quote(val)},`,
                ]), [t `}`]);
                if (enumMod === "default") {
                    module.buf.writeln([js `const ${getEnumTypeName(type.name)} = {`], ...type.enum_values.map(val => [
                        js `  ${makePlainIdent(val)}: ${quote(val)},`,
                    ]), [js `}`]);
                    plainTypesCode.addExport(getEnumTypeName(type.name), {
                        modes: ["js"],
                    });
                }
                else {
                    module.buf.writeln([js `"${getEnumTypeName(type.name)}": {`], ...type.enum_values.map(val => [
                        js `  ${makePlainIdent(val)}: ${quote(val)},`,
                    ]), [js `},`]);
                }
            }
            continue;
        }
        if ((type.union_of && type.union_of.length) ||
            (type.intersection_of && type.intersection_of.length)) {
            continue;
        }
        const { mod, name } = splitName(type.name);
        const body = dir.getModule(mod);
        body.registerRef(type.name, type.id);
        const ref = getRef(type.name);
        const getTypeName = _getTypeName(mod);
        const getTSType = (pointer) => {
            const targetType = types.get(pointer.target_id);
            if (pointer.kind === "link") {
                return getTypeName(targetType.name);
            }
            else {
                return toTSScalarType(targetType, types, {
                    getEnumRef: enumType => getTypeName(enumType.name),
                    edgedbDatatypePrefix: "",
                }).join("");
            }
        };
        const { module: plainTypeModule } = getPlainTypeModule(type.name);
        plainTypeModule.types.set(name, getTypeName(type.name, true));
        plainTypeModule.buf.writeln([
            t `export interface ${getTypeName(type.name)}${type.bases.length
                ? ` extends ${type.bases
                    .map(({ id }) => {
                    const baseType = types.get(id);
                    return getTypeName(baseType.name);
                })
                    .join(", ")}`
                : ""} ${type.pointers.length
                ? `{\n${type.pointers
                    .map(pointer => {
                    const isOptional = pointer.real_cardinality === Cardinality.AtMostOne;
                    return `  ${quote(pointer.name)}${isOptional ? "?" : ""}: ${getTSType(pointer)}${pointer.real_cardinality === Cardinality.Many ||
                        pointer.real_cardinality === Cardinality.AtLeastOne
                        ? "[]"
                        : ""}${isOptional ? " | null" : ""};`;
                })
                    .join("\n")}\n}`
                : "{}"}\n`,
        ]);
        const ptrToLine = ptr => {
            var _a, _b, _c, _d;
            const card = `$.Cardinality.${ptr.real_cardinality}`;
            const target = types.get(ptr.target_id);
            const { staticType, runtimeType } = getStringRepresentation(target, {
                types,
            });
            return {
                key: ptr.name,
                staticType,
                runtimeType,
                card,
                kind: ptr.kind,
                isExclusive: ptr.is_exclusive,
                is_computed: (_a = ptr.is_computed) !== null && _a !== void 0 ? _a : false,
                is_readonly: (_b = ptr.is_readonly) !== null && _b !== void 0 ? _b : false,
                hasDefault: (_c = ptr.has_default) !== null && _c !== void 0 ? _c : false,
                lines: ((_d = ptr.pointers) !== null && _d !== void 0 ? _d : [])
                    .filter(p => p.name !== "@target" && p.name !== "@source")
                    .map(ptrToLine),
            };
        };
        const lines = [
            ...type.pointers,
            ...type.backlinks,
            ...type.backlink_stubs,
        ].map(ptrToLine);
        const fieldNames = new Set(lines.map(l => l.key));
        const baseTypesUnion = type.bases.length
            ? frag `${joinFrags(type.bases.map(base => {
                const baseType = types.get(base.id);
                const overloadedFields = [
                    ...baseType.pointers,
                    ...baseType.backlinks,
                    ...baseType.backlink_stubs,
                ]
                    .filter(field => fieldNames.has(field.name))
                    .map(field => quote(field.name));
                const baseRef = getRef(baseType.name);
                return overloadedFields.length
                    ? frag `Omit<${baseRef}λShape, ${overloadedFields.join(" | ")}>`
                    : frag `${baseRef}λShape`;
            }), " & ")} & `
            : ``;
        body.writeln([
            t `export `,
            dts `declare `,
            t `type ${ref}λShape = $.typeutil.flatten<${baseTypesUnion}{`,
        ]);
        body.indented(() => {
            for (const line of lines) {
                if (line.kind === "link") {
                    if (!line.lines.length) {
                        body.writeln([
                            t `${quote(line.key)}: $.LinkDesc<${line.staticType}, ${line.card}, {}, ${line.isExclusive.toString()}, ${line.is_computed.toString()},  ${line.is_readonly.toString()}, ${line.hasDefault.toString()}>;`,
                        ]);
                    }
                    else {
                        body.writeln([
                            t `${quote(line.key)}: $.LinkDesc<${line.staticType}, ${line.card}, {`,
                        ]);
                        body.indented(() => {
                            for (const linkProp of line.lines) {
                                body.writeln([
                                    t `${quote(linkProp.key)}: $.PropertyDesc<${linkProp.staticType}, ${linkProp.card}>;`,
                                ]);
                            }
                        });
                        body.writeln([
                            t `}, ${line.isExclusive.toString()}, ${line.is_computed.toString()}, ${line.is_readonly.toString()}, ${line.hasDefault.toString()}>;`,
                        ]);
                    }
                }
                else {
                    body.writeln([
                        t `${quote(line.key)}: $.PropertyDesc<${line.staticType}, ${line.card}, ${line.isExclusive.toString()}, ${line.is_computed.toString()}, ${line.is_readonly.toString()}, ${line.hasDefault.toString()}>;`,
                    ]);
                }
            }
        });
        body.writeln([t `}>;`]);
        body.writeln([
            dts `declare `,
            t `type ${ref} = $.ObjectType<${quote(type.name)}, ${ref}λShape, null>;`,
        ]);
        if (type.name === "std::Object") {
            body.writeln([t `export `, dts `declare `, t `type $Object = ${ref}`]);
        }
        const literal = getRef(type.name, { prefix: "" });
        body.writeln([
            dts `declare `,
            ...frag `const ${ref}`,
            dts `: ${ref}`,
            r ` = $.makeType`,
            ts `<${ref}>`,
            r `(_.spec, ${quote(type.id)}, _.syntax.literal);`,
        ]);
        body.addExport(ref);
        const typeCard = singletonObjectTypes.has(type.name) ? "One" : "Many";
        body.nl();
        body.writeln([
            dts `declare `,
            ...frag `const ${literal}`,
            t `: $.$expr_PathNode<$.TypeSet<${ref}, $.Cardinality.${typeCard}>, null, true> `,
            r `= _.syntax.$PathNode($.$toSet(${ref}, $.Cardinality.${typeCard}), null, true);`,
        ]);
        body.nl();
        body.addExport(literal);
        body.addToDefaultExport(literal, name);
    }
    const plainTypesExportBuf = new CodeBuffer();
    for (const [moduleName, module] of plainTypeModules) {
        if (moduleName === "default") {
            plainTypesCode.writeBuf(module.buf);
        }
        else {
            plainTypesCode.writeln([t `export namespace ${module.internalName} {`]);
            plainTypesCode.writeln([js `const ${module.internalName} = {`]);
            plainTypesCode.indented(() => plainTypesCode.writeBuf(module.buf));
            plainTypesCode.writeln([t `}`]);
            plainTypesCode.writeln([js `}`]);
            plainTypesCode.addExport(module.internalName, { modes: ["js"] });
        }
        plainTypesExportBuf.writeln([
            t `  ${quote(moduleName)}: {\n${[...module.types.entries()]
                .map(([name, typeName]) => `    ${quote(name)}: ${typeName};`)
                .join("\n")}\n  };`,
        ]);
    }
    plainTypesCode.writeln([t `export interface types {`]);
    plainTypesCode.writeBuf(plainTypesExportBuf);
    plainTypesCode.writeln([t `}`]);
};

import { splitName, getRef, frag, joinFrags, toIdent, quote, toTSScalarType, scalarToLiteralMapping, } from "../util/genutil";
import { dts, r, t, ts } from "../builders";
import { typeMapping } from "../queries/getTypes";
export const generateScalars = (params) => {
    var _a, _b, _c, _d;
    const { dir, types, casts, scalars } = params;
    for (const type of types.values()) {
        if (type.kind !== "scalar") {
            continue;
        }
        const { mod, name: _name } = splitName(type.name);
        const sc = dir.getModule(mod);
        sc.registerRef(type.name, type.id);
        const ref = getRef(type.name);
        const literal = getRef(type.name, { prefix: "" });
        if (type.name === "std::anyenum") {
            continue;
        }
        if (type.is_abstract) {
            const scalarType = scalars.get(type.id);
            if (scalarType.children.length) {
                const children = [
                    ...new Set(scalarType.children.map(desc => { var _a; return ((_a = typeMapping.get(desc.id)) !== null && _a !== void 0 ? _a : desc).name; })),
                ].map(descName => descName === "std::anyenum" ? "$.EnumType" : getRef(descName));
                sc.writeln([
                    dts `declare `,
                    t `type ${ref} = ${joinFrags(children, " | ")};`,
                ]);
                sc.nl();
                sc.addExport(ref, { typeOnly: true });
            }
            else if (scalarType.bases.length) {
                const bases = scalarType.bases.map(base => getRef(base.name));
                sc.writeln([t `interface ${ref} extends ${joinFrags(bases, ", ")} {}`]);
                sc.writeln([
                    dts `declare `,
                    ...frag `const ${ref}`,
                    t `: ${ref}`,
                    r ` = $.makeType`,
                    ts `<${ref}>`,
                    r `(_.spec, "${type.id}", _.syntax.literal);`,
                ]);
                sc.nl();
                sc.addExport(ref);
            }
            continue;
        }
        if (type.enum_values && type.enum_values.length) {
            sc.writeln([
                t `export `,
                dts `declare `,
                t `type ${ref} = {\n`,
                ...type.enum_values.map(val => t `  ${toIdent(val)}: $.$expr_Literal<${ref}>;\n`),
                t `} & `,
                t `$.EnumType<${quote(type.name)}, [${type.enum_values
                    .map(val => quote(val))
                    .join(", ")}]>;`,
            ]);
            sc.writeln([
                dts `declare `,
                ...frag `const ${literal}`,
                t `: ${ref}`,
                r ` = $.makeType`,
                ts `<${ref}>`,
                r `(_.spec, "${type.id}", _.syntax.literal);`,
            ]);
            sc.nl();
            sc.addExport(literal);
            sc.addToDefaultExport(literal, _name);
            continue;
        }
        const tsType = toTSScalarType(type, types);
        if (type.castType) {
            const mapped = types.get(type.castType);
            const mappedRef = getRef(mapped.name);
            const extraTypes = (((_a = scalarToLiteralMapping[mapped.name]) === null || _a === void 0 ? void 0 : _a.extraTypes) || ["never"]).join(" | ");
            sc.writeln([
                t `export `,
                dts `declare `,
                t `type ${ref} = $.ScalarType<"${mapped.name}", ${tsType}>;`,
            ]);
            sc.writeln([
                dts `declare `,
                ...frag `const ${literal}`,
                t `: $.scalarTypeWithConstructor<${mappedRef}, ${extraTypes}>`,
                r ` = $.makeType`,
                ts `<$.scalarTypeWithConstructor<${mappedRef}, ${extraTypes}>>`,
                r `(_.spec, "${type.id}", _.syntax.literal);`,
            ]);
        }
        else {
            const extraTypes = (((_b = scalarToLiteralMapping[type.name]) === null || _b === void 0 ? void 0 : _b.extraTypes) || ["never"]).join(" | ");
            sc.writeln([
                t `export `,
                dts `declare `,
                t `type ${ref} = $.ScalarType<"${type.name}", ${tsType}>;`,
            ]);
            sc.writeln([
                dts `declare `,
                ...frag `const ${literal}`,
                t `: $.scalarTypeWithConstructor<${ref}, ${extraTypes}>`,
                r ` = $.makeType`,
                ts `<$.scalarTypeWithConstructor<${ref}, ${extraTypes}>>`,
                r `(_.spec, "${type.id}", _.syntax.literal);`,
            ]);
        }
        if ((_c = casts.implicitCastFromMap[type.id]) === null || _c === void 0 ? void 0 : _c.length) {
            sc.writeln([
                t `export `,
                dts `declare `,
                t `type ${ref}λICastableTo = ${joinFrags([
                    ref,
                    ...casts.implicitCastFromMap[type.id].map(typeId => getRef(types.get(typeId).name)),
                ], " | ")};`,
            ]);
        }
        const assignableMap = casts.assignableByMap[type.id] || [];
        if ((_d = casts.assignableByMap[type.id]) === null || _d === void 0 ? void 0 : _d.length) {
            sc.writeln([
                t `export `,
                dts `declare `,
                t `type ${ref}λIAssignableBy = ${joinFrags(assignableMap.length
                    ? [
                        ref,
                        ...assignableMap.map(typeId => getRef(types.get(typeId).name)),
                    ]
                    : [ref], " | ")};`,
            ]);
        }
        sc.addExport(literal);
        if (_name !== "number")
            sc.addToDefaultExport(literal, _name);
        sc.nl();
    }
};

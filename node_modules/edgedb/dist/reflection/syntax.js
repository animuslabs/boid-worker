module.exports.syntax = {"dts":[{"path":"cast.d.ts","content":"import { Expression, ExpressionKind, BaseType, TypeSet, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { orScalarLiteral } from \"../castMaps\";\nexport declare function cast<Target extends BaseType>(target: Target, arg: null): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Expr>;\nexport declare type $expr_Cast<Target extends BaseType = BaseType, Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Target;\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Cast;\n    __expr__: Expr | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, cardinalityUtil, Cardinality, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType } from \"edgedb/dist/reflection/index\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"../castMaps\";\nexport declare type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ndeclare type assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport declare type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport declare type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardinalityUtil.assignable<Set[\"__cardinality__\"]>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardinalityUtil.assignable<cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ndeclare type getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ndeclare type castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport declare type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardinalityUtil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"collections.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, cardinalityUtil, ExpressionRoot, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, TupleType, TypeSet, typeutil } from \"edgedb/dist/reflection/index\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral, scalarLiterals } from \"../castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardinalityUtil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport type { ArrayType as $Array, NamedTupleType as $NamedTuple, TupleType as $Tuple, } from \"edgedb/dist/reflection/index\";\n"},{"path":"detached.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport declare type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: Expr;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Expression, BaseType, BaseTypeSet, Cardinality, ExpressionKind, cardinalityUtil } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_For<IterSet extends BaseTypeSet = BaseTypeSet, Expr extends Expression = Expression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: cardinalityUtil.multiplyCardinalities<IterSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>;\n    __kind__: ExpressionKind.For;\n    __iterSet__: IterSet;\n    __forVar__: $expr_ForVar;\n    __expr__: Expr;\n}>;\nexport declare type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<IteratorSet, Expr>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { BaseType, BaseTypeSet, Cardinality, introspect } from \"edgedb/dist/reflection/index\";\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { Expression, ExpressionKind, BaseType, Cardinality } from \"edgedb/dist/reflection/index\";\nexport declare function makeGlobal<Name extends string, Type extends BaseType, Card extends Cardinality>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card>;\nexport declare type $expr_Global<Name extends string = string, Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: Name;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"edgedb/dist/reflection/index\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"../modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ndeclare type SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ndeclare type SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ndeclare type GroupModifiers = {\n    by: SimpleGroupElements;\n};\ndeclare type NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport declare type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport declare type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: Expr;\n    __scope__: ObjectTypeSet;\n}>;\ndeclare type noUndefined<T> = T extends undefined ? never : T;\ndeclare type groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"insert.d.ts","content":"import { Cardinality, Expression, ExpressionKind, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, typeutil, $scopify, stripSet, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"edgedb/dist/reflection/path\";\nimport type { $Object } from \"../modules/std\";\nimport type { scalarLiterals } from \"../castMaps\";\nexport declare type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport declare type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<RawInsertShape<Root>>;\nexport declare type RawInsertShape<Root extends ObjectTypeSet> = $expr_PathNode extends Root ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ndeclare type InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport declare type $expr_Insert<Root extends $expr_PathNode = $expr_PathNode> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: Root;\n    __shape__: InsertShape<Root>;\n    unlessConflict(): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, Conflict>;\n}>;\nexport declare type $expr_InsertUnlessConflict<Root extends InsertBaseExpression = InsertBaseExpression, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"] ? Root[\"__element__\"] : $Object : Root[\"__element__\"];\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: Root;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root>): $expr_Insert<Root>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import { BaseType, BaseTypeToTsType, ScalarType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { Expression, ExpressionKind, ParamType, Cardinality, setToTsType, TypeSet, BaseTypeToTsType } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport declare type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport declare type $expr_WithParams<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ndeclare type paramsToParamArgs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key]>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null> : never;\n};\nexport declare type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ndeclare type paramsToParamExprs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ObjectTypeSet, TypeSet, Expression } from \"edgedb/dist/reflection/index\";\nimport type { PathParent, $expr_PathLeaf, $expr_PathNode, $pathify, ExpressionRoot } from \"edgedb/dist/reflection/path\";\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent, Exclusive>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent, Exclusive>;\ndeclare function _$pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { _$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport { RangeType, $expr_Literal, getPrimitiveBaseType, TypeSet, $expr_Function, cardinalityUtil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"../modules/std\";\nimport type { $local_date, $local_datetime } from \"../modules/cal\";\nimport type { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral } from \"../castMaps\";\ndeclare type $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, mapLiteralToTypeSet<NamedArgs>, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, {}, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>>>;\nexport { range as $range };\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"../modules/std\";\nimport { $expr_PolyShapeElement, $scopify, Cardinality, cardinalityUtil, Expression, ExpressionKind, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, typeutil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_PathLeaf, $expr_PathNode, $linkPropify, ExpressionRoot, PathParent } from \"edgedb/dist/reflection/path\";\nimport type { anonymizeObject } from \"./casting\";\nimport type { $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport { scalarLiterals, literalToScalarType } from \"../castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport declare type OrderByDirection = \"ASC\" | \"DESC\";\nexport declare type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport declare type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport declare type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport declare type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport declare type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport declare type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\nexport declare type SelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport declare type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport declare type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n};\nexport declare type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\ndeclare type argCardToResultCard<OpCard extends Cardinality, BaseCase extends Cardinality> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One] ? Cardinality.AtMostOne : [OpCard] extends [Cardinality.Empty] ? Cardinality.Empty : BaseCase;\nexport declare type InferFilterCardinality<Base extends TypeSet, Filter> = Filter extends TypeSet ? Base extends ObjectTypeSet ? Filter extends $expr_Operator<\"=\", any, infer Args, any> ? Args[0] extends $expr_PathLeaf ? Args[0][\"__exclusive__\"] extends true ? typeutil.assertEqual<Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Args[0] extends $expr_PathNode<any, any, any> ? Args[0][\"__exclusive__\"] extends true ? Args[0][\"__parent__\"] extends null ? typeutil.assertEqual<Args[0][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Args[0][\"__parent__\"] extends infer Parent ? Parent extends PathParent ? typeutil.assertEqual<Parent[\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"];\nexport declare type InferOffsetLimitCardinality<Card extends Cardinality, Modifers extends UnknownSelectModifiers> = Modifers[\"limit\"] extends number | LimitExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Modifers[\"offset\"] extends number | OffsetExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport declare type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<InferFilterCardinality<Expr, Modifiers[\"filter\"]>, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, rootExpr: TypeSet): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n};\nexport declare type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport declare type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>, {\n        type: $scopify<Desc[\"target\"]>;\n        linkName: k;\n    }, Desc[\"properties\"][k][\"exclusive\"]>;\n};\nexport declare type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, {}>;\ndeclare type linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\nexport declare type linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardinalityUtil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\nexport declare type objectTypeToSelectShape<T extends ObjectType = ObjectType> = Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc ? boolean | TypeSet<T[\"__pointers__\"][k][\"target\"], cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>> : T[\"__pointers__\"][k] extends LinkDesc ? linkDescToSelectElement<T[\"__pointers__\"][k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport declare type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport declare type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>, true>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers>(expr: Expr, _shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Expr[\"__element__\"][\"__shape__\"]>;\n    __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Omit<normaliseShape<Shape>, SelectModifierNames>>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ExpressionKind, mergeObjectTypes, ObjectType, Cardinality, getPrimitiveBaseType, SomeType } from \"edgedb/dist/reflection/index\";\nimport * as castMaps from \"../castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport declare type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: Expression<Set>[];\n    __kind__: ExpressionKind.Set;\n}>;\ndeclare type mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport declare type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ndeclare type _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport declare type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport declare type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ndeclare type _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport declare type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport declare type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport declare type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport declare type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, $expr_TuplePath } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"edgedb/dist/reflection/path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport declare type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"update.d.ts","content":"import { Expression, ExpressionKind, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, typeutil, ObjectTypeExpression, $scopify, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { SelectModifiers, NormalisedSelectModifiers, ComputeSelectCardinality } from \"./select\";\nimport { pointerIsOptional } from \"./insert\";\nexport declare type $expr_Update<Set extends TypeSet = TypeSet, Expr extends ObjectTypeSet = ObjectTypeSet, Shape extends UpdateShape<Expr> = any> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: Expr;\n    __shape__: Shape;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport declare type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n}, Expr, Shape[\"set\"]>;\n"},{"path":"with.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport declare type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Alias;\n    __expr__: Expr;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr>;\nexport declare type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport declare type $expr_With<Refs extends TypeSet[] = TypeSet[], Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: Refs;\n}>;\ndeclare function _with<Refs extends Expression[], Expr extends WithableExpression>(refs: Refs, expr: Expr): $expr_With<Refs, Expr>;\nexport { _with as with };\n"}],"deno":[{"path":"cast.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  TypeSet,\n  Cardinality,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\nimport type {orScalarLiteral} from \"../castMaps.ts\";\nimport {literalToTypeSet} from \"../castMaps.ts\";\n\nexport function cast<Target extends BaseType>(\n  target: Target,\n  arg: null\n): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\n  target: Target,\n  expr: orScalarLiteral<Expr>\n): $expr_Cast<Target, Expr>;\nexport function cast(target: BaseType, expr: any) {\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\n  return $expressionify({\n    __element__: target,\n    __cardinality__:\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\n    __expr__: cleanedExpr,\n    __kind__: ExpressionKind.Cast,\n  }) as any;\n}\n\nexport type $expr_Cast<\n  Target extends BaseType = BaseType,\n  Expr extends TypeSet = TypeSet\n> = Expression<{\n  __element__: Target;\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Cast;\n  __expr__: Expr | null;\n}>;\n"},{"path":"casting.ts","content":"import type {\n  ArrayType,\n  BaseType,\n  BaseTypeTuple,\n  BaseTypeToTsType,\n  cardinalityUtil,\n  Cardinality,\n  EnumType,\n  LinkDesc,\n  NamedTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  TupleType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {\n  scalarCastableFrom,\n  scalarAssignableBy,\n} from \"../castMaps.ts\";\n\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\n  string,\n  T[\"__pointers__\"],\n  any\n>;\n\n////////////////\n// ASSIGNABLE\n////////////////\n\ntype assignableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? assignableBy<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type assignableBy<T extends BaseType> = T extends ScalarType\n  ? scalarAssignableBy<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends EnumType\n  ? T\n  : T extends ArrayType\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n    }>\n  : T extends RangeType\n  ? RangeType<\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\n        ? scalarAssignableBy<T[\"__element__\"]>\n        : never\n    >\n  : never;\n\nexport type pointerToAssignmentExpression<\n  Pointer extends PropertyDesc | LinkDesc,\n  IsSetModifier extends boolean = false\n> = setToAssignmentExpression<\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\n  IsSetModifier\n>;\n\nexport type setToAssignmentExpression<\n  Set extends TypeSet,\n  IsSetModifier extends boolean\n> = [Set] extends [PrimitiveTypeSet]\n  ?\n      | TypeSet<\n          assignableBy<Set[\"__element__\"]>,\n          cardinalityUtil.assignable<Set[\"__cardinality__\"]>\n        >\n      | getAssignmentLiteral<Set, IsSetModifier>\n  : [Set] extends [ObjectTypeSet]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Set[\"__element__\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<\n        // Allow expressions with AtMostOne or Many cardinality in\n        // insert/update shape even when link is required since EdgeDB will\n        // assert cardinality at runtime\n        cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\n      >\n    >\n  : never;\n\ntype getAssignmentLiteral<\n  Set extends PrimitiveTypeSet,\n  IsSetModifier extends boolean\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\n  ?\n      | TsType\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\n          ? TsType[]\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\n          ? IsSetModifier extends true\n            ? TsType[]\n            : [TsType, ...TsType[]]\n          : never)\n  : never;\n\n////////////////\n// CASTABLES\n////////////////\n\ntype castableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? castableFrom<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type castableFrom<T extends BaseType> = T extends ScalarType\n  ? scalarCastableFrom<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends ArrayType\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<castableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n    }>\n  : never;\n\nexport type pointerToCastableExpression<\n  Pointer extends PropertyDesc | LinkDesc\n> = [Pointer] extends [PropertyDesc]\n  ? {\n      __element__: castableFrom<Pointer[\"target\"]>;\n      __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n    }\n  : [Pointer] extends [LinkDesc]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Pointer[\"target\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<Pointer[\"cardinality\"]>\n    >\n  : never;\n"},{"path":"collections.ts","content":"import {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  ArrayType,\n  BaseType,\n  Cardinality,\n  cardinalityUtil,\n  ExpressionKind,\n  ExpressionRoot,\n  getPrimitiveBaseType,\n  NamedTupleLiteralShape,\n  NamedTupleShape,\n  NamedTupleType,\n  NonArrayType,\n  TupleType,\n  TypeKind,\n  TypeSet,\n  typeutil,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\nimport type {getCardsFromExprs} from \"./set.ts\";\nimport {\n  literalToScalarType,\n  literalToTypeSet,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n  scalarLiterals,\n} from \"../castMaps.ts\";\n\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\n\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n    if (match) {\n      const start = match[1];\n      const end = match[3] ?? match[4];\n      const isIndex = start && !match[2];\n      return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__:\n          target.__element__.__kind__ === TypeKind.array && isIndex\n            ? (target.__element__ as ArrayType).__element__\n            : target.__element__,\n        __cardinality__: target.__cardinality__,\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [\n          proxy,\n          isIndex\n            ? literalToTypeSet(Number(start))\n            : [\n                start && literalToTypeSet(Number(start)),\n                end && literalToTypeSet(Number(end)),\n              ],\n        ],\n      }) as any;\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\n  const indexTypeSet = literalToTypeSet(index);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__:\n      this.__element__.__kind__ === TypeKind.array\n        ? (this.__element__ as ArrayType).__element__\n        : this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      indexTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, indexTypeSet],\n  }) as any;\n}\n\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\n  const startTypeSet = start && literalToTypeSet(start);\n  const endTypeSet = end && literalToTypeSet(end);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.multiplyCardinalities(\n        this.__cardinality__,\n        startTypeSet?.__cardinality__ ?? Cardinality.One\n      ),\n      endTypeSet?.__cardinality__ ?? Cardinality.One\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, [startTypeSet, endTypeSet]],\n  }) as any;\n}\n\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.array ||\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\n      (_expr.__element__.__name__ === \"std::str\" ||\n        _expr.__element__.__name__ === \"std::bytes\"))\n  ) {\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\n\n    expr.index = arrayLikeIndex.bind(expr);\n    expr.slice = arrayLikeSlice.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\n// ARRAY\nexport function array<Element extends NonArrayType>(\n  element: Element\n): ArrayType<Element>;\nexport function array<\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\n  Exprs extends orScalarLiteral<\n    TypeSet<\n      Expr extends TypeSet\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\n    >\n  >[]\n>(\n  arg: [Expr, ...Exprs]\n): $expr_Array<\n  ArrayType<\n    Expr extends TypeSet\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\n  >,\n  cardinalityUtil.multiplyCardinalitiesVariadic<\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\n  >\n>;\nexport function array(arg: any) {\n  if (Array.isArray(arg)) {\n    const items = arg.map(a => literalToTypeSet(a));\n    return $expressionify({\n      __kind__: ExpressionKind.Array,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(item => item.__cardinality__) as any\n      ),\n      __element__: {\n        __kind__: TypeKind.array,\n        __name__: `array<${items[0].__element__.__name__}>`,\n        __element__: items[0].__element__,\n      } as any,\n      __items__: items,\n    });\n  }\n  if (arg.__kind__) {\n    return {\n      __kind__: TypeKind.array,\n      __name__: `array<${arg.__name__}>`,\n      __element__: arg,\n    } as any;\n  }\n\n  throw new Error(\"Invalid array input.\");\n}\n\n// TUPLE\n\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const type = target.__element__;\n    const items =\n      type.__kind__ === TypeKind.tuple\n        ? (type as TupleType).__items__\n        : type.__kind__ === TypeKind.namedtuple\n        ? (type as NamedTupleType).__shape__\n        : null;\n    return items?.hasOwnProperty(prop)\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\n      : (target as any)[prop];\n  },\n};\n\nexport function $tuplePathify(expr: ExpressionRoot) {\n  if (\n    expr.__element__.__kind__ !== TypeKind.tuple &&\n    expr.__element__.__kind__ !== TypeKind.namedtuple\n  ) {\n    return expr;\n  }\n\n  return new Proxy(expr, tupleProxyHandlers);\n}\n\nfunction tuplePath(\n  parent: $expr_Tuple | $expr_TuplePath,\n  itemType: BaseType,\n  index: string\n): $expr_TuplePath {\n  return $expressionify({\n    __kind__: ExpressionKind.TuplePath,\n    __element__: itemType,\n    __cardinality__: parent.__cardinality__,\n    __parent__: parent,\n    __index__: index,\n  }) as any;\n}\n\nfunction makeTupleType(name: string, items: BaseType[]) {\n  return {\n    __kind__: TypeKind.tuple,\n    __name__: name,\n    __items__: items,\n  } as any;\n}\n\nconst typeKinds = new Set(Object.values(TypeKind));\n\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\n  items: Items\n): TupleType<Items>;\nexport function tuple<\n  Item extends TypeSet | scalarLiterals,\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\n>(\n  items: Items\n): $expr_Tuple<\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\n>;\nexport function tuple<Shape extends NamedTupleShape>(\n  shape: Shape\n): NamedTupleType<Shape>;\nexport function tuple<Shape extends {[k: string]: TypeSet | scalarLiterals}>(\n  shape: Shape\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport function tuple(input: any) {\n  if (Array.isArray(input)) {\n    // is tuple\n    if (input.every(item => typeKinds.has(item.__kind__))) {\n      const typeItems = input as BaseType[];\n      const typeName = `tuple<${typeItems\n        .map(item => item.__name__)\n        .join(\", \")}>`;\n      return makeTupleType(typeName, typeItems);\n    }\n\n    const items = input.map(item => literalToTypeSet(item));\n    const name = `tuple<${items\n      .map(item => item.__element__.__name__)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.Tuple,\n      __element__: makeTupleType(\n        name,\n        items.map(item => item.__element__)\n      ),\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(i => i.__cardinality__) as any\n      ),\n      __items__: items,\n    }) as any;\n  } else {\n    // is named tuple\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\n      const typeName = `tuple<${Object.entries(input)\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n        .join(\", \")}>`;\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: typeName,\n        __shape__: input,\n      } as any;\n    }\n\n    const exprShape: NamedTupleLiteralShape = {};\n    const typeShape: NamedTupleShape = {};\n    for (const [key, val] of Object.entries(input)) {\n      exprShape[key] = literalToTypeSet(val);\n      typeShape[key] = exprShape[key].__element__;\n    }\n    const name = `tuple<${Object.entries(exprShape)\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.NamedTuple,\n      __element__: {\n        __kind__: TypeKind.namedtuple,\n        __name__: name,\n        __shape__: typeShape,\n      } as any,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        Object.values(exprShape).map(val => val.__cardinality__) as any\n      ),\n      __shape__: exprShape,\n    }) as any;\n  }\n}\n\nexport type {\n  ArrayType as $Array,\n  NamedTupleType as $NamedTuple,\n  TupleType as $Tuple,\n} from \"edgedb/_src/reflection/index.ts\";\n"},{"path":"detached.ts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\n\nexport function detached<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Detached<Expr> {\n  return $expressionify({\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n    __kind__: ExpressionKind.Detached,\n  }) as any;\n}\n\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Detached;\n  __expr__: Expr;\n}>;\n"},{"path":"external.ts","content":"import type {TypeSet, setToTsType} from \"edgedb/_src/reflection/index.ts\";\n\nexport {literal} from \"./literal.ts\";\nexport {} from \"./path.ts\";\nexport {set} from \"./set.ts\";\nexport {cast} from \"./cast.ts\";\nexport {\n  ASC,\n  DESC,\n  EMPTY_FIRST,\n  EMPTY_LAST,\n  is,\n  delete,\n  select,\n} from \"./select.ts\";\nexport {update} from \"./update.ts\";\nexport {insert} from \"./insert.ts\";\nexport {array, tuple} from \"./collections.ts\";\nexport {} from \"./funcops.ts\";\nexport {for} from \"./for.ts\";\nexport {alias, with} from \"./with.ts\";\nexport {optional, params} from \"./params.ts\";\nexport {detached} from \"./detached.ts\";\nexport {} from \"./toEdgeQL.ts\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.ts","content":"import {\n  Expression,\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  ExpressionKind,\n  cardinalityUtil,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\n\nexport type $expr_For<\n  IterSet extends BaseTypeSet = BaseTypeSet,\n  Expr extends Expression = Expression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: cardinalityUtil.multiplyCardinalities<\n    IterSet[\"__cardinality__\"],\n    Expr[\"__cardinality__\"]\n  >;\n  __kind__: ExpressionKind.For;\n  __iterSet__: IterSet;\n  __forVar__: $expr_ForVar;\n  __expr__: Expr;\n}>;\n\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n  __element__: Type;\n  __cardinality__: Cardinality.One;\n  __kind__: ExpressionKind.ForVar;\n}>;\n\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(\n  set: IteratorSet,\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\n): $expr_For<IteratorSet, Expr> {\n  const forVar = $expressionify({\n    __kind__: ExpressionKind.ForVar,\n    __element__: set.__element__,\n    __cardinality__: Cardinality.One,\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\n\n  const returnExpr = expr(forVar);\n\n  return $expressionify({\n    __kind__: ExpressionKind.For,\n    __element__: returnExpr.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      set.__cardinality__,\n      returnExpr.__cardinality__\n    ),\n    __iterSet__: set,\n    __expr__: returnExpr,\n    __forVar__: forVar,\n  }) as any;\n}\n\nexport {_for as for};\n"},{"path":"funcops.ts","content":"import {\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  introspect,\n  makeType,\n  TypeKind,\n  ArrayType,\n  cardinalityUtil,\n  ObjectType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {cast} from \"./cast.ts\";\nimport {isImplicitlyCastableTo, literalToTypeSet} from \"../castMaps.ts\";\nimport {literal} from \"./literal.ts\";\n\ninterface OverloadFuncArgDef {\n  typeId: string;\n  optional?: boolean;\n  setoftype?: boolean;\n  variadic?: boolean;\n}\n\ninterface OverloadFuncDef {\n  kind?: string;\n  args: OverloadFuncArgDef[];\n  namedArgs?: {[key: string]: OverloadFuncArgDef};\n  returnTypeId: string;\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\n  preservesOptionality?: boolean;\n}\n\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\nfunction mapLiteralToTypeSet(literals: {[key: string]: any}): {\n  [key: string]: TypeSet;\n};\nfunction mapLiteralToTypeSet(literals: any[] | {[key: string]: any}) {\n  if (Array.isArray(literals)) {\n    return literals.map(lit => (lit != null ? literalToTypeSet(lit) : lit));\n  }\n  const obj: {[key: string]: TypeSet} = {};\n  for (const key of Object.keys(literals)) {\n    obj[key] =\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\n  }\n  return obj;\n}\n\nexport function $resolveOverload(\n  funcName: string,\n  args: any[],\n  typeSpec: introspect.Types,\n  funcDefs: OverloadFuncDef[]\n) {\n  const positionalArgs: (TypeSet | undefined)[] = [];\n  let namedArgs: {[key: string]: TypeSet} | undefined;\n  if (args.length) {\n    if (args[0] !== undefined) {\n      try {\n        positionalArgs.push(literalToTypeSet(args[0]));\n      } catch {\n        // first arg is not a expr or literal type, so assume named args object\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\n      }\n    } else {\n      positionalArgs.push(undefined);\n    }\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n  }\n\n  for (const def of funcDefs) {\n    const resolvedOverload = _tryOverload(\n      funcName,\n      positionalArgs,\n      namedArgs,\n      typeSpec,\n      def\n    );\n    if (resolvedOverload !== null) {\n      return resolvedOverload;\n    }\n  }\n\n  throw new Error(\n    `No function overload found for ${\n      funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\")[1]}()'`\n        : `operator '${funcName}'`\n    } with args: ${args.map(arg => `${arg}`).join(\", \")}`\n  );\n}\n\nconst ANYTYPE_ARG = Symbol();\n\nfunction _tryOverload(\n  funcName: string,\n  args: (BaseTypeSet | undefined)[],\n  namedArgs: {[key: string]: BaseTypeSet} | undefined,\n  typeSpec: introspect.Types,\n  funcDef: OverloadFuncDef\n): {\n  kind?: string;\n  returnType: BaseType;\n  cardinality: Cardinality;\n  args: BaseTypeSet[];\n  namedArgs: {[key: string]: BaseTypeSet};\n} | null {\n  if (\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n    (namedArgs === undefined &&\n      funcDef.namedArgs &&\n      Object.values(funcDef.namedArgs).some(arg => !arg.optional))\n  ) {\n    return null;\n  }\n\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\n    return null;\n  }\n\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [\n    Cardinality.One,\n  ];\n\n  if (namedArgs) {\n    for (const [key, value] of Object.entries(namedArgs)) {\n      const argDef = funcDef.namedArgs?.[key];\n      if (\n        !argDef ||\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\n      ) {\n        return null;\n      }\n\n      paramCardinalities.push(\n        argDef.setoftype\n          ? funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(value.__cardinality__, \"One\")\n            : Cardinality.One\n          : argDef.optional\n          ? cardinalityUtil.overrideLowerBound(value.__cardinality__, \"One\")\n          : value.__cardinality__\n      );\n    }\n  }\n\n  let positionalArgs: BaseTypeSet[] = [];\n\n  let returnAnytype: BaseType | undefined;\n  let needsAnytypeReplacement = false;\n\n  for (let i = 0; i < funcDef.args.length; i++) {\n    const argDef = funcDef.args[i];\n    const arg = args[i];\n\n    if (arg === undefined) {\n      if (!argDef.optional) {\n        return null;\n      }\n\n      if (i < args.length) {\n        // arg is explicitly undefined, inject empty set\n        const argTypeName = typeSpec.get(argDef.typeId).name;\n        if (\n          argTypeName.includes(\"anytype\") ||\n          argTypeName.includes(\"std::anypoint\")\n        ) {\n          if (!returnAnytype) {\n            positionalArgs.push(ANYTYPE_ARG as any);\n            needsAnytypeReplacement = true;\n          } else {\n            positionalArgs.push(cast(returnAnytype, null));\n          }\n        } else {\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\n          positionalArgs.push(cast(argType, null));\n        }\n      }\n    } else {\n      const {match, anytype} = compareType(\n        typeSpec,\n        argDef.typeId,\n        arg.__element__\n      );\n\n      if (!match) {\n        return null;\n      }\n      if (!returnAnytype && anytype) {\n        returnAnytype = anytype;\n      }\n\n      positionalArgs.push(\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\n      );\n      if (argDef.setoftype) {\n        paramCardinalities.push(\n          funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(arg.__cardinality__, \"One\")\n            : Cardinality.One\n        );\n      } else {\n        const card = argDef.variadic\n          ? cardinalityUtil.multiplyCardinalitiesVariadic(\n              (args.slice(i) as BaseTypeSet[]).map(\n                el => el.__cardinality__\n              ) as [Cardinality, ...Cardinality[]]\n            )\n          : arg.__cardinality__;\n\n        paramCardinalities.push(\n          argDef.optional\n            ? cardinalityUtil.overrideLowerBound(card, \"One\")\n            : card\n        );\n      }\n    }\n  }\n\n  let cardinality: Cardinality;\n  if (funcName === \"if_else\") {\n    cardinality = cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.orCardinalities(\n        positionalArgs[0].__cardinality__,\n        positionalArgs[2].__cardinality__\n      ),\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"std::assert_exists\") {\n    cardinality = cardinalityUtil.overrideLowerBound(\n      positionalArgs[0].__cardinality__,\n      \"One\"\n    );\n  } else if (funcName === \"union\") {\n    cardinality = cardinalityUtil.mergeCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"??\") {\n    cardinality = cardinalityUtil.orCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"distinct\") {\n    cardinality = positionalArgs[0].__cardinality__;\n  } else {\n    cardinality =\n      funcDef.returnTypemod === \"SetOfType\"\n        ? Cardinality.Many\n        : cardinalityUtil.multiplyCardinalitiesVariadic(paramCardinalities);\n\n    if (\n      funcDef.returnTypemod === \"OptionalType\" &&\n      !funcDef.preservesOptionality\n    ) {\n      cardinality = cardinalityUtil.overrideLowerBound(cardinality, \"Zero\");\n    }\n  }\n\n  if (needsAnytypeReplacement) {\n    if (!returnAnytype) {\n      throw new Error(`could not resolve anytype for ${funcName}`);\n    }\n    positionalArgs = positionalArgs.map(arg =>\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\n    );\n  }\n\n  return {\n    kind: funcDef.kind,\n    returnType: makeType(\n      typeSpec,\n      funcDef.returnTypeId,\n      literal,\n      returnAnytype\n    ),\n    cardinality,\n    args: positionalArgs,\n    namedArgs: namedArgs ?? {},\n  };\n}\n\nconst nameRemapping: {[key: string]: string} = {\n  \"std::int16\": \"std::number\",\n  \"std::int32\": \"std::number\",\n  \"std::int64\": \"std::number\",\n  \"std::float32\": \"std::number\",\n  \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map<string, string[]>();\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\n  if (descendantCache.has(typeId)) {\n    return descendantCache.get(typeId)!;\n  }\n  const descendants: string[] = [\n    ...new Set(\n      [...typeSpec.values()]\n        .filter(\n          type =>\n            type.kind === \"scalar\" && type.bases.some(({id}) => id === typeId)\n        )\n        .flatMap(type =>\n          type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name]\n        )\n    ),\n  ];\n  descendantCache.set(typeId, descendants);\n  return descendants;\n}\n\nfunction compareType(\n  typeSpec: introspect.Types,\n  typeId: string,\n  arg: BaseType\n): {match: boolean; anytype?: BaseType} {\n  const type = typeSpec.get(typeId);\n\n  if (type.name === \"anytype\") {\n    return {match: true, anytype: arg};\n  }\n\n  if (type.name === \"std::anypoint\") {\n    const descendants = getDescendantNames(typeSpec, typeId);\n    if (descendants.includes(arg.__name__)) {\n      return {match: true, anytype: arg};\n    }\n  }\n\n  if (type.name === \"std::anyenum\") {\n    return {match: arg.__kind__ === TypeKind.enum};\n  }\n\n  if (type.kind === \"scalar\") {\n    arg = (arg as any).__casttype__ ?? arg;\n    return {\n      match:\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\n        (arg.__name__ === type.name ||\n          isImplicitlyCastableTo(arg.__name__, type.name)),\n    };\n  }\n  if (type.kind === \"array\") {\n    if (arg.__kind__ === TypeKind.array) {\n      return compareType(\n        typeSpec,\n        type.array_element_id,\n        (arg as any as ArrayType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"range\") {\n    if (arg.__kind__ === TypeKind.range) {\n      return compareType(\n        typeSpec,\n        type.range_element_id,\n        (arg as any as RangeType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"object\") {\n    if (arg.__kind__ !== TypeKind.object) return {match: false};\n\n    const objectArg = arg as ObjectType;\n    let match = true;\n\n    // shape comparison\n    for (const ptr of type.pointers) {\n      if (objectArg.__pointers__[ptr.name]) {\n        const argPtr = objectArg.__pointers__[ptr.name];\n        const ptrTarget = typeSpec.get(ptr.target_id);\n        if (\n          ptrTarget.name !== argPtr.target.__name__ ||\n          ptr.real_cardinality !== argPtr.cardinality\n        ) {\n          match = false;\n        }\n      }\n    }\n\n    return {\n      match,\n    };\n  }\n  if (type.kind === \"tuple\") {\n    const items =\n      arg.__kind__ === TypeKind.tuple\n        ? (arg as any).__items__\n        : arg.__kind__ === TypeKind.namedtuple\n        ? (arg as any).__shape__\n        : null;\n    if (items) {\n      const keys = Object.keys(items);\n\n      if (keys.length === type.tuple_elements.length) {\n        let anytype: BaseType | undefined;\n        for (let i = 0; i < keys.length; i++) {\n          if (keys[i] !== type.tuple_elements[i].name) {\n            return {match: false};\n          }\n          const {match: m, anytype: a} = compareType(\n            typeSpec,\n            type.tuple_elements[i].target_id,\n            (items as any)[keys[i]]\n          );\n          if (!m) {\n            return {match: false};\n          }\n          if (a) anytype = a;\n        }\n        return {match: true, anytype};\n      }\n    }\n  }\n\n  return {match: false};\n}\n"},{"path":"globals.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  Cardinality,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\n\nexport function makeGlobal<\n  Name extends string,\n  Type extends BaseType,\n  Card extends Cardinality\n>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card> {\n  return $expressionify({\n    __name__: name,\n    __element__: type,\n    __cardinality__: card,\n    __kind__: ExpressionKind.Global,\n  });\n}\n\nexport type $expr_Global<\n  Name extends string = string,\n  Type extends BaseType = BaseType,\n  Card extends Cardinality = Cardinality\n> = Expression<{\n  __name__: Name;\n  __element__: Type;\n  __cardinality__: Card;\n  __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.ts","content":"import type {\n  Expression,\n  ObjectType,\n  ObjectTypeSet,\n  TypeSet,\n  BaseType,\n  $scopify,\n  PropertyDesc,\n  LinkDesc,\n  // stripSet,\n  // LinkDesc,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {\n  Cardinality,\n  ExpressionKind,\n  TypeKind,\n  makeType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify, $getScopedExpr} from \"./path.ts\";\n// @ts-ignore\nimport type {$FreeObjectλShape, $str} from \"../modules/std.ts\";\nimport {spec} from \"../__spec__.ts\";\nimport {literal} from \"./literal.ts\";\nimport {resolveShapeElement} from \"./select.ts\";\nimport type {\n  normaliseShape,\n  // normaliseElement,\n  objectTypeToSelectShape,\n} from \"./select.ts\";\n\ntype SingletonSet = Expression<\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\n>;\ntype SimpleGroupElements = {[k: string]: SingletonSet};\ntype GroupModifiers = {by: SimpleGroupElements};\ntype NestedGroupElements = {\n  [k: string]: SingletonSet | GroupingSet;\n};\n\nexport type GroupingSet = {\n  __kind__: \"groupingset\";\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n  __elements__: NestedGroupElements;\n  __exprs__: [string, SingletonSet][];\n};\nexport function isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// result is partial to prevent \"X is specified more than once\" errors\n// the return type is a lie, this function returns a grouping set\n// but it pretends to return a SimpleGroupElements\n// to make the static computatation of `key` easier\nconst makeGroupingSet =\n  (prefix: string) =>\n  <T extends SimpleGroupElements>(grps: T): {[k in keyof T]?: T[k]} => {\n    const seenKeys = new Map<string, SingletonSet>();\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\n      ([k, grp]) =>\n        isGroupingSet(grp)\n          ? grp.__exprs__\n          : ([[k, grp]] as [string, SingletonSet][])\n    );\n    const filtered = unfiltered.filter(([k, expr]) => {\n      if (!seenKeys.has(k)) {\n        seenKeys.set(k, expr);\n        return true;\n      }\n\n      if (expr !== seenKeys.get(k)) {\n        throw new Error(\n          `Cannot override pre-existing expression with key \"${k}\"`\n        );\n      }\n\n      return false;\n    });\n\n    return {\n      [`${Math.round(1000000 * Math.random())}___`]: {\n        __kind__: \"groupingset\",\n        __settype__: prefix,\n        __elements__: grps,\n        __exprs__: filtered,\n      } as GroupingSet,\n    } as any;\n  };\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\n\nconst setFuncs = {set, tuple, rollup, cube};\n\nexport type $expr_Group<\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Mods extends GroupModifiers = GroupModifiers,\n  Shape extends object = {id: true}\n> = Expression<{\n  __element__: ObjectType<\n    \"std::FreeObject\",\n    $FreeObjectλShape & {\n      // adding free shape elements into __pointers__\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\n      // and setToTsType can't handle that currently\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n      key: LinkDesc<\n        ObjectType<\n          \"std::FreeObject\",\n          {\n            // tslint:disable-next-line\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\n              ? never\n              : PropertyDesc<\n                  Mods[\"by\"][k][\"__element__\"],\n                  Cardinality.AtMostOne\n                >;\n          }\n        >,\n        Cardinality.One,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n      elements: LinkDesc<\n        Expr[\"__element__\"],\n        Cardinality.Many,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n    },\n    {\n      // grouping: true;\n      // key: {[k in keyof Mods['by']]: true};\n      // elements: {id: true};\n      grouping: TypeSet<$str, Cardinality.Many>;\n      key: Expression<{\n        __element__: ObjectType<\n          \"std::FreeObject\",\n          $FreeObjectλShape,\n          {\n            [k in keyof Mods[\"by\"]]: Expression<{\n              __element__: Mods[\"by\"][k][\"__element__\"];\n              __cardinality__: Cardinality.AtMostOne;\n            }>;\n          }\n        >;\n        __cardinality__: Cardinality.One;\n      }>;\n      elements: Expression<{\n        __element__: ObjectType<\n          Expr[\"__element__\"][\"__name__\"],\n          Expr[\"__element__\"][\"__pointers__\"],\n          // Omit<normaliseShape<Shape>, \"by\">\n          normaliseShape<Shape, \"by\">\n        >;\n        __cardinality__: Cardinality.Many;\n      }>;\n    }\n  >;\n  __cardinality__: Cardinality.Many;\n  // bit of a lie, this is a GroupingSet at runtime\n  __modifiers__: Mods;\n  __kind__: ExpressionKind.Group;\n  __expr__: Expr;\n  __scope__: ObjectTypeSet;\n}>;\n\n// type modifierKeys = \"by\";\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <\n  Expr extends ObjectTypeSet,\n  // Shape extends GroupModifiers\n  // Grps extends SimpleGroupElements,\n  Shape extends {by?: SimpleGroupElements} & objectTypeToSelectShape<\n    Expr[\"__element__\"]\n  >\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\n>(\n  expr: Expr,\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n) => $expr_Group<\n  Expr,\n  {by: noUndefined<Shape[\"by\"]>},\n  normaliseShape<Shape, \"by\">\n>;\n\nconst groupFunc: groupFunc = (expr, getter) => {\n  const {shape, scope, modifiers} = resolveShape(getter, expr);\n  // const scope = $getScopedExpr(expr as any);\n  // const rawGroupings = getter(scope);\n  const groupSet = tuple(modifiers.by);\n\n  // only one key in object returned from makeGroupingSet\n  const key = Object.keys(groupSet)[0];\n  const grouping = groupSet[key] as any as GroupingSet;\n  const keyShape: any = {};\n  const keyPointers: any = {};\n  const keyShapeElement: any = {};\n\n  for (const [k, e] of grouping.__exprs__) {\n    keyShape[k] = $expressionify({\n      __element__: e.__element__,\n      __cardinality__: Cardinality.AtMostOne,\n    } as any);\n    keyPointers[k] = {\n      __kind__: \"property\",\n      target: e.__element__,\n      cardinality: Cardinality.AtMostOne,\n      exclusive: false,\n      computed: false,\n      readonly: false,\n      hasDefault: false,\n    } as PropertyDesc;\n    keyShapeElement[k] = true;\n  }\n\n  const $FreeObject = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n    literal\n  );\n\n  const str = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::str\")!.id,\n    literal\n  );\n\n  return $expressionify({\n    __element__: {\n      ...$FreeObject,\n      __name__: \"std::FreeObject\",\n      __pointers__: {\n        ...($FreeObject as any).__pointers__,\n        __name__: \"std::FreeObject\",\n        grouping: {\n          __kind__: \"property\",\n          target: str,\n          cardinality: Cardinality.Many,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as PropertyDesc,\n        key: {\n          __kind__: \"link\",\n          target: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n              ...($FreeObject as any).__pointers__,\n              ...keyPointers,\n            },\n            __shape__: keyShape,\n          },\n          properties: {},\n          cardinality: Cardinality.One,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n\n        elements: {\n          __kind__: \"link\",\n          target: expr.__element__,\n          cardinality: Cardinality.Many,\n          properties: {},\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n      },\n      __shape__: {\n        grouping: $expressionify({\n          __element__: str,\n          __cardinality__: Cardinality.Many,\n        } as any),\n        key: $expressionify({\n          __element__: {\n            ...$FreeObject,\n            __shape__: keyShape,\n          },\n          __cardinality__: Cardinality.One,\n        } as any),\n        elements: $expressionify({\n          __element__: {...expr.__element__, __shape__: shape} as any,\n          __cardinality__: Cardinality.Many,\n        } as any),\n      },\n    },\n\n    __cardinality__: Cardinality.Many,\n    __expr__: expr,\n    __modifiers__: {by: grouping},\n    __kind__: ExpressionKind.Group,\n    __scope__: scope,\n  }) as any;\n};\nObject.assign(groupFunc, setFuncs);\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: {by: SimpleGroupElements}; shape: any; scope: TypeSet} {\n  const modifiers: {by: SimpleGroupElements} = {} as any;\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (key === \"by\") {\n      modifiers[key] = value as any;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  if (Object.keys(shape).length === 0) {\n    shape.id = true;\n  }\n  if (!modifiers.by) {\n    throw new Error(\"Must provide a `by` key in `e.group`\");\n  }\n  return {shape, modifiers, scope};\n}\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\n"},{"path":"insert.ts","content":"import {\n  Cardinality,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  ObjectTypeSet,\n  ObjectTypePointers,\n  PropertyDesc,\n  stripBacklinks,\n  stripNonInsertables,\n  typeutil,\n  $scopify,\n  stripSet,\n  TypeSet,\n  TypeKind,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {pointerToAssignmentExpression} from \"./casting.ts\";\nimport {$expressionify, $getScopedExpr} from \"./path.ts\";\nimport {cast} from \"./cast.ts\";\nimport {set} from \"./set.ts\";\nimport {literal} from \"./literal.ts\";\nimport {$getTypeByName} from \"./literal.ts\";\nimport type {$expr_PathNode} from \"edgedb/_src/reflection/path.ts\";\nimport type {$Object} from \"../modules/std.ts\";\nimport type {scalarLiterals} from \"../castMaps.ts\";\n\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\n  T[\"cardinality\"] extends\n    | Cardinality.Many\n    | Cardinality.Empty\n    | Cardinality.AtMostOne\n    ? true\n    : false;\n\nexport type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<\n  RawInsertShape<Root>\n>;\n\nexport type RawInsertShape<Root extends ObjectTypeSet> =\n  // short-circuit infinitely deep\n  $expr_PathNode extends Root\n    ? never\n    : typeutil.stripNever<\n        stripNonInsertables<\n          stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>\n        >\n      > extends infer Shape\n    ? Shape extends ObjectTypePointers\n      ? typeutil.addQuestionMarks<{\n          [k in keyof Shape]:\n            | pointerToAssignmentExpression<Shape[k]>\n            | (pointerIsOptional<Shape[k]> extends true\n                ? undefined | null\n                : never)\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n        }> & {[k in `@${string}`]: TypeSet | scalarLiterals}\n      : never\n    : never;\n\ninterface UnlessConflict {\n  on: TypeSet | null;\n  else?: TypeSet;\n}\n\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: stripSet<Root>;\n  __shape__: any;\n};\nexport type $expr_Insert<\n  Root extends $expr_PathNode = $expr_PathNode\n  // Conflict = UnlessConflict | null\n  // Shape extends InsertShape<Root> = any\n> = Expression<{\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: Root;\n  __shape__: InsertShape<Root>;\n\n  unlessConflict(): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    {on: null}\n  >;\n  unlessConflict<Conflict extends UnlessConflict>(\n    conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict\n  ): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    Conflict\n  >;\n}>;\n\nexport type $expr_InsertUnlessConflict<\n  Root extends InsertBaseExpression = InsertBaseExpression,\n  Conflict extends UnlessConflict = UnlessConflict\n> = Expression<{\n  __kind__: ExpressionKind.InsertUnlessConflict;\n  __element__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"]\n      ? Root[\"__element__\"]\n      : $Object\n    : Root[\"__element__\"];\n  __cardinality__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__cardinality__\"]\n    : Cardinality.AtMostOne;\n  __expr__: Root;\n  __conflict__: Conflict;\n}>;\n\nfunction unlessConflict(\n  this: $expr_Insert,\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\n) {\n  const expr: any = {\n    __kind__: ExpressionKind.InsertUnlessConflict,\n    __element__: this.__element__,\n    __cardinality__: Cardinality.AtMostOne,\n    __expr__: this,\n    // __conflict__: Conflict;\n  };\n\n  if (!conflictGetter) {\n    expr.__conflict__ = {on: null};\n    return $expressionify(expr);\n  } else {\n    const scopedExpr = $getScopedExpr(this.__expr__);\n    const conflict = conflictGetter(scopedExpr);\n    expr.__conflict__ = conflict;\n    if (conflict.else) {\n      expr.__cardinality__ = conflict.else.__cardinality__;\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n        expr.__element__ = $getTypeByName(\"std::Object\");\n      }\n    }\n    return $expressionify(expr);\n  }\n}\n\nexport function $insertify(\n  expr: Omit<$expr_Insert, \"unlessConflict\">\n): $expr_Insert {\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\n  return expr as any;\n}\n\nexport function $normaliseInsertShape(\n  root: ObjectTypeSet,\n  shape: {[key: string]: any},\n  isUpdate: boolean = false\n): {[key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet}} {\n  const newShape: {\n    [key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet};\n  } = {};\n  for (const [key, _val] of Object.entries(shape)) {\n    let val = _val;\n    let setModify: string | null = null;\n    if (isUpdate && _val != null && typeof _val === \"object\") {\n      const valKeys = Object.keys(_val);\n      if (\n        valKeys.length === 1 &&\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\n      ) {\n        val = _val[valKeys[0]];\n        setModify = valKeys[0];\n      }\n    }\n\n    const pointer = root.__element__.__pointers__[key];\n\n    // no pointer, not a link property\n    const isLinkProp = key[0] === \"@\";\n    if (!pointer && !isLinkProp) {\n      throw new Error(\n        `Could not find property pointer for ${\n          isUpdate ? \"update\" : \"insert\"\n        } shape key: '${key}'`\n      );\n    }\n\n    // skip undefined vals\n    if (val === undefined) continue;\n\n    // is val is expression, assign to newShape\n    if (val?.__kind__) {\n      // ranges can contain null values, so if the type is 'std::number'\n      // we need to set the type to the exact number type of the pointer\n      // so null casts are correct\n      if (\n        val.__kind__ === ExpressionKind.Literal &&\n        val.__element__.__kind__ === TypeKind.range &&\n        val.__element__.__element__.__name__ === \"std::number\"\n      ) {\n        newShape[key] = (literal as any)(pointer.target, val.__value__);\n      } else {\n        newShape[key] = _val;\n      }\n      continue;\n    }\n\n    // handle link props\n    // after this guard, pointer definitely is defined\n    if (isLinkProp) {\n      throw new Error(\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\n      );\n    }\n\n    // trying to assign plain data to a link\n    if (pointer.__kind__ !== \"property\" && val !== null) {\n      throw new Error(\n        `Must provide subquery when assigning to link '${key}' in ${\n          isUpdate ? \"update\" : \"insert\"\n        } query.`\n      );\n    }\n\n    // val is plain data\n    // key corresponds to pointer or starts with \"@\"\n    const isMulti =\n      pointer.cardinality === Cardinality.AtLeastOne ||\n      pointer.cardinality === Cardinality.Many;\n    if (pointer.__kind__ === \"property\") {\n      if (pointer.target.__name__ === \"std::json\") {\n      }\n    }\n\n    const wrappedVal =\n      val === null\n        ? cast(pointer.target, null)\n        : isMulti && Array.isArray(val)\n        ? val.length === 0\n          ? cast(pointer.target, null)\n          : set(...val.map(v => (literal as any)(pointer.target, v)))\n        : (literal as any)(pointer.target, val);\n    newShape[key] = setModify\n      ? ({[setModify]: wrappedVal} as any)\n      : wrappedVal;\n  }\n  return newShape;\n}\n\nexport function insert<Root extends $expr_PathNode>(\n  root: Root,\n  shape: InsertShape<Root>\n): $expr_Insert<Root> {\n  if (typeof shape !== \"object\") {\n    throw new Error(\n      `invalid insert shape.${\n        typeof shape === \"function\"\n          ? \" Hint: Insert shape is expected to be an object, \" +\n            \"not a function returning a shape object.\"\n          : \"\"\n      }`\n    );\n  }\n  const expr: any = {\n    __kind__: ExpressionKind.Insert,\n    __element__: root.__element__,\n    __cardinality__: Cardinality.One,\n    __expr__: root,\n    __shape__: $normaliseInsertShape(root, shape),\n  };\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\n  return $expressionify($insertify(expr)) as any;\n}\n"},{"path":"json.ts","content":"import {ExpressionKind, ParamType, TypeKind} from \"edgedb/_src/reflection/index.ts\";\nimport type {$expr_WithParams} from \"./params.ts\";\n\nfunction jsonStringify(type: ParamType, val: any): string {\n  if (type.__kind__ === TypeKind.array) {\n    if (Array.isArray(val)) {\n      return `[${val\n        .map(item => jsonStringify(type.__element__, item))\n        .join()}]`;\n    }\n    throw new Error(`Param with array type is not an array`);\n  }\n  if (type.__kind__ === TypeKind.tuple) {\n    if (!Array.isArray(val)) {\n      throw new Error(`Param with tuple type is not an array`);\n    }\n    if (val.length !== type.__items__.length) {\n      throw new Error(\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\n      );\n    }\n    return `[${val\n      .map((item, i) => jsonStringify(type.__items__[i], item))\n      .join()}]`;\n  }\n  if (type.__kind__ === TypeKind.namedtuple) {\n    if (typeof val !== \"object\") {\n      throw new Error(`Param with named tuple type is not an object`);\n    }\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n      throw new Error(\n        `Param with named tuple type has incorrect number of items. Got ${\n          Object.keys(val).length\n        } expected ${Object.keys(type.__shape__).length}`\n      );\n    }\n    return `{${Object.entries(val)\n      .map(([key, item]) => {\n        if (!type.__shape__[key]) {\n          throw new Error(\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\n              type.__shape__\n            ).join()}`\n          );\n        }\n        return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n      })\n      .join()}}`;\n  }\n  if (\n    type.__kind__ === TypeKind.scalar\n    // || type.__kind__ === TypeKind.castonlyscalar\n  ) {\n    switch (type.__name__) {\n      case \"std::bigint\":\n        return val.toString();\n      case \"std::json\":\n        return JSON.stringify(val);\n      case \"std::bytes\":\n        return `\"${val.toString(\"base64\")}\"`;\n      case \"cfg::memory\":\n        return `\"${val.toString()}\"`;\n      default:\n        return JSON.stringify(val);\n    }\n  }\n  if (type.__kind__ === TypeKind.enum) {\n    return JSON.stringify(val);\n  }\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\n}\n\nexport function jsonifyComplexParams(expr: any, _args: any) {\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\n    const args = {..._args};\n    for (const param of (expr as $expr_WithParams).__params__) {\n      if (param.__isComplex__) {\n        args[param.__name__] = jsonStringify(\n          param.__element__ as any,\n          args[param.__name__]\n        );\n      }\n    }\n\n    return args;\n  }\n  return _args;\n}\n"},{"path":"literal.ts","content":"import {\n  Cardinality,\n  ExpressionKind,\n  BaseType,\n  BaseTypeToTsType,\n  makeType,\n  ScalarType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {$expr_Literal} from \"edgedb/_src/reflection/literal.ts\";\nimport {$expressionify} from \"./path.ts\";\nimport {spec} from \"../__spec__.ts\";\n\nexport function literal<T extends BaseType>(\n  type: T,\n  value: BaseTypeToTsType<T>\n): $expr_Literal<T> {\n  return $expressionify({\n    __element__: type,\n    __cardinality__: Cardinality.One,\n    __kind__: ExpressionKind.Literal,\n    __value__: value,\n  }) as any;\n}\n\nexport const $nameMapping = new Map<string, string>([\n  ...([...spec.values()].map(type => [type.name, type.id]) as any),\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\n\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, id, literal) as any;\n}\n\nexport function $getTypeByName(\n  name: string\n): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\n}\n"},{"path":"params.ts","content":"import type {Executor} from \"edgedb\";\nimport {\n  Expression,\n  ExpressionKind,\n  ParamType,\n  Cardinality,\n  setToTsType,\n  TypeSet,\n  TypeKind,\n  BaseTypeToTsType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {$expressionify} from \"./path.ts\";\n\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n  __kind__: ExpressionKind.OptionalParam;\n  __type__: Type;\n};\n\nexport function optional<Type extends ParamType>(\n  type: Type\n): $expr_OptionalParam<Type> {\n  return {\n    __kind__: ExpressionKind.OptionalParam,\n    __type__: type,\n  };\n}\n\nexport type QueryableWithParamsExpression<\n  Set extends TypeSet = TypeSet,\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {}\n> = Expression<Set, false> & {\n  run(\n    cxn: Executor,\n    args: paramsToParamArgs<Params>\n  ): Promise<setToTsType<Set>>;\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\n\nexport type $expr_WithParams<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n> = QueryableWithParamsExpression<\n  {\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n  },\n  Params\n>;\n\ntype paramsToParamArgs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params as Params[key] extends ParamType\n    ? key\n    : never]: Params[key] extends ParamType\n    ? Readonly<BaseTypeToTsType<Params[key]>>\n    : never;\n} & {\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\n    ? key\n    : never]?: Params[key] extends $expr_OptionalParam\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null>\n    : never;\n};\n\nexport type $expr_Param<\n  Name extends string | number | symbol = string,\n  Type extends ParamType = ParamType,\n  Optional extends boolean = boolean\n> = Expression<{\n  __kind__: ExpressionKind.Param;\n  __element__: Type;\n  __cardinality__: Optional extends true\n    ? Cardinality.AtMostOne\n    : Cardinality.One;\n  __name__: Name;\n  __isComplex__: boolean;\n}>;\n\ntype paramsToParamExprs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\n    : Params[key] extends ParamType\n    ? $expr_Param<key, Params[key], false>\n    : never;\n};\n\nconst complexParamKinds = new Set([TypeKind.tuple, TypeKind.namedtuple]);\n\nexport function params<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n>(\n  paramsDef: Params,\n  expr: (params: paramsToParamExprs<Params>) => Expr\n): $expr_WithParams<Params, Expr> {\n  const paramExprs: {[key: string]: $expr_Param} = {};\n  for (const [key, param] of Object.entries(paramsDef)) {\n    const paramType =\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\n    const isComplex =\n      complexParamKinds.has(paramType.__kind__) ||\n      (paramType.__kind__ === TypeKind.array &&\n        complexParamKinds.has(paramType.__element__.__kind__));\n    paramExprs[key] = $expressionify({\n      __kind__: ExpressionKind.Param,\n      __element__: paramType,\n      __cardinality__:\n        param.__kind__ === ExpressionKind.OptionalParam\n          ? Cardinality.AtMostOne\n          : Cardinality.One,\n      __name__: key,\n      __isComplex__: isComplex,\n    }) as any;\n  }\n\n  const returnExpr = expr(paramExprs as any);\n\n  return $expressionify({\n    __kind__: ExpressionKind.WithParams,\n    __element__: returnExpr.__element__,\n    __cardinality__: returnExpr.__cardinality__,\n    __expr__: returnExpr,\n    __params__: Object.values(paramExprs),\n  }) as any;\n}\n"},{"path":"path.ts","content":"import {\n  cardinalityUtil,\n  ObjectTypeSet,\n  TypeSet,\n  Expression,\n  ExpressionKind,\n  TypeKind,\n  LinkDesc,\n  PropertyDesc,\n  Cardinality,\n  BaseType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {\n  PathParent,\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $pathify,\n  ExpressionRoot,\n} from \"edgedb/_src/reflection/path.ts\";\nimport {literalToTypeSet} from \"../castMaps.ts\";\nimport {$arrayLikeIndexify, $tuplePathify} from \"./collections.ts\";\nimport {$toEdgeQL} from \"./toEdgeQL.ts\";\nimport {$queryFunc, $queryFuncJSON} from \"./query.ts\";\n\nfunction PathLeaf<\n  Root extends TypeSet,\n  Parent extends PathParent,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathLeaf<Root, Parent, Exclusive> {\n  return $expressionify({\n    __kind__: ExpressionKind.PathLeaf,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  }) as any;\n}\n\nfunction PathNode<\n  Root extends ObjectTypeSet,\n  Parent extends PathParent | null,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathNode<Root, Parent, Exclusive> {\n  const obj = {\n    __kind__: ExpressionKind.PathNode,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  };\n\n  const shape: any = {};\n  Object.entries(obj.__element__.__pointers__).map(([key, ptr]) => {\n    if (ptr.__kind__ === \"property\") {\n      shape[key] = true;\n    }\n  });\n  Object.defineProperty(obj, \"*\", {\n    writable: false,\n    value: shape,\n  });\n  return $expressionify(obj) as any;\n}\n\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\n\nconst pathifyProxyHandlers: ProxyHandler<any> = {\n  get(target: any, prop: string | symbol, proxy: any) {\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\n    if (ptr) {\n      return (\n        target[_pathCache][prop] ??\n        (target[_pathCache][prop] = (\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\n        )(\n          {\n            __element__: ptr.target,\n            __cardinality__: cardinalityUtil.multiplyCardinalities(\n              target.__cardinality__,\n              ptr.cardinality\n            ),\n          },\n          {\n            linkName: prop,\n            type: proxy,\n          },\n          ptr.exclusive ?? false,\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\n        ))\n      );\n    }\n    return target[prop];\n  },\n};\n\nfunction _$pathify<Root extends TypeSet, Parent extends PathParent>(\n  _root: Root\n): $pathify<Root> {\n  if (_root.__element__.__kind__ !== TypeKind.object) {\n    return _root as any;\n  }\n\n  const root: $expr_PathNode<ObjectTypeSet, Parent> = _root as any;\n\n  let pointers = {\n    ...root.__element__.__pointers__,\n  };\n\n  if (root.__parent__) {\n    const {type, linkName} = root.__parent__;\n    const parentPointer = type.__element__.__pointers__[linkName];\n    if (parentPointer?.__kind__ === \"link\") {\n      pointers = {...pointers, ...parentPointer.properties};\n    }\n  }\n\n  for (const [key, val] of Object.entries(\n    root.__element__.__shape__ || {id: true}\n  )) {\n    if (pointers[key]) continue;\n    const valType: BaseType = (val as any)?.__element__;\n    if (!valType) continue;\n\n    pointers[key] = {\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\n      properties: {},\n      target: (val as any).__element__,\n      cardinality: (val as any).__cardinality__,\n      exclusive: false,\n      computed: true,\n      readonly: true,\n      hasDefault: false,\n    };\n  }\n\n  (root as any)[_pointers] = pointers;\n  (root as any)[_pathCache] = {};\n\n  return new Proxy(root, pathifyProxyHandlers);\n}\n\nfunction isFunc(this: any, expr: ObjectTypeSet) {\n  return $expressionify({\n    __kind__: ExpressionKind.TypeIntersection,\n    __cardinality__: this.__cardinality__,\n    __element__: {\n      ...expr.__element__,\n      __shape__: {id: true},\n    } as any,\n    __expr__: this,\n  });\n}\n\nfunction assert_single(expr: Expression) {\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: expr.__element__,\n    __cardinality__: cardinalityUtil.overrideUpperBound(\n      expr.__cardinality__,\n      \"One\"\n    ),\n    __name__: \"std::assert_single\",\n    __args__: [expr],\n    __namedargs__: {},\n  }) as any;\n}\n\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    if (typeof prop === \"string\" && !(prop in target)) {\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n      return jsonDestructure.call(proxy, parsedProp);\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\n  const pathTypeSet = literalToTypeSet(path);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      pathTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, pathTypeSet],\n  }) as any;\n}\n\nexport function $jsonDestructure(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.scalar &&\n    _expr.__element__.__name__ === \"std::json\"\n  ) {\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\n\n    expr.destructure = jsonDestructure.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\nexport function $expressionify<T extends ExpressionRoot>(\n  _expr: T\n): Expression<T> {\n  const expr: Expression = _$pathify(\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\n  ) as any;\n\n  expr.run = $queryFunc.bind(expr) as any;\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\n  expr.is = isFunc.bind(expr) as any;\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\n  expr.assert_single = () => assert_single(expr) as any;\n\n  return Object.freeze(expr) as any;\n}\n\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\nconst scopeRoots = new WeakSet<Expression>();\n\nexport function $getScopedExpr<T extends ExpressionRoot>(\n  expr: T,\n  existingScopes?: Set<Expression>\n): Expression<T> {\n  let scopedExpr = scopedExprCache.get(expr);\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\n    // free objects should not be scopified\n    const isFreeObject =\n      expr.__cardinality__ === Cardinality.One &&\n      expr.__element__.__name__ === \"std::FreeObject\";\n\n    const isInsert = expr.__kind__ === ExpressionKind.Insert;\n    scopedExpr =\n      isFreeObject || isInsert\n        ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\n        : $expressionify({\n            ...expr,\n            __cardinality__: Cardinality.One,\n            __scopedFrom__: expr,\n            \"*\": (expr as any)[\"*\"],\n          });\n    scopeRoots.add(scopedExpr);\n    const uncached = !scopedExpr;\n    if (uncached) {\n      scopedExprCache.set(expr, scopedExpr);\n    }\n  }\n  existingScopes?.add(scopedExpr);\n  return scopedExpr as any;\n}\n\nexport {_$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode};\n"},{"path":"query.ts","content":"import type * as edgedb from \"edgedb\";\nimport {Cardinality, ExpressionKind} from \"edgedb/_src/reflection/index.ts\";\nimport {jsonifyComplexParams} from \"./json.ts\";\nimport {select} from \"./select.ts\";\n\nconst runnableExpressionKinds = new Set([\n  ExpressionKind.Select,\n  ExpressionKind.Update,\n  ExpressionKind.Insert,\n  ExpressionKind.InsertUnlessConflict,\n  ExpressionKind.Delete,\n  ExpressionKind.Group,\n  ExpressionKind.For,\n  ExpressionKind.With,\n  ExpressionKind.WithParams,\n]);\n\nconst wrappedExprCache = new WeakMap();\n\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n\n  const _args = jsonifyComplexParams(expr, args);\n\n  const query = expr.toEdgeQL();\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne ||\n    expr.__cardinality__ === Cardinality.Empty\n  ) {\n    return cxn.querySingle(query, _args);\n  } else {\n    return cxn.query(query, _args);\n  }\n}\n\nexport async function $queryFuncJSON(\n  this: any,\n  cxn: edgedb.Executor,\n  args: any\n) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n  const _args = jsonifyComplexParams(expr, args);\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne\n  ) {\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n  } else {\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\n  }\n}\n"},{"path":"range.ts","content":"import type {LocalDate, LocalDateTime, Duration} from \"edgedb\";\nimport {Range} from \"edgedb\";\nimport {\n  RangeType,\n  $expr_Literal,\n  TypeKind,\n  getPrimitiveBaseType,\n  TypeSet,\n  $expr_Function,\n  cardinalityUtil,\n  BaseType,\n  ExpressionKind,\n} from \"edgedb/_src/reflection/index.ts\";\n\nimport type {\n  $number,\n  $decimal,\n  $datetime,\n  $duration,\n  $bool,\n} from \"../modules/std.ts\";\nimport type {$local_date, $local_datetime} from \"../modules/cal.ts\";\nimport type {\n  literalToScalarType,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n} from \"../castMaps.ts\";\nimport {literalToTypeSet} from \"../castMaps.ts\";\nimport {spec} from \"../__spec__.ts\";\nimport {literal, $nameMapping} from \"./literal.ts\";\nimport {$resolveOverload} from \"./funcops.ts\";\nimport {$expressionify} from \"./path.ts\";\n\ntype $anypoint =\n  | $number\n  | $local_date\n  | $decimal\n  | $datetime\n  | $local_datetime\n  | $duration;\n\nfunction range<Element extends $anypoint>(\n  element: Element\n): RangeType<Element>;\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\n  val: Range<T>\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\nfunction range<\n  NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n  },\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  namedArgs: NamedArgs,\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  mapLiteralToTypeSet<NamedArgs>,\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.multiplyCardinalities<\n        cardinalityUtil.multiplyCardinalities<\n          cardinalityUtil.multiplyCardinalities<\n            cardinalityUtil.optionalParamCardinality<P1>,\n            cardinalityUtil.optionalParamCardinality<P2>\n          >,\n          cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\n        >,\n        cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\n      >,\n      cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>\n    >\n  >\n>;\nfunction range<\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  {},\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.optionalParamCardinality<P1>,\n      cardinalityUtil.optionalParamCardinality<P2>\n    >\n  >\n>;\nfunction range(...args: any[]): any {\n  if (args.length === 1) {\n    const arg = args[0];\n    if (arg instanceof Range) {\n      if (arg.lower === null && arg.upper === null) {\n        throw new Error(\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\n        );\n      }\n      if (arg.isEmpty) {\n        throw new Error(`Can't create literal expression from empty range.`);\n      }\n      return literal(\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\n        arg\n      );\n    }\n    if (arg.__kind__ && !arg.__element__) {\n      return {\n        __kind__: TypeKind.range,\n        __name__: `range<${arg.__name__}>`,\n        __element__: arg,\n      } as any;\n    }\n  }\n  const {\n    returnType,\n    cardinality,\n    args: positionalArgs,\n    namedArgs,\n  } = $resolveOverload(\"std::range\", args, spec, [\n    {\n      args: [\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      ],\n      namedArgs: {\n        inc_lower: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        inc_upper: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        empty: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      },\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\n    },\n  ]);\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: returnType,\n    __cardinality__: cardinality,\n    __name__: \"std::range\",\n    __args__: positionalArgs,\n    __namedargs__: namedArgs,\n  }) as any;\n}\n\nexport {range as $range};\n"},{"path":"select.ts","content":"import {Buffer} from \"https://deno.land/std@0.114.0/node/buffer.ts\";\n\nimport {\n  LocalDateTime,\n  LocalDate,\n  LocalTime,\n  Duration,\n  RelativeDuration,\n  ConfigMemory,\n  DateDuration,\n} from \"edgedb\";\nimport type {$bool, $number} from \"../modules/std.ts\";\nimport {\n  $expr_PolyShapeElement,\n  $scopify,\n  Cardinality,\n  cardinalityUtil,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  makeType,\n  ObjectType,\n  ObjectTypeExpression,\n  ObjectTypePointers,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  stripSet,\n  TypeKind,\n  TypeSet,\n  typeutil,\n  BaseType,\n} from \"edgedb/_src/reflection/index.ts\";\n\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $linkPropify,\n  ExpressionRoot,\n  PathParent,\n} from \"edgedb/_src/reflection/path.ts\";\nimport type {anonymizeObject} from \"./casting.ts\";\nimport type {$expr_Operator} from \"edgedb/_src/reflection/funcops.ts\";\nimport {$expressionify, $getScopedExpr} from \"./path.ts\";\nimport {$getTypeByName, literal} from \"./literal.ts\";\nimport {spec} from \"../__spec__.ts\";\nimport {\n  scalarLiterals,\n  literalToScalarType,\n  literalToTypeSet,\n} from \"../castMaps.ts\";\n\nexport const ASC: \"ASC\" = \"ASC\";\nexport const DESC: \"DESC\" = \"DESC\";\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\n\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n  expression: OrderByExpr;\n  direction?: OrderByDirection;\n  empty?: OrderByEmpty;\n};\n\nexport type OrderByExpression =\n  | OrderByExpr\n  | OrderByObjExpr\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\n\nexport type OffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\nexport type LimitExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\n\nexport type SelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByExpression;\n  offset?: OffsetExpression | number;\n  limit?: LimitExpression | number;\n};\n\nexport type UnknownSelectModifiers = {[k in keyof SelectModifiers]: unknown};\n\nexport type NormalisedSelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByObjExpr[];\n  offset?: OffsetExpression;\n  limit?: LimitExpression;\n};\n\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\n//   Mods extends OrderByExpr\n//     ? [{expression: Mods}]\n//     : Mods extends OrderByObjExpr\n//     ? [Mods]\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\n//     ? {\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\n//           ? {expression: Mods[K]}\n//           : Mods[K];\n//       }\n//     : [];\n\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\n//   filter: Mods[\"filter\"];\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\n//     : [];\n//   offset: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n//   limit: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n// };\n\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: TypeSet;\n  __kind__: ExpressionKind.Select;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__?: ObjectTypeExpression;\n}>;\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n// & SelectModifierMethods<stripSet<Set>>;\n\nexport interface SelectModifierMethods<Root extends TypeSet> {\n  filter<Filter extends SelectFilterExpression>(\n    filter:\n      | Filter\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => Filter)\n  ): this;\n  order_by(\n    order_by:\n      | OrderByExpression\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OrderByExpression)\n  ): this;\n  offset(\n    offset:\n      | OffsetExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OffsetExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n  limit(\n    limit:\n      | LimitExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => LimitExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n}\n// Base is ObjectTypeSet &\n// Filter is equality &\n// Filter.args[0] is PathLeaf\n//   Filter.args[0] is __exclusive__ &\n//   Filter.args[0].parent.__element__ === Base.__element__\n//   Filter.args[1].__cardinality__ is AtMostOne or One\n// if Filter.args[0] is PathNode:\n//   Filter.args[0] is __exclusive__ &\n//   if Filter.args[0].parent === null\n//     Filter.args[0].parent.__element__ === Base.__element__\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n//   else\n//     Filter.args[0].type.__element__ === Base.__element__ &\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n\ntype argCardToResultCard<\n  OpCard extends Cardinality,\n  BaseCase extends Cardinality\n> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\n  ? Cardinality.AtMostOne\n  : [OpCard] extends [Cardinality.Empty]\n  ? Cardinality.Empty\n  : BaseCase;\n\nexport type InferFilterCardinality<\n  Base extends TypeSet,\n  Filter\n> = Filter extends TypeSet\n  ? // Base is ObjectTypeExpression &\n    Base extends ObjectTypeSet // $expr_PathNode\n    ? // Filter is equality\n      Filter extends $expr_Operator<\"=\", any, infer Args, any>\n      ? // Filter.args[0] is PathLeaf\n        Args[0] extends $expr_PathLeaf\n        ? // Filter.args[0] is unique\n          Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            typeutil.assertEqual<\n              Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\n              Base[\"__element__\"][\"__name__\"]\n            > extends true\n            ? // Filter.args[1].__cardinality__ is AtMostOne or One\n              argCardToResultCard<\n                Args[1][\"__cardinality__\"],\n                Base[\"__cardinality__\"]\n              >\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Args[0] extends $expr_PathNode<any, any, any>\n        ? Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            Args[0][\"__parent__\"] extends null\n            ? typeutil.assertEqual<\n                Args[0][\"__element__\"][\"__name__\"],\n                Base[\"__element__\"][\"__name__\"]\n              > extends true\n              ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                argCardToResultCard<\n                  Args[1][\"__cardinality__\"],\n                  Base[\"__cardinality__\"]\n                >\n              : Base[\"__cardinality__\"]\n            : Args[0][\"__parent__\"] extends infer Parent\n            ? Parent extends PathParent\n              ? typeutil.assertEqual<\n                  Parent[\"type\"][\"__element__\"][\"__name__\"],\n                  Base[\"__element__\"][\"__name__\"]\n                > extends true\n                ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                  argCardToResultCard<\n                    Args[1][\"__cardinality__\"],\n                    Base[\"__cardinality__\"]\n                  >\n                : Base[\"__cardinality__\"]\n              : Base[\"__cardinality__\"]\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Base[\"__cardinality__\"]\n      : Base[\"__cardinality__\"]\n    : Base[\"__cardinality__\"]\n  : Base[\"__cardinality__\"];\n\nexport type InferOffsetLimitCardinality<\n  Card extends Cardinality,\n  Modifers extends UnknownSelectModifiers\n> = Modifers[\"limit\"] extends number | LimitExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Modifers[\"offset\"] extends number | OffsetExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Card;\n\nexport type ComputeSelectCardinality<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends UnknownSelectModifiers\n> = InferOffsetLimitCardinality<\n  InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\n  Modifiers\n>;\n\nexport function is<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\n>(\n  expr: Expr,\n  shape: Shape\n): {\n  [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<\n    Expr,\n    normaliseElement<Shape[k]>\n  >;\n} {\n  const mappedShape: any = {};\n  for (const [key, value] of Object.entries(shape)) {\n    mappedShape[key] = {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: expr,\n      __shapeElement__: value,\n    };\n  }\n  return mappedShape;\n}\n\nfunction computeFilterCardinality(\n  expr: SelectFilterExpression,\n  cardinality: Cardinality,\n  base: TypeSet\n) {\n  let card = cardinality;\n\n  const filter: any = expr;\n  // Base is ObjectExpression\n  const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\n  const filterExprIsEq =\n    filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\n  const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\n  const arg1: TypeSet = filter?.__args__?.[1];\n  const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\n  const arg0IsUnique = arg0?.__exclusive__ === true;\n\n  if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\n    const newCard =\n      arg1.__cardinality__ === Cardinality.One ||\n      arg1.__cardinality__ === Cardinality.AtMostOne\n        ? Cardinality.AtMostOne\n        : arg1.__cardinality__ === Cardinality.Empty\n        ? Cardinality.Empty\n        : cardinality;\n\n    if (arg0.__kind__ === ExpressionKind.PathLeaf) {\n      const arg0ParentMatchesBase =\n        arg0.__parent__.type.__element__.__name__ ===\n        base.__element__.__name__;\n      if (arg0ParentMatchesBase) {\n        card = newCard;\n      }\n    } else if (arg0.__kind__ === ExpressionKind.PathNode) {\n      // if Filter.args[0] is PathNode:\n      //   Filter.args[0] is __exclusive__ &\n      //   if Filter.args[0].parent === null\n      //     Filter.args[0].__element__ === Base.__element__\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      //   else\n      //     Filter.args[0].type.__element__ === Base.__element__ &\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      const parent = arg0.__parent__;\n      if (parent === null) {\n        const arg0MatchesBase =\n          arg0.__element__.__name__ === base.__element__.__name__;\n        if (arg0MatchesBase) {\n          card = newCard;\n        }\n      } else {\n        const arg0ParentMatchesBase =\n          parent?.type.__element__.__name__ === base.__element__.__name__;\n        if (arg0ParentMatchesBase) {\n          card = newCard;\n        }\n      }\n    }\n  }\n\n  return card;\n}\n\nexport function $handleModifiers(\n  modifiers: SelectModifiers,\n  rootExpr: TypeSet\n): {modifiers: NormalisedSelectModifiers; cardinality: Cardinality} {\n  const mods = {...modifiers};\n  let card = rootExpr.__cardinality__;\n\n  if (mods.filter && rootExpr.__element__.__kind__ === TypeKind.object) {\n    card = computeFilterCardinality(mods.filter, card, rootExpr);\n  }\n  if (mods.order_by) {\n    const orderExprs = Array.isArray(mods.order_by)\n      ? mods.order_by\n      : [mods.order_by];\n    mods.order_by = orderExprs.map(expr =>\n      typeof (expr as any).__element__ === \"undefined\"\n        ? expr\n        : {expression: expr}\n    ) as any;\n  }\n  if (mods.offset) {\n    mods.offset =\n      typeof mods.offset === \"number\"\n        ? ($getTypeByName(\"std::number\")(mods.offset) as any)\n        : mods.offset;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n  if (mods.limit) {\n    let expr = mods.limit;\n    if (typeof expr === \"number\") {\n      expr = $getTypeByName(\"std::number\")(expr) as any;\n    } else if ((expr as any).__kind__ === ExpressionKind.Set) {\n      expr = (expr as any).__exprs__[0];\n    }\n    mods.limit = expr;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n\n  return {modifiers: mods as NormalisedSelectModifiers, cardinality: card};\n}\n\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\n  Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n  }>;\n\nfunction deleteExpr<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\n): $expr_Delete<{\n  __element__: ObjectType<\n    Expr[\"__element__\"][\"__name__\"],\n    Expr[\"__element__\"][\"__pointers__\"],\n    {id: true}\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nfunction deleteExpr(expr: any, modifiersGetter: any) {\n  const selectExpr = select(expr, modifiersGetter);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Delete,\n    __element__: selectExpr.__element__,\n    __cardinality__: selectExpr.__cardinality__,\n    __expr__: selectExpr,\n  }) as any;\n}\n\nexport {deleteExpr as delete};\n\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n\n// function resolveModifierGetter(parent: any, modGetter: any) {\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\n//       const shape = parent.__element__.__shape__;\n//       const _scope =\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\n//           $existingScopes);\n//       const scope = new Proxy(_scope, {\n//         get(target: any, prop: string) {\n//           if (shape[prop] && shape[prop] !== true) {\n//             return shape[prop];\n//           }\n//           return target[prop];\n//         },\n//       });\n//       return {\n//         scope: _scope,\n//         modExpr: modGetter(scope),\n//       };\n//     } else {\n//       return {\n//         scope: undefined,\n//         modExpr: modGetter(parent.__expr__),\n//       };\n//     }\n//   } else {\n//     return {scope: parent.__scope__, modExpr: modGetter};\n//   }\n// }\n\n// function updateModifier(\n//   parent: any,\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\n//   modGetter: any\n// ) {\n//   const modifiers = {\n//     ...parent.__modifiers__,\n//   };\n//   const cardinality = parent.__cardinality__;\n\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\n\n//   switch (modName) {\n//     case \"filter\":\n//       modifiers.filter = modifiers.filter\n//         ? op(modifiers.filter, \"and\", modExpr)\n//         : modExpr;\n\n//       // methods no longer change cardinality\n//       // cardinality = computeFilterCardinality(\n//       //   modExpr,\n//       //   cardinality,\n//       //   parent.__expr__\n//       // );\n//       break;\n//     case \"order_by\":\n//       const ordering =\n//         typeof (modExpr as any).__element__ === \"undefined\"\n//           ? modExpr\n//           : {expression: modExpr};\n//       modifiers.order_by = modifiers.order_by\n//         ? [...modifiers.order_by, ordering]\n//         : [ordering];\n//       break;\n//     case \"offset\":\n//       modifiers.offset =\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//     case \"limit\":\n//       modifiers.limit =\n//         typeof modExpr === \"number\"\n//           ? _std.number(modExpr)\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\n//           ? (modExpr as any).__exprs__[0]\n//           : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//   }\n\n//   return $expressionify(\n//     $selectify({\n//       __kind__: ExpressionKind.Select,\n//       __element__: parent.__element__,\n//       __cardinality__: cardinality,\n//       __expr__: parent.__expr__,\n//       __modifiers__: modifiers,\n//       __scope__: scope,\n//     })\n//   );\n// }\n\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\n  // Object.assign(expr, {\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\n  // });\n  return expr;\n}\n\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\n    TypeSet<\n      Desc[\"properties\"][k][\"target\"],\n      Desc[\"properties\"][k][\"cardinality\"]\n    >,\n    {\n      type: $scopify<Desc[\"target\"]>;\n      linkName: k;\n    },\n    Desc[\"properties\"][k][\"exclusive\"]\n  >;\n};\n\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\n  string,\n  P,\n  {}\n>;\n\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\n  L[\"target\"]\n> &\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\n  SelectModifiers;\nexport type linkDescToSelectElement<L extends LinkDesc> =\n  | boolean\n  // | pointerToCastableExpression<Shape[k]>\n  | TypeSet<\n      anonymizeObject<L[\"target\"]>,\n      cardinalityUtil.assignable<L[\"cardinality\"]>\n    >\n  | linkDescToShape<L>\n  | ((\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\n    ) => linkDescToShape<L>);\n\n// object types -> pointers\n// pointers -> links\n// links -> target object type\n// links -> link properties\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType> =\n  // ObjectType extends T\n  //   ? {[k: string]: unknown}\n  //   :\n  Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc\n      ?\n          | boolean\n          | TypeSet<\n              T[\"__pointers__\"][k][\"target\"],\n              cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>\n            >\n      : T[\"__pointers__\"][k] extends LinkDesc\n      ? linkDescToSelectElement<T[\"__pointers__\"][k]>\n      : any;\n  }> & {[k: string]: unknown};\n\n// incorporate __shape__ (computeds) on selection shapes\n// this works but a major rewrite of setToTsType is required\n// to incorporate __shape__-based selection shapes into\n// result type inference\n// & [k in keyof T[\"__shape__\"]]:\n//    string | number | symbol extends k //   Partial<{ // &\n//       ? unknown\n//       : T[\"__shape__\"][k] extends infer U\n//       ? U extends ObjectTypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 anonymizeObject<U[\"__element__\"]>,\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//             | objectTypeToSelectShape<U[\"__element__\"]>\n//             | ((\n//                 scope: $scopify<U[\"__element__\"]>\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\n//                 SelectModifiers)\n//         : U extends TypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 U[\"__element__\"],\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//         : unknown\n//       : unknown;\n//   }>\n\nexport type normaliseElement<El> = El extends boolean\n  ? El\n  : El extends TypeSet\n  ? stripSet<El>\n  : El extends (...scope: any[]) => any\n  ? normaliseShape<ReturnType<El>>\n  : El extends object\n  ? normaliseShape<stripSet<El>>\n  : stripSet<El>;\n\nexport type normaliseShape<\n  Shape extends object,\n  Strip = SelectModifierNames\n> = {\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\n\nconst $FreeObject = makeType(\n  spec,\n  [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n  literal\n);\nconst FreeObject: $expr_PathNode = {\n  __kind__: ExpressionKind.PathNode,\n  __element__: $FreeObject as any,\n  __cardinality__: Cardinality.One,\n  __parent__: null,\n  __exclusive__: true,\n  __scopeRoot__: null,\n} as any;\n\nexport const $existingScopes = new Set<\n  Expression<TypeSet<BaseType, Cardinality>>\n>();\n\nfunction $shape<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers\n>(\n  expr: Expr,\n  _shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): (scope: unknown) => Readonly<Shape>;\nfunction $shape(_a: unknown, b: (...args: any) => any) {\n  return b;\n}\nexport {$shape as shape};\n\nexport function select<Expr extends ObjectTypeExpression>(\n  expr: Expr\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Expr[\"__element__\"][\"__shape__\"] // {id: true}\n  >;\n  __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport function select<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Select<stripSet<Expr>>;\nexport function select<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers,\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\n>(\n  expr: Expr,\n  shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Omit<normaliseShape<Shape>, SelectModifierNames>\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\n/*\n\nFor the moment is isn't possible to implement both closure-based and plain\nobject overloads without breaking autocomplete on one or the other.\nThis is due to a limitation in TS:\n\nhttps://github.com/microsoft/TypeScript/issues/26892\nhttps://github.com/microsoft/TypeScript/issues/47081\n\n*/\nexport function select<\n  Expr extends PrimitiveTypeSet,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers: (expr: Expr) => Readonly<Modifiers>\n): $expr_Select<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: InferOffsetLimitCardinality<\n    Expr[\"__cardinality__\"],\n    Modifiers\n  >;\n}>;\nexport function select<Shape extends {[key: string]: TypeSet}>(\n  shape: Shape\n): $expr_Select<{\n  __element__: ObjectType<\n    `std::FreeObject`,\n    {\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\n        ? LinkDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            {},\n            false,\n            true,\n            true,\n            false\n          >\n        : PropertyDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            false,\n            true,\n            true,\n            false\n          >;\n    },\n    Shape\n  >; // _shape\n  __cardinality__: Cardinality.One;\n}>;\nexport function select<Expr extends scalarLiterals>(\n  expr: Expr\n): $expr_Select<{\n  __element__: literalToScalarType<Expr>;\n  __cardinality__: Cardinality.One;\n}>;\nexport function select(...args: any[]) {\n  const firstArg = args[0];\n\n  if (\n    typeof firstArg !== \"object\" ||\n    firstArg instanceof Buffer ||\n    firstArg instanceof Date ||\n    firstArg instanceof Duration ||\n    firstArg instanceof LocalDateTime ||\n    firstArg instanceof LocalDate ||\n    firstArg instanceof LocalTime ||\n    firstArg instanceof RelativeDuration ||\n    firstArg instanceof DateDuration ||\n    firstArg instanceof ConfigMemory\n  ) {\n    const literalExpr = literalToTypeSet(firstArg);\n    return $expressionify(\n      $selectify({\n        __kind__: ExpressionKind.Select,\n        __element__: literalExpr.__element__,\n        __cardinality__: literalExpr.__cardinality__,\n        __expr__: literalExpr,\n        __modifiers__: {},\n      })\n    ) as any;\n  }\n\n  const exprPair: [TypeSet, (scope: any) => any] =\n    typeof args[0].__element__ !== \"undefined\"\n      ? (args as any)\n      : [FreeObject, () => args[0]];\n\n  let expr = exprPair[0];\n  const shapeGetter = exprPair[1];\n  if (expr === FreeObject) {\n    const freeObjectPtrs: ObjectTypePointers = {};\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\n      freeObjectPtrs[k] = {\n        __kind__:\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\n        target: v.__element__,\n\n        cardinality: v.__cardinality__,\n        exclusive: false,\n        computed: true,\n        readonly: true,\n        hasDefault: false,\n        properties: {},\n      };\n    }\n    expr = {\n      ...FreeObject,\n      __element__: {\n        ...FreeObject.__element__,\n        __pointers__: {\n          ...FreeObject.__element__.__pointers__,\n          ...freeObjectPtrs,\n        },\n      } as any,\n    };\n  }\n  if (!shapeGetter) {\n    if (expr.__element__.__kind__ === TypeKind.object) {\n      const objectExpr: ObjectTypeSet = expr as any;\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: {\n            __kind__: TypeKind.object,\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\n            __pointers__: objectExpr.__element__.__pointers__,\n            __shape__: objectExpr.__element__.__shape__,\n          } as any,\n          __cardinality__: objectExpr.__cardinality__,\n          __expr__: objectExpr,\n          __modifiers__: {},\n        })\n      ) as any;\n    } else {\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: expr.__element__,\n          __cardinality__: expr.__cardinality__,\n          __expr__: expr,\n          __modifiers__: {},\n        })\n      ) as any;\n    }\n  }\n\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const {modifiers: mods, shape, scope} = resolveShape(shapeGetter, expr);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n  return $expressionify(\n    $selectify({\n      __kind__: ExpressionKind.Select,\n      __element__:\n        expr.__element__.__kind__ === TypeKind.object\n          ? {\n              __kind__: TypeKind.object,\n              __name__: `${expr.__element__.__name__}`, // _shape\n              __pointers__: (expr.__element__ as ObjectType).__pointers__,\n              __shape__: shape,\n            }\n          : expr.__element__,\n      __cardinality__: cardinality,\n      __expr__: expr,\n      __modifiers__: modifiers,\n      __scope__:\n        expr !== scope // && expr.__element__.__name__ !== \"std::FreeObject\"\n          ? scope\n          : undefined,\n    })\n  ) as any;\n}\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: any; shape: any; scope: TypeSet} {\n  const modifiers: any = {};\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope =\n    expr.__element__.__kind__ === TypeKind.object\n      ? $getScopedExpr(expr as any, $existingScopes)\n      : expr;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (\n      key === \"filter\" ||\n      key === \"order_by\" ||\n      key === \"offset\" ||\n      key === \"limit\"\n    ) {\n      modifiers[key] = value;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  return {shape, modifiers, scope};\n}\n\nexport function resolveShapeElement(\n  key: any,\n  value: any,\n  scope: ObjectTypeExpression\n): any {\n  // if value is a nested closure\n  // or a nested shape object\n  const isSubshape =\n    typeof value === \"object\" &&\n    typeof (value as any).__kind__ === \"undefined\";\n  const isClosure =\n    typeof value === \"function\" &&\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\n  // if (isSubshape) {\n  //   // return value;\n  //   const childExpr = (scope as any)[key];\n  //   const {\n  //     shape: childShape,\n  //     // scope: childScope,\n  //     // modifiers: mods,\n  //   } = resolveShape(value as any, childExpr);\n  //   return childShape;\n  // }\n  if (isSubshape || isClosure) {\n    // get child node expression\n    // this relies on Proxy-based getters\n    const childExpr = (scope as any)[key];\n    if (!childExpr) {\n      throw new Error(\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\n      );\n    }\n    const {\n      shape: childShape,\n      scope: childScope,\n      modifiers: mods,\n    } = resolveShape(value as any, childExpr);\n\n    // extracts normalized modifiers\n    const {modifiers} = $handleModifiers(mods, childExpr);\n\n    return {\n      __kind__: ExpressionKind.Select,\n      __element__: {\n        __kind__: TypeKind.object,\n        __name__: `${childExpr.__element__.__name__}`,\n        __pointers__: childExpr.__element__.__pointers__,\n        __shape__: childShape,\n      },\n      __cardinality__:\n        scope.__element__.__pointers__?.[key]?.cardinality ||\n        scope.__element__.__shape__?.[key]?.__cardinality__,\n      __expr__: childExpr,\n      __modifiers__: modifiers,\n      __scope__: childExpr !== childScope ? childScope : undefined,\n    };\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\n    const polyElement = value as $expr_PolyShapeElement;\n\n    const polyScope = (scope as any).is(polyElement.__polyType__);\n    return {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: polyScope,\n      __shapeElement__: resolveShapeElement(\n        key,\n        polyElement.__shapeElement__,\n        polyScope\n      ),\n    };\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n    const linkProp = (scope as any)[key];\n    if (!linkProp) {\n      throw new Error(\n        (scope as any).__parent__\n          ? `link property '${key}' does not exist on link ${\n              (scope as any).__parent__.linkName\n            }`\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\n      );\n    }\n    return value ? linkProp : false;\n  } else {\n    return value;\n  }\n}\n"},{"path":"set.ts","content":"import type {\n  ArrayType,\n  BaseTypeTuple,\n  BaseType,\n  NamedTupleType,\n  ObjectTypeSet,\n  TypeSet,\n  TupleType,\n  Expression,\n  ExpressionKind,\n  mergeObjectTypes,\n  ObjectType,\n  Cardinality,\n  getPrimitiveBaseType,\n  SomeType,\n} from \"edgedb/_src/reflection/index.ts\";\nimport {TypeKind, $mergeObjectTypes} from \"edgedb/_src/reflection/index.ts\";\n\n// \"../\" path gets replaced during generation step\n// @ts-ignore\nimport * as castMaps from \"../castMaps.ts\";\n\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\n  if (a.__kind__ !== b.__kind__) {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\n    return castMaps.getSharedParentScalar(a, b);\n  } else if (\n    a.__kind__ === TypeKind.object &&\n    b.__kind__ === TypeKind.object\n  ) {\n    return $mergeObjectTypes(a, b);\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\n    if (a.__items__.length !== b.__items__.length) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items = a.__items__.map((_, i) => {\n        if (!a.__items__[i] || !b.__items__[i]) {\n          throw new Error();\n        }\n        return getSharedParent(\n          a.__items__[i] as SomeType,\n          b.__items__[i] as SomeType\n        );\n      });\n\n      return {\n        __kind__: TypeKind.tuple,\n        __name__: `tuple<${items.map(item => item.__name__).join(\", \")}>`,\n        __items__: items as BaseTypeTuple,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (\n    a.__kind__ === TypeKind.namedtuple &&\n    b.__kind__ === TypeKind.namedtuple\n  ) {\n    const aKeys = Object.keys(a);\n    const bKeys = new Set(Object.keys(b));\n    const sameKeys =\n      aKeys.length === bKeys.size && aKeys.every(k => bKeys.has(k));\n    if (!sameKeys) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items: {[k: string]: BaseType} = {};\n      for (const [i] of Object.entries(a.__shape__)) {\n        if (!a.__shape__[i] || !b.__shape__[i]) {\n          throw new Error();\n        }\n        items[i] = getSharedParent(\n          a.__shape__[i] as SomeType,\n          b.__shape__[i] as SomeType\n        );\n      }\n\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: `tuple<${Object.entries(items)\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n          .join(\", \")}>`,\n        __shape__: items,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\n    try {\n      const mergedEl: any = getSharedParent(\n        a.__element__ as any,\n        b.__element__ as any\n      );\n      return {\n        __kind__: TypeKind.array,\n        __name__: a.__name__,\n        __element__: mergedEl,\n      } as ArrayType;\n    } catch (err) {\n      throw new Error(\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\n    if (a.__name__ === b.__name__) return a;\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  } else {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n}\n\n// @ts-ignore\nexport {set} from \"./setImpl.ts\";\n\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __exprs__: Expression<Set>[];\n  __kind__: ExpressionKind.Set;\n}>;\n\ntype mergeTypeTuples<AItems, BItems> = {\n  [k in keyof AItems]: k extends keyof BItems\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\n    : never;\n};\n\n// find shared parent of two primitives\nexport type getSharedParentPrimitive<A, B> = A extends undefined\n  ? B extends undefined\n    ? undefined\n    : B\n  : B extends undefined\n  ? A\n  : A extends ArrayType<infer AEl>\n  ? B extends ArrayType<infer BEl>\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\n    : never\n  : A extends NamedTupleType<infer AShape>\n  ? B extends NamedTupleType<infer BShape>\n    ? NamedTupleType<{\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\n          AShape[k],\n          BShape[k]\n        >;\n      }>\n    : never\n  : A extends TupleType<infer AItems>\n  ? B extends TupleType<infer BItems>\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\n      : never\n    : never\n  : castMaps.getSharedParentScalar<A, B>;\n\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? _getSharedParentPrimitiveVariadic<\n        [getSharedParentPrimitive<A, B>, ...Rest]\n      >\n    : never;\n\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  _getSharedParentPrimitiveVariadic<Types>;\n\nexport type LooseTypeSet<\n  T extends any = any,\n  C extends Cardinality = Cardinality\n> = {\n  __element__: T;\n  __cardinality__: C;\n};\n\nexport type {mergeObjectTypes};\n\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? A extends ObjectType\n      ? B extends ObjectType\n        ? mergeObjectTypes<A, B> extends BaseType\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\n          : never\n        : never\n      : never\n    : never;\n\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\n  _mergeObjectTypesVariadic<Types>;\n\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\n    ? getPrimitiveBaseType<El>\n    : never;\n};\n\nexport type getTypesFromObjectExprs<\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\n> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\n\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.ts","content":"import type {TypeSet, setToTsType} from \"edgedb/_src/reflection/index.ts\";\n\nexport * from \"./literal.ts\";\nexport * from \"./path.ts\";\nexport * from \"./set.ts\";\nexport * from \"./cast.ts\";\nexport * from \"./select.ts\";\nexport * from \"./update.ts\";\nexport * from \"./insert.ts\";\nexport * from \"./group.ts\";\nexport * from \"./collections.ts\";\nexport * from \"./funcops.ts\";\nexport * from \"./for.ts\";\nexport * from \"./with.ts\";\nexport * from \"./params.ts\";\nexport * from \"./globals.ts\";\nexport * from \"./detached.ts\";\nexport * from \"./toEdgeQL.ts\";\nexport * from \"./range.ts\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.ts","content":"import {Buffer} from \"https://deno.land/std@0.114.0/node/buffer.ts\";\n\nimport {\n  Duration,\n  LocalDate,\n  LocalDateTime,\n  LocalTime,\n  RelativeDuration,\n  DateDuration,\n  Range,\n} from \"edgedb\";\nimport {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  BaseType,\n  Cardinality,\n  EnumType,\n  ExpressionKind,\n  isArrayType,\n  isNamedTupleType,\n  isObjectType,\n  isTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  OperatorKind,\n  RangeType,\n  TypeKind,\n  TypeSet,\n  util,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {$expr_Literal} from \"edgedb/_src/reflection/literal.ts\";\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $expr_TypeIntersection,\n} from \"edgedb/_src/reflection/path.ts\";\nimport {reservedKeywords} from \"edgedb/_src/reflection/reservedKeywords.ts\";\nimport type {$expr_Cast} from \"./cast.ts\";\nimport type {$expr_Detached} from \"./detached.ts\";\nimport type {$expr_For, $expr_ForVar} from \"./for.ts\";\nimport type {$expr_Function, $expr_Operator} from \"edgedb/_src/reflection/funcops.ts\";\nimport type {$expr_Insert, $expr_InsertUnlessConflict} from \"./insert.ts\";\nimport type {$expr_Param, $expr_WithParams} from \"./params.ts\";\nimport type {\n  $expr_Delete,\n  $expr_Select,\n  LimitExpression,\n  OffsetExpression,\n} from \"./select.ts\";\nimport type {$expr_Set} from \"./set.ts\";\nimport type {$expr_Update} from \"./update.ts\";\nimport type {$expr_Alias, $expr_With} from \"./with.ts\";\nimport type {$expr_Group, GroupingSet} from \"./group.ts\";\nimport type {$expr_Global} from \"./globals.ts\";\n\nexport type SomeExpression =\n  | $expr_PathNode\n  | $expr_PathLeaf\n  | $expr_Literal\n  | $expr_Set\n  | $expr_Array\n  | $expr_Tuple\n  | $expr_NamedTuple\n  | $expr_TuplePath\n  | $expr_Cast\n  | $expr_Select\n  | $expr_Delete\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_Function\n  | $expr_Operator\n  | $expr_For\n  | $expr_ForVar\n  | $expr_TypeIntersection\n  | $expr_Alias\n  | $expr_With\n  | $expr_WithParams\n  | $expr_Param\n  | $expr_Detached\n  | $expr_Group\n  | $expr_Global;\n\ntype WithScopeExpr =\n  | $expr_Select\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_For\n  | $expr_Group;\n\ninterface RenderCtx {\n  // mapping withable expr to list of with vars\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\n  // metadata about each with var\n  withVars: Map<\n    SomeExpression,\n    {\n      name: string;\n      scope: WithScopeExpr;\n      childExprs: Set<SomeExpression>;\n      scopedExpr?: SomeExpression; // scope vars only\n    }\n  >;\n  renderWithVar?: SomeExpression;\n  forVars: Map<$expr_ForVar, string>;\n  linkProps: Map<SomeExpression, string[]>;\n}\n\nconst toEdgeQLCache = new WeakMap<any, string>();\n\nexport function $toEdgeQL(this: any) {\n  if (toEdgeQLCache.has(this)) {\n    return toEdgeQLCache.get(this)!;\n  }\n\n  const walkExprCtx: WalkExprTreeCtx = {\n    seen: new Map(),\n    rootScope: null,\n  };\n\n  walkExprTree(this, null, walkExprCtx);\n\n  // get variables by block\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\n  // get per-variable metadata\n  const withVars: RenderCtx[\"withVars\"] = new Map();\n  const seen = new Map(walkExprCtx.seen);\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\n\n  // iterate over all expressions\n  for (const [expr, refData] of seen) {\n    // delete from seen after visitinng\n    seen.delete(expr);\n\n    // convert referenced link props to simple string array\n    if (refData.linkProps.length) {\n      linkProps.set(\n        expr,\n        refData.linkProps.map(linkProp =>\n          linkProp.__parent__.linkName.slice(1)\n        )\n      );\n    }\n\n    // already extracted\n    if (withVars.has(expr)) {\n      continue;\n    }\n\n    // ignore unbound leaves, nodes, and intersections\n    // these should be rendered as is\n    if (\n      !refData.boundScope &&\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\n        expr.__kind__ === ExpressionKind.PathNode ||\n        expr.__kind__ === ExpressionKind.TypeIntersection)\n    ) {\n      continue;\n    }\n\n    // forvars and params should not be hoisted\n    if (\n      expr.__kind__ === ExpressionKind.ForVar ||\n      expr.__kind__ === ExpressionKind.Param\n    ) {\n      continue;\n    }\n\n    // pull out scope variables\n    // from select, update, and group expressions.\n    // these are always rendered in with blocks\n    if (\n      (expr.__kind__ === ExpressionKind.Select ||\n        expr.__kind__ === ExpressionKind.Update ||\n        expr.__kind__ === ExpressionKind.Group) &&\n      expr.__scope__ &&\n      // with var not previously registered\n      !withVars.has(expr.__scope__ as any)\n    ) {\n      const withBlock = expr;\n      const scopeVar = expr.__scope__ as SomeExpression;\n      const scopeVarName = `__scope_${withVars.size}_${\n        scopeVar.__element__.__name__.split(\"::\")[1]\n      }`;\n\n      withVars.set(scopeVar, {\n        name: scopeVarName,\n        scope: withBlock,\n        childExprs: new Set(),\n        scopedExpr:\n          expr.__element__.__kind__ === TypeKind.object\n            ? (expr.__expr__ as any)\n            : undefined,\n      });\n    }\n\n    // expression should be extracted to with block if\n    // - bound with e.with\n    // - refcount > 1\n    // - aliased with e.alias\n    if (\n      refData.refCount > 1 ||\n      refData.boundScope ||\n      refData.aliases.length > 0\n    ) {\n      // first, check if expr is bound to scope\n      let withBlock = refData.boundScope;\n\n      // filter nulls\n      const parentScopes = [...refData.parentScopes].filter(\n        scope => scope !== null\n      ) as WithScopeExpr[];\n\n      // if expression is unbound\n      if (!withBlock) {\n        // if parent scopes haven't all been resolved,\n        // re-add current expr to `seen` to be resolved later\n        if (parentScopes.some(parentScope => seen.has(parentScope))) {\n          seen.set(expr, refData);\n          continue;\n        }\n\n        // set withBlock to top-level parent scope\n        const resolvedParentScopes = parentScopes.map(\n          parentScope => withVars.get(parentScope)?.scope ?? parentScope\n        );\n        withBlock =\n          resolvedParentScopes.find(parentScope => {\n            // loop over parent scopes\n            // get list of children exprs for each parent\n            const childExprs = new Set(\n              walkExprCtx.seen.get(parentScope)!.childExprs\n            );\n            // return true for scope that contains all other scopes\n            return resolvedParentScopes.every(\n              scope => childExprs.has(scope) || scope === parentScope\n            );\n          }) ?? walkExprCtx.rootScope;\n      }\n\n      if (!withBlock) {\n        throw new Error(\n          `Cannot extract repeated expression into 'WITH' block, ` +\n            `query has no 'WITH'able expressions`\n        );\n      }\n\n      if (!withBlocks.has(withBlock)) {\n        withBlocks.set(withBlock, new Set());\n      }\n\n      // check all references and aliases are within this block\n      const validScopes = new Set([\n        withBlock,\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\n      ]);\n      for (const scope of [\n        ...refData.parentScopes,\n        ...util.flatMap(refData.aliases, alias => [\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\n        ]),\n      ]) {\n        if (scope === null || !validScopes.has(scope)) {\n          throw new Error(\n            refData.boundScope\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                `expression or its aliases appear outside root scope`\n          );\n        }\n      }\n\n      for (const withVar of [expr, ...refData.aliases]) {\n        // withVar is an alias already explicitly bound\n        // to an inner WITH block\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n          continue;\n        }\n\n        const withVarName = `__withVar_${withVars.size}`;\n\n        withBlocks.get(withBlock)!.add(withVar);\n        withVars.set(withVar, {\n          name: withVarName,\n          scope: withBlock,\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\n        });\n      }\n    }\n  }\n\n  let edgeQL = renderEdgeQL(this, {\n    withBlocks,\n    withVars,\n    forVars: new Map(),\n    linkProps,\n  });\n  if (\n    edgeQL.startsWith(\"(\") &&\n    edgeQL.endsWith(\")\") &&\n    !(\n      this.__kind__ === ExpressionKind.Tuple ||\n      this.__kind__ === ExpressionKind.NamedTuple ||\n      this.__kind__ === ExpressionKind.Literal\n    )\n  ) {\n    edgeQL = edgeQL.slice(1, -1);\n  }\n  toEdgeQLCache.set(this, edgeQL);\n\n  return edgeQL;\n}\n\ninterface WalkExprTreeCtx {\n  seen: Map<\n    SomeExpression,\n    {\n      refCount: number;\n      // tracks all withable ancestors\n      parentScopes: Set<WithScopeExpr | null>;\n      // tracks all child exprs\n      childExprs: SomeExpression[];\n      // tracks bound scope from e.with\n      boundScope: WithScopeExpr | null;\n      // tracks aliases from e.alias\n      aliases: SomeExpression[];\n      linkProps: $expr_PathLeaf[];\n    }\n  >;\n  rootScope: WithScopeExpr | null;\n}\n\n// walks entire expression tree\n// populates\nfunction walkExprTree(\n  _expr: TypeSet,\n  parentScope: WithScopeExpr | null,\n  ctx: WalkExprTreeCtx\n): SomeExpression[] {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\n      `Expected a valid querybuilder expression, ` +\n        `instead received ${typeof _expr}${\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\n        }.` +\n        getErrorHint(_expr)\n    );\n  }\n\n  const expr = _expr as SomeExpression;\n\n  function walkShape(shape: object) {\n    for (let param of Object.values(shape)) {\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\n        param = param.__shapeElement__;\n      }\n      if (typeof param === \"object\") {\n        if (!!(param as any).__kind__) {\n          // param is expression\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\n        } else {\n          walkShape(param);\n        }\n      }\n    }\n  }\n\n  // set root scope\n  if (!ctx.rootScope && parentScope) {\n    ctx.rootScope = parentScope;\n  }\n\n  // return without walking if expression has been seen\n  const seenExpr = ctx.seen.get(expr);\n  if (seenExpr) {\n    seenExpr.refCount += 1;\n    // if (seenExpr.refCount > 1) {\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\n    // console.log(expr.__kind__);\n    // console.log(expr.__element__.__name__);\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\n    // if (arg) console.log(arg);\n    // }\n    seenExpr.parentScopes.add(parentScope);\n    return [expr, ...seenExpr.childExprs];\n  }\n\n  const childExprs: SomeExpression[] = [];\n  ctx.seen.set(expr, {\n    refCount: 1,\n    parentScopes: new Set([parentScope]),\n    childExprs,\n    boundScope: null,\n    aliases: [],\n    linkProps: [],\n  });\n\n  switch (expr.__kind__) {\n    case ExpressionKind.Alias:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\n      break;\n    case ExpressionKind.With:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      for (const refExpr of expr.__refs__) {\n        walkExprTree(refExpr, expr.__expr__, ctx);\n        const seenRef = ctx.seen.get(refExpr as any)!;\n        if (seenRef.boundScope) {\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\n        }\n        seenRef.boundScope = expr.__expr__;\n      }\n      break;\n    case ExpressionKind.Literal:\n    case ExpressionKind.ForVar:\n    case ExpressionKind.Param:\n      break;\n    case ExpressionKind.PathLeaf:\n    case ExpressionKind.PathNode:\n      if (expr.__parent__) {\n        if ((expr.__parent__.type as any).__scopedFrom__) {\n          // if parent is scoped expr then don't walk expr\n          // since it will already be walked by enclosing select/update\n\n          childExprs.push(expr.__parent__.type as any);\n        } else {\n          childExprs.push(\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\n          );\n        }\n\n        if (\n          // is link prop\n          expr.__kind__ === ExpressionKind.PathLeaf &&\n          expr.__parent__.linkName.startsWith(\"@\")\n        ) {\n          // don't hoist a linkprop that isn't scoped from parentScope\n          const parentScopeVar = (parentScope as any).__scope__;\n          if (parentScopeVar === expr.__parent__.type) {\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\n          }\n        }\n      }\n      break;\n    case ExpressionKind.Cast:\n      if (expr.__expr__ === null) break;\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Set:\n      for (const subExpr of expr.__exprs__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Array:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Tuple:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.NamedTuple:\n      for (const subExpr of Object.values(expr.__shape__)) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.TuplePath:\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n      break;\n    case ExpressionKind.Select:\n    case ExpressionKind.Update: {\n      const modifiers = expr.__modifiers__;\n      if (modifiers.filter) {\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n      }\n      if (modifiers.order_by) {\n        for (const orderExpr of modifiers.order_by) {\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n        }\n      }\n      if (modifiers.offset) {\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\n      }\n      if (modifiers.limit) {\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\n      }\n\n      if (expr.__kind__ === ExpressionKind.Select) {\n        if (\n          isObjectType(expr.__element__) &&\n          // don't walk shape twice if select expr justs wrap another object\n          // type expr with the same shape\n          expr.__element__.__shape__ !==\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n        ) {\n          walkShape(expr.__element__.__shape__ ?? {});\n        }\n      } else {\n        // Update\n        const shape: any = expr.__shape__ ?? {};\n\n        for (const _element of Object.values(shape)) {\n          let element: any = _element;\n          if (!element.__element__) {\n            if (element[\"+=\"]) element = element[\"+=\"];\n            else if (element[\"-=\"]) element = element[\"-=\"];\n          }\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\n        }\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.Delete: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Insert: {\n      const shape: any = expr.__shape__ ?? {};\n\n      for (const element of Object.values(shape)) {\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.InsertUnlessConflict: {\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\n      // child expressions is the wrapped Insert expr\n      if (expr.__conflict__.on) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.on,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n      if (expr.__conflict__.else) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.else,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Group: {\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\n        // this prevents recurring grouping elements from being walked twice\n        // this way, these won't get pulled into with blocks,\n        // which is good because they need to be rendered in `using`\n        const seen: Set<any> = new Set();\n        if (!seen.has(expr)) {\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n          seen.add(expr);\n        }\n      }\n\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n        throw new Error(\"Missing shape in GROUP statement\");\n      }\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.TypeIntersection:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Operator:\n    case ExpressionKind.Function:\n      for (const subExpr of expr.__args__) {\n        if (Array.isArray(subExpr)) {\n          for (const arg of subExpr) {\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\n          }\n        } else {\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\n        }\n      }\n      if (expr.__kind__ === ExpressionKind.Function) {\n        for (const subExpr of Object.values(expr.__namedargs__)) {\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n        }\n      }\n      break;\n    case ExpressionKind.For: {\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.WithParams: {\n      if (parentScope !== null) {\n        throw new Error(\n          `'withParams' does not support being used as a nested expression`\n        );\n      }\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Detached: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Global:\n      break;\n    default:\n      util.assertNever(\n        expr,\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n      );\n  }\n\n  return [expr, ...childExprs];\n}\n\nfunction renderEdgeQL(\n  _expr: TypeSet,\n  ctx: RenderCtx,\n  renderShape: boolean = true,\n  noImplicitDetached: boolean = false\n): string {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\"Invalid expression.\");\n  }\n  const expr = _expr as SomeExpression;\n\n  // if expression is in a with block\n  // render its name\n  const withVar = ctx.withVars.get(expr);\n\n  if (withVar && ctx.renderWithVar !== expr) {\n    return renderShape &&\n      expr.__kind__ === ExpressionKind.Select &&\n      isObjectType(expr.__element__)\n      ? `(${withVar.name} ${shapeToEdgeQL(\n          (expr.__element__.__shape__ || {}) as object,\n          ctx,\n          null,\n          true // render shape only\n        )})`\n      : withVar.name;\n  }\n\n  // render with block expression\n  function renderWithBlockExpr(\n    varExpr: SomeExpression,\n    _noImplicitDetached?: boolean\n  ) {\n    const withBlockElement = ctx.withVars.get(varExpr)!;\n    let renderedExpr = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      _noImplicitDetached\n    );\n    const renderedExprNoDetached = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      true\n    );\n\n    if (ctx.linkProps.has(expr)) {\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n        .get(expr)!\n        .map(\n          linkPropName =>\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\n        )\n        .join(\",\\n\")}\\n})`;\n    }\n    return `  ${withBlockElement.name} := ${\n      renderedExpr.includes(\"\\n\")\n        ? `(\\n${indent(\n            renderedExpr[0] === \"(\" &&\n              renderedExpr[renderedExpr.length - 1] === \")\"\n              ? renderedExpr.slice(1, -1)\n              : renderedExpr,\n            4\n          )}\\n  )`\n        : renderedExpr\n    }`;\n  }\n\n  // extract scope expression from select/update if exists\n  const scopeExpr =\n    (expr.__kind__ === ExpressionKind.Select ||\n      expr.__kind__ === ExpressionKind.Update ||\n      expr.__kind__ === ExpressionKind.Group) &&\n    ctx.withVars.has(expr.__scope__ as any)\n      ? (expr.__scope__ as SomeExpression)\n      : undefined;\n\n  const scopeExprVar: string[] = [];\n  const unscopedWithBlock: string[] = [];\n  const scopedWithBlock: string[] = [];\n\n  // generate with block if needed\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\n    // sort associated vars\n    const sortedBlockVars = topoSortWithVars(\n      ctx.withBlocks.get(expr as any) ?? new Set(),\n      ctx\n    );\n\n    if (!scopeExpr) {\n      // if no scope expression exists, all variables are unscoped\n      unscopedWithBlock.push(\n        ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n      );\n    }\n    // else if (expr.__kind__ === ExpressionKind.Group) {\n    //   // add all vars into scoped with block\n    //   // this is rendered inside the `using` clause later\n    //   // no need for the with/for trick\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n    //   scopedWithBlock.push(\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n    //   );\n    // }\n    else {\n      // get scope variable\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\n\n      // get list of with vars that reference scope\n      const scopedVars = sortedBlockVars.filter(blockVarExpr =>\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\n      );\n      // filter blockvars to only include vars that don't reference scope\n      unscopedWithBlock.push(\n        ...sortedBlockVars\n          .filter(blockVar => !scopedVars.includes(blockVar))\n          .map(blockVar => renderWithBlockExpr(blockVar))\n      );\n\n      // when rendering `with` variables that reference current scope\n      // they are extracted into computed properties defining in a for loop\n      if (!scopedVars.length) {\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n      } else {\n        const scopeName = scopeVar.name;\n\n        // render a reference to scoped path (e.g. \".nemesis\")\n        scopeVar.name = scopeName + \"_expr\";\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n        // scopedWithBlock.push(\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\n        // );\n\n        // render a for loop containing all scoped block vars\n        // as computed properties\n        scopeVar.name = scopeName + \"_inner\";\n        scopeExprVar.push(\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\n            scopeName + \"_expr\"\n          }} UNION (\\n    WITH\\n${indent(\n            scopedVars\n              .map(blockVar => renderWithBlockExpr(blockVar))\n              .join(\",\\n\"),\n            4\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n            .map(blockVar => {\n              const name = ctx.withVars.get(blockVar)!.name;\n              return `      ${name} := ${name}`;\n            })\n            .join(\",\\n\")}\\n    }\\n  ))`\n        );\n\n        // change var name back to original value\n        scopeVar.name = scopeName;\n\n        // reassign name for all scoped block vars\n        for (const blockVarExpr of scopedVars) {\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\n          blockVar.name = `${scopeName}.${blockVar.name}`;\n        }\n      }\n    }\n  }\n\n  const withBlockElements = [\n    ...unscopedWithBlock,\n    ...scopeExprVar,\n    ...scopedWithBlock,\n  ];\n  const withBlock = withBlockElements.length\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n    : \"\";\n\n  if (expr.__kind__ === ExpressionKind.With) {\n    return renderEdgeQL(expr.__expr__, ctx);\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\n    return `(WITH\\n${expr.__params__\n      .map(param => {\n        const optional =\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n        return `  __param__${param.__name__} := ${\n          param.__isComplex__\n            ? `<${param.__element__.__name__}>to_json(<${optional}str>$${param.__name__})`\n            : `<${optional}${param.__element__.__name__}>$${param.__name__}`\n        }`;\n      })\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\n    if (!aliasedExprVar) {\n      throw new Error(\n        `Expression referenced by alias does not exist in 'WITH' block`\n      );\n    }\n    return aliasedExprVar.name;\n  } else if (\n    expr.__kind__ === ExpressionKind.PathNode ||\n    expr.__kind__ === ExpressionKind.PathLeaf\n  ) {\n    if (!expr.__parent__) {\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\n        expr.__element__.__name__\n      }`;\n    } else {\n      const isScopedLinkProp =\n        expr.__parent__.linkName.startsWith(\"@\") &&\n        ctx.withVars.has(expr.__parent__.type as any);\n      const linkName = isScopedLinkProp\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n        : expr.__parent__.linkName;\n      const parent = renderEdgeQL(\n        expr.__parent__.type,\n        ctx,\n        false,\n        noImplicitDetached\n      );\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n    }\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\n    return literalToEdgeQL(expr.__element__, expr.__value__);\n  } else if (expr.__kind__ === ExpressionKind.Set) {\n    const exprs = expr.__exprs__;\n\n    if (\n      exprs.every(ex => ex.__element__.__kind__ === TypeKind.object) ||\n      exprs.every(ex => ex.__element__.__kind__ !== TypeKind.object)\n    ) {\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\n      return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n    } else {\n      throw new Error(\n        `Invalid arguments to set constructor: ${exprs\n          .map(ex => ex.__element__.__name__)\n          .join(\", \")}`\n      );\n    }\n  } else if (expr.__kind__ === ExpressionKind.Array) {\n    return `[${expr.__items__\n      .map(item => renderEdgeQL(item, ctx))\n      .join(\", \")}]`;\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\n    return `(\\n${expr.__items__\n      .map(\n        item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\n      )\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\n    return `(\\n${Object.keys(expr.__shape__)\n      .map(\n        key =>\n          `  ${key} := ${renderEdgeQL(\n            expr.__shape__[key],\n            ctx,\n            renderShape,\n            noImplicitDetached\n          )}`\n      )\n      .join(\",\\n\")}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\n    const typeName =\n      expr.__element__.__name__ === \"std::number\"\n        ? \"std::float64\"\n        : expr.__element__.__name__;\n    if (expr.__expr__ === null) {\n      return `<${typeName}>{}`;\n    }\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Select) {\n    const lines: string[] = [];\n    if (isObjectType(expr.__element__)) {\n      const selectionTarget = renderEdgeQL(\n        expr.__scope__ ?? expr.__expr__,\n        ctx,\n        false\n      );\n\n      lines.push(\n        `SELECT${\n          selectionTarget === \"DETACHED std::FreeObject\"\n            ? \"\"\n            : ` ${selectionTarget}`\n        }`\n      );\n\n      if (\n        expr.__element__.__shape__ !==\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n      ) {\n        lines.push(\n          shapeToEdgeQL(\n            (expr.__element__.__shape__ || {}) as object,\n            ctx,\n            expr.__element__\n          )\n        );\n      }\n    } else {\n      // non-object/non-shape select expression\n      const needsScalarVar =\n        (expr.__modifiers__.filter ||\n          expr.__modifiers__.order_by ||\n          expr.__modifiers__.offset ||\n          expr.__modifiers__.limit) &&\n        !ctx.withVars.has(expr.__expr__ as any);\n\n      lines.push(\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\n          expr.__expr__,\n          ctx\n        )}`\n      );\n\n      if (needsScalarVar) {\n        ctx = {...ctx, withVars: new Map(ctx.withVars)};\n        ctx.withVars.set(expr.__expr__ as any, {\n          name: \"_\",\n          childExprs: new Set(),\n          scope: expr,\n        });\n      }\n    }\n\n    const modifiers: string[] = [];\n\n    if (expr.__modifiers__.filter) {\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n    }\n    if (expr.__modifiers__.order_by) {\n      modifiers.push(\n        ...expr.__modifiers__.order_by.map(\n          ({expression, direction, empty}, i) => {\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\n              expression,\n              ctx\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n          }\n        )\n      );\n    }\n    if (expr.__modifiers__.offset) {\n      modifiers.push(\n        `OFFSET ${renderEdgeQL(\n          expr.__modifiers__.offset as OffsetExpression,\n          ctx\n        )}`\n      );\n    }\n    if (expr.__modifiers__.limit) {\n      modifiers.push(\n        `LIMIT ${renderEdgeQL(\n          expr.__modifiers__.limit as LimitExpression,\n          ctx\n        )}`\n      );\n    }\n\n    return (\n      \"(\" +\n      withBlock +\n      lines.join(\" \") +\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n      \")\"\n    );\n  } else if (expr.__kind__ === ExpressionKind.Update) {\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\n      expr.__modifiers__.filter\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n        : \" \"\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\n    return `(${withBlock}DELETE ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      undefined,\n      noImplicitDetached\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\n    return `(${withBlock}INSERT ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      false,\n      true\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\n    const $on = expr.__conflict__.on;\n    const $else = expr.__conflict__.else;\n    const clause: string[] = [];\n    if (!$on) {\n      clause.push(\"\\nUNLESS CONFLICT\");\n    }\n    if ($on) {\n      clause.push(\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\n      );\n    }\n    if ($else) {\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n    }\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\n      1,\n      -1\n    )} ${clause.join(\"\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Group) {\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n    const elementsShape =\n      expr.__element__.__shape__.elements.__element__.__shape__;\n\n    const selectStatement: string[] = [];\n    const groupStatement: string[] = [];\n\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx);\n    groupStatement.push(`GROUP ${groupTarget}`);\n\n    // render scoped withvars in using\n    const combinedBlock = [\n      // ...scopedWithBlock,\n      // this is deduplicated in e.group\n      ...groupingSet.__exprs__.map(\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\n      ),\n    ];\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n\n    let by = renderGroupingSet(groupingSet).trim();\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n      by = by.slice(1, by.length - 1);\n    }\n    groupStatement.push(`BY ` + by);\n\n    // clause.push(withBlock.trim());\n\n    // render scope var and any unscoped withVars in with block\n    const selectTarget = `${groupTarget}_groups`;\n    selectStatement.push(\n      `WITH\\n${[\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        // ...scopedWithBlock,\n      ].join(\",\\n\")},\n  ${selectTarget} := (\n${indent(groupStatement.join(\"\\n\"), 4)}\n)`\n    );\n\n    // rename scope var to fix all scope references that\n    // occur in the `elements` subshape\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\n\n    // replace references to __scope__ with\n    // .elements reference\n    const elementsShapeQuery = indent(\n      shapeToEdgeQL(elementsShape as object, {...ctx}, expr.__element__),\n      2\n    )\n      .trim()\n      .split(scopeVar!.name + \".\")\n      .join(`${selectTarget}.elements.`);\n\n    selectStatement.push(`SELECT ${selectTarget} {\n  key: {${groupingSet.__exprs__.map(e => e[0]).join(\", \")}},\n  grouping,\n  elements: ${elementsShapeQuery}\n}`);\n    return `(${selectStatement.join(\"\\n\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Function) {\n    const args = expr.__args__.map(arg => `${renderEdgeQL(arg!, ctx, false)}`);\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n    }\n    return `${expr.__name__}(${args.join(\", \")})`;\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\n    const operator = expr.__name__;\n    const args = expr.__args__;\n    switch (expr.__opkind__) {\n      case OperatorKind.Infix:\n        if (operator === \"[]\") {\n          let index = \"\";\n          if (Array.isArray(args[1])) {\n            const [start, end] = args[1];\n            if (start) {\n              index += renderEdgeQL(start, ctx);\n            }\n            index += \":\";\n            if (end) {\n              index += renderEdgeQL(end, ctx);\n            }\n          } else {\n            index = renderEdgeQL(args[1], ctx);\n          }\n\n          return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n        }\n        return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(\n          args[1],\n          ctx\n        )})`;\n      case OperatorKind.Postfix:\n        return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n      case OperatorKind.Prefix:\n        return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n      case OperatorKind.Ternary:\n        if (operator === \"if_else\") {\n          return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(\n            args[1],\n            ctx\n          )} ELSE ${renderEdgeQL(args[2], ctx)})`;\n        } else {\n          throw new Error(`Unknown operator: ${operator}`);\n        }\n      default:\n        util.assertNever(\n          expr.__opkind__,\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\n        );\n    }\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\n      expr.__element__.__name__\n    }]`;\n  } else if (expr.__kind__ === ExpressionKind.For) {\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n    return `(${withBlock}FOR ${ctx.forVars.get(\n      expr.__forVar__\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\n    const forVar = ctx.forVars.get(expr);\n    if (!forVar) {\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n    }\n    return forVar;\n  } else if (expr.__kind__ === ExpressionKind.Param) {\n    return `__param__${expr.__name__}`;\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\n    return `(DETACHED ${renderEdgeQL(\n      expr.__expr__,\n      {\n        ...ctx,\n        renderWithVar: expr.__expr__ as any,\n      },\n      undefined,\n      true\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Global) {\n    return `(GLOBAL ${expr.__name__})`;\n  } else {\n    util.assertNever(\n      expr,\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n    );\n  }\n}\n\nfunction isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// recursive renderer\nfunction renderGroupingSet(set: GroupingSet): string {\n  const contents = Object.entries(set.__elements__)\n    .map(([k, v]) => {\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n    .join(\", \");\n  if (set.__settype__ === \"tuple\") {\n    return `(${contents})`;\n  } else if (set.__settype__ === \"set\") {\n    return `{${contents}}`;\n  } else if (set.__settype__ === \"cube\") {\n    return `cube(${contents})`;\n  } else if (set.__settype__ === \"rollup\") {\n    return `rollup(${contents})`;\n  } else {\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n  }\n}\n\nfunction shapeToEdgeQL(\n  shape: object | null,\n  ctx: RenderCtx,\n  type: ObjectType | null = null,\n  keysOnly: boolean = false,\n  injectImplicitId: boolean = true\n) {\n  const pointers = type?.__pointers__ || null;\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\n  if (shape === null) {\n    return ``;\n  }\n\n  const lines: string[] = [];\n  const addLine = (line: string) =>\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n\n  const seen = new Set();\n\n  for (const key in shape) {\n    if (!shape.hasOwnProperty(key)) continue;\n    if (seen.has(key)) {\n      // tslint:disable-next-line\n      console.warn(`Invalid: duplicate key \"${key}\"`);\n      continue;\n    }\n    seen.add(key);\n    let val = (shape as any)[key];\n    let operator = \":=\";\n    let polyType: SomeExpression | null = null;\n\n    if (typeof val === \"object\" && !val.__element__) {\n      if (!!val[\"+=\"]) {\n        operator = \"+=\";\n        val = val[\"+=\"];\n      } else if (!!val[\"-=\"]) {\n        operator = \"-=\";\n        val = val[\"-=\"];\n      }\n    }\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\n      polyType = val.__polyType__;\n      val = val.__shapeElement__;\n    }\n    const polyIntersection = polyType\n      ? `[IS ${polyType.__element__.__name__}].`\n      : \"\";\n\n    // For computed properties in select shapes, inject the expected\n    // cardinality inferred by the query builder. This ensures the actual\n    // type returned by the server matches the inferred return type, or an\n    // explicit error is thrown, instead of a silent mismatch between\n    // actual and inferred type.\n    // Add annotations on FreeObjects, despite the existence of a pointer.\n    const ptr = pointers?.[key];\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n\n    const expectedCardinality =\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n        ? val.__cardinality__ === Cardinality.Many ||\n          val.__cardinality__ === Cardinality.AtLeastOne\n          ? \"multi \"\n          : \"single \"\n        : \"\";\n\n    // if selecting a required multi link, wrap expr in 'assert_exists'\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\n\n    if (typeof val === \"boolean\") {\n      if (\n        !pointers?.[key] &&\n        key[0] !== \"@\" &&\n        type &&\n        type?.__name__ !== \"std::FreeObject\" &&\n        !polyIntersection\n      ) {\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\n      }\n      if (val) {\n        addLine(`${polyIntersection}${q(key)}`);\n      }\n      continue;\n    }\n\n    if (typeof val !== \"object\") {\n      throw new Error(`Invalid shape element at \"${key}\".`);\n    }\n\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\n\n    // is subshape\n    if (!valIsExpression) {\n      addLine(\n        `${polyIntersection}${q(key, false)}: ${indent(\n          shapeToEdgeQL(val, ctx, ptr?.target),\n          2\n        ).trim()}`\n      );\n      continue;\n    }\n\n    // val is expression\n\n    // is computed\n    if (keysOnly) {\n      addLine(\n        q(key, false) +\n          (isObjectType(val.__element__)\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n            : \"\")\n      );\n      continue;\n    }\n    const renderedExpr = renderEdgeQL(val, ctx);\n\n    addLine(\n      `${expectedCardinality}${q(key, false)} ${operator} ${\n        wrapAssertExists ? \"assert_exists(\" : \"\"\n      }${\n        renderedExpr.includes(\"\\n\")\n          ? `(\\n${indent(\n              renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr,\n              4\n            )}\\n  )`\n          : renderedExpr\n      }${wrapAssertExists ? \")\" : \"\"}`\n    );\n  }\n\n  if (lines.length === 0 && injectImplicitId) {\n    addLine(\"id\");\n  }\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\n\nfunction topoSortWithVars(\n  vars: Set<SomeExpression>,\n  ctx: RenderCtx\n): SomeExpression[] {\n  if (!vars.size) {\n    return [];\n  }\n\n  const sorted: SomeExpression[] = [];\n\n  const unvisited = new Set(vars);\n  const visiting = new Set<SomeExpression>();\n\n  for (const withVar of unvisited) {\n    visit(withVar);\n  }\n\n  function visit(withVar: SomeExpression): void {\n    if (!unvisited.has(withVar)) {\n      return;\n    }\n    if (visiting.has(withVar)) {\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\n    }\n\n    visiting.add(withVar);\n\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\n      if (vars.has(child)) {\n        visit(child);\n      }\n    }\n\n    visiting.delete(withVar);\n    unvisited.delete(withVar);\n\n    sorted.push(withVar);\n  }\n  return sorted;\n}\n\nconst numericalTypes: Record<string, boolean> = {\n  \"std::number\": true,\n  \"std::int16\": true,\n  \"std::int32\": true,\n  \"std::int64\": true,\n  \"std::float32\": true,\n  \"std::float64\": true,\n};\n\nfunction literalToEdgeQL(type: BaseType, val: any): string {\n  let skipCast = false;\n  let stringRep;\n  if (type.__name__ === \"std::json\") {\n    skipCast = true;\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n  } else if (typeof val === \"string\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n      stringRep = val;\n    } else if (type.__kind__ === TypeKind.enum) {\n      skipCast = true;\n      const vals = (type as EnumType).__values__;\n      if (vals.includes(val)) {\n        skipCast = true;\n        if (val.includes(\" \")) {\n          stringRep = `<${type.__name__}>\"${val}\"`;\n        } else {\n          stringRep = `${type.__name__}.${val}`;\n        }\n      } else {\n        throw new Error(\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n        );\n      }\n    } else {\n      if (type.__name__ === \"std::str\") {\n        skipCast = true;\n      }\n      stringRep = JSON.stringify(val);\n    }\n  } else if (typeof val === \"number\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n    } else {\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\n    }\n    stringRep = `${val.toString()}`;\n  } else if (typeof val === \"boolean\") {\n    stringRep = `${val.toString()}`;\n    skipCast = true;\n  } else if (typeof val === \"bigint\") {\n    stringRep = `${val.toString()}n`;\n  } else if (Array.isArray(val)) {\n    skipCast = val.length !== 0;\n    if (isArrayType(type)) {\n      stringRep = `[${val\n        .map(el => literalToEdgeQL(type.__element__ as any, el))\n        .join(\", \")}]`;\n    } else if (isTupleType(type)) {\n      stringRep = `( ${val\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else if (val instanceof Date) {\n    stringRep = `'${val.toISOString()}'`;\n  } else if (\n    val instanceof LocalDate ||\n    val instanceof LocalDateTime ||\n    val instanceof LocalTime ||\n    val instanceof Duration ||\n    val instanceof RelativeDuration ||\n    val instanceof DateDuration\n  ) {\n    stringRep = `'${val.toString()}'`;\n  } else if (val instanceof Buffer) {\n    stringRep = bufferToStringRep(val);\n    skipCast = true;\n  } else if (val instanceof Range) {\n    const elType = (type as RangeType).__element__;\n\n    // actual type will be inferred from\n    // defined value\n    const elTypeName =\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n\n    return `std::range(${\n      val.lower === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.lower)\n    }, ${\n      val.upper === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.upper)\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n  } else if (typeof val === \"object\") {\n    if (isNamedTupleType(type)) {\n      stringRep = `( ${Object.entries(val).map(\n        ([key, value]) =>\n          `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`\n      )} )`;\n      skipCast = true;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else {\n    throw new Error(\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n    );\n  }\n  if (skipCast) {\n    return stringRep;\n  }\n  return `<${type.__name__}>${stringRep}`;\n}\n\nfunction indent(str: string, depth: number) {\n  return str\n    .split(\"\\n\")\n    .map(line => \" \".repeat(depth) + line)\n    .join(\"\\n\");\n}\n\n// backtick quote identifiers if needed\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\nfunction q(ident: string, allowBacklinks: boolean = true): string {\n  if (\n    !ident ||\n    ident.startsWith(\"@\") ||\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\n  ) {\n    return ident;\n  }\n\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n  if (isAlphaNum) {\n    const lident = ident.toLowerCase();\n    const isReserved =\n      lident !== \"__type__\" &&\n      lident !== \"__std__\" &&\n      reservedKeywords.includes(lident);\n\n    if (!isReserved) {\n      return ident;\n    }\n  }\n\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\n\nfunction bufferToStringRep(buf: Buffer): string {\n  let stringRep = \"\";\n  for (const byte of buf) {\n    if (byte < 32 || byte > 126) {\n      // non printable ascii\n      switch (byte) {\n        case 8:\n          stringRep += \"\\\\b\";\n          break;\n        case 9:\n          stringRep += \"\\\\t\";\n          break;\n        case 10:\n          stringRep += \"\\\\n\";\n          break;\n        case 12:\n          stringRep += \"\\\\f\";\n          break;\n        case 13:\n          stringRep += \"\\\\r\";\n          break;\n        default:\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n      }\n    } else {\n      stringRep +=\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n    }\n  }\n  return `b'${stringRep}'`;\n}\n\nfunction getErrorHint(expr: any): string {\n  let literalConstructor: string | null = null;\n  switch (typeof expr) {\n    case \"string\":\n      literalConstructor = \"e.str()\";\n      break;\n    case \"number\":\n      literalConstructor = Number.isInteger(expr)\n        ? \"e.int64()\"\n        : \"e.float64()\";\n      break;\n    case \"bigint\":\n      literalConstructor = \"e.bigint()\";\n      break;\n    case \"boolean\":\n      literalConstructor = \"e.bool()\";\n      break;\n  }\n  switch (true) {\n    case expr instanceof Date:\n      literalConstructor = \"e.datetime()\";\n      break;\n    case expr instanceof Duration:\n      literalConstructor = \"e.duration()\";\n      break;\n    case expr instanceof LocalDate:\n      literalConstructor = \"e.cal.local_date()\";\n      break;\n    case expr instanceof LocalDateTime:\n      literalConstructor = \"e.cal.local_datetime()\";\n      break;\n    case expr instanceof LocalTime:\n      literalConstructor = \"e.cal.local_time()\";\n      break;\n    case expr instanceof RelativeDuration:\n      literalConstructor = \"e.cal.relative_duration()\";\n      break;\n    case expr instanceof DateDuration:\n      literalConstructor = \"e.cal.date_duration()\";\n      break;\n  }\n\n  return literalConstructor\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\n        `a '${literalConstructor}' expression?`\n    : \"\";\n}\n"},{"path":"update.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  ObjectTypePointers,\n  TypeSet,\n  ObjectTypeSet,\n  stripBacklinks,\n  stripNonUpdateables,\n  typeutil,\n  ObjectTypeExpression,\n  $scopify,\n  Cardinality,\n} from \"edgedb/_src/reflection/index.ts\";\nimport type {pointerToAssignmentExpression} from \"./casting.ts\";\nimport {$expressionify, $getScopedExpr} from \"./path.ts\";\nimport {\n  SelectModifiers,\n  NormalisedSelectModifiers,\n  ComputeSelectCardinality,\n  $existingScopes,\n  $handleModifiers,\n} from \"./select.ts\";\nimport {$normaliseInsertShape, pointerIsOptional} from \"./insert.ts\";\n\n/////////////////\n/// UPDATE\n/////////////////\n\nexport type $expr_Update<\n  Set extends TypeSet = TypeSet,\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Shape extends UpdateShape<Expr> = any\n> = Expression<{\n  __kind__: ExpressionKind.Update;\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: Expr;\n  __shape__: Shape;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__: ObjectTypeExpression;\n}>;\n\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\n> extends infer Shape\n  ? Shape extends ObjectTypePointers\n    ? {\n        [k in keyof Shape]?:\n          | (\n              | pointerToAssignmentExpression<Shape[k]>\n              | (Shape[k][\"cardinality\"] extends\n                  | Cardinality.Many\n                  | Cardinality.AtLeastOne\n                  ?\n                      | {\"+=\": pointerToAssignmentExpression<Shape[k], true>}\n                      | {\"-=\": pointerToAssignmentExpression<Shape[k], true>}\n                  : never)\n            )\n          | (pointerIsOptional<Shape[k]> extends true\n              ? undefined | null\n              : never);\n      }\n    : never\n  : never;\n\nexport function update<\n  Expr extends ObjectTypeExpression,\n  Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n  }\n  // SetShape extends UpdateShape<Expr>,\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\n>(\n  expr: Expr,\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n): $expr_Update<\n  {\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n  },\n  Expr,\n  Shape[\"set\"]\n> {\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const scope = $getScopedExpr(expr as any, $existingScopes);\n\n  const resolvedShape = shape(scope);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const mods: any = {};\n  let updateShape: any | null;\n  for (const [key, val] of Object.entries(resolvedShape)) {\n    if (key === \"filter\") {\n      mods[key] = val;\n    } else if (key === \"set\") {\n      updateShape = val;\n    } else {\n      throw new Error(\n        `Invalid update shape key '${key}', only 'filter', ` +\n          `and 'set' are allowed`\n      );\n    }\n  }\n\n  if (!updateShape) {\n    throw new Error(`Update shape must contain 'set' shape`);\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Update,\n    __element__: expr.__element__,\n    __cardinality__: cardinality,\n    __expr__: expr,\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\n    __modifiers__: modifiers,\n    __scope__: scope,\n  }) as any;\n}\n"},{"path":"with.ts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/_src/reflection/index.ts\";\nimport type {$expr_Select} from \"./select.ts\";\nimport type {$expr_For} from \"./for.ts\";\nimport type {$expr_Insert} from \"./insert.ts\";\nimport type {$expr_Update} from \"./update.ts\";\nimport type {$expr_Group} from \"./group.ts\";\nimport {$expressionify} from \"./path.ts\";\n\nexport type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Alias;\n  __expr__: Expr;\n}>;\n\nexport function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.Alias,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n  }) as any;\n}\n\nexport type WithableExpression =\n  | $expr_Select\n  | $expr_For\n  | $expr_Insert\n  | $expr_Update\n  | $expr_Group;\n\nexport type $expr_With<\n  Refs extends TypeSet[] = TypeSet[],\n  Expr extends WithableExpression = WithableExpression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.With;\n  __expr__: Expr;\n  __refs__: Refs;\n}>;\n\nfunction _with<Refs extends Expression[], Expr extends WithableExpression>(\n  refs: Refs,\n  expr: Expr\n): $expr_With<Refs, Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.With,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __refs__: refs,\n    __expr__: expr as any,\n  }) as any;\n}\n\nexport {_with as with};\n"}],"cjs":[{"path":"cast.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cast = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst castMaps_1 = require(\"../castMaps\");\nfunction cast(target, expr) {\n    const cleanedExpr = expr === null ? null : (0, castMaps_1.literalToTypeSet)(expr);\n    return (0, path_1.$expressionify)({\n        __element__: target,\n        __cardinality__: cleanedExpr === null ? index_1.Cardinality.Empty : cleanedExpr.__cardinality__,\n        __expr__: cleanedExpr,\n        __kind__: index_1.ExpressionKind.Cast,\n    });\n}\nexports.cast = cast;\n"},{"path":"casting.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},{"path":"collections.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tuple = exports.$tuplePathify = exports.array = exports.$arrayLikeIndexify = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst castMaps_1 = require(\"../castMaps\");\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\nconst arrayLikeProxyHandlers = {\n    get(target, prop, proxy) {\n        var _a;\n        const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n        if (match) {\n            const start = match[1];\n            const end = (_a = match[3]) !== null && _a !== void 0 ? _a : match[4];\n            const isIndex = start && !match[2];\n            return (0, path_1.$expressionify)({\n                __kind__: index_1.ExpressionKind.Operator,\n                __element__: target.__element__.__kind__ === index_1.TypeKind.array && isIndex\n                    ? target.__element__.__element__\n                    : target.__element__,\n                __cardinality__: target.__cardinality__,\n                __name__: \"[]\",\n                __opkind__: \"Infix\",\n                __args__: [\n                    proxy,\n                    isIndex\n                        ? (0, castMaps_1.literalToTypeSet)(Number(start))\n                        : [\n                            start && (0, castMaps_1.literalToTypeSet)(Number(start)),\n                            end && (0, castMaps_1.literalToTypeSet)(Number(end)),\n                        ],\n                ],\n            });\n        }\n        return target[prop];\n    },\n};\nfunction arrayLikeIndex(index) {\n    const indexTypeSet = (0, castMaps_1.literalToTypeSet)(index);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__.__kind__ === index_1.TypeKind.array\n            ? this.__element__.__element__\n            : this.__element__,\n        __cardinality__: index_1.cardinalityUtil.multiplyCardinalities(this.__cardinality__, indexTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, indexTypeSet],\n    });\n}\nfunction arrayLikeSlice(start, end) {\n    var _a, _b;\n    const startTypeSet = start && (0, castMaps_1.literalToTypeSet)(start);\n    const endTypeSet = end && (0, castMaps_1.literalToTypeSet)(end);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: index_1.cardinalityUtil.multiplyCardinalities(index_1.cardinalityUtil.multiplyCardinalities(this.__cardinality__, (_a = startTypeSet === null || startTypeSet === void 0 ? void 0 : startTypeSet.__cardinality__) !== null && _a !== void 0 ? _a : index_1.Cardinality.One), (_b = endTypeSet === null || endTypeSet === void 0 ? void 0 : endTypeSet.__cardinality__) !== null && _b !== void 0 ? _b : index_1.Cardinality.One),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, [startTypeSet, endTypeSet]],\n    });\n}\nfunction $arrayLikeIndexify(_expr) {\n    if (_expr.__element__.__kind__ === index_1.TypeKind.array ||\n        (_expr.__element__.__kind__ === index_1.TypeKind.scalar &&\n            (_expr.__element__.__name__ === \"std::str\" ||\n                _expr.__element__.__name__ === \"std::bytes\"))) {\n        const expr = new Proxy(_expr, arrayLikeProxyHandlers);\n        expr.index = arrayLikeIndex.bind(expr);\n        expr.slice = arrayLikeSlice.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexports.$arrayLikeIndexify = $arrayLikeIndexify;\nfunction array(arg) {\n    if (Array.isArray(arg)) {\n        const items = arg.map(a => (0, castMaps_1.literalToTypeSet)(a));\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Array,\n            __cardinality__: index_1.cardinalityUtil.multiplyCardinalitiesVariadic(items.map(item => item.__cardinality__)),\n            __element__: {\n                __kind__: index_1.TypeKind.array,\n                __name__: `array<${items[0].__element__.__name__}>`,\n                __element__: items[0].__element__,\n            },\n            __items__: items,\n        });\n    }\n    if (arg.__kind__) {\n        return {\n            __kind__: index_1.TypeKind.array,\n            __name__: `array<${arg.__name__}>`,\n            __element__: arg,\n        };\n    }\n    throw new Error(\"Invalid array input.\");\n}\nexports.array = array;\nconst tupleProxyHandlers = {\n    get(target, prop, proxy) {\n        const type = target.__element__;\n        const items = type.__kind__ === index_1.TypeKind.tuple\n            ? type.__items__\n            : type.__kind__ === index_1.TypeKind.namedtuple\n                ? type.__shape__\n                : null;\n        return (items === null || items === void 0 ? void 0 : items.hasOwnProperty(prop))\n            ? tuplePath(proxy, items[prop], prop)\n            : target[prop];\n    },\n};\nfunction $tuplePathify(expr) {\n    if (expr.__element__.__kind__ !== index_1.TypeKind.tuple &&\n        expr.__element__.__kind__ !== index_1.TypeKind.namedtuple) {\n        return expr;\n    }\n    return new Proxy(expr, tupleProxyHandlers);\n}\nexports.$tuplePathify = $tuplePathify;\nfunction tuplePath(parent, itemType, index) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.TuplePath,\n        __element__: itemType,\n        __cardinality__: parent.__cardinality__,\n        __parent__: parent,\n        __index__: index,\n    });\n}\nfunction makeTupleType(name, items) {\n    return {\n        __kind__: index_1.TypeKind.tuple,\n        __name__: name,\n        __items__: items,\n    };\n}\nconst typeKinds = new Set(Object.values(index_1.TypeKind));\nfunction tuple(input) {\n    if (Array.isArray(input)) {\n        if (input.every(item => typeKinds.has(item.__kind__))) {\n            const typeItems = input;\n            const typeName = `tuple<${typeItems\n                .map(item => item.__name__)\n                .join(\", \")}>`;\n            return makeTupleType(typeName, typeItems);\n        }\n        const items = input.map(item => (0, castMaps_1.literalToTypeSet)(item));\n        const name = `tuple<${items\n            .map(item => item.__element__.__name__)\n            .join(\", \")}>`;\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Tuple,\n            __element__: makeTupleType(name, items.map(item => item.__element__)),\n            __cardinality__: index_1.cardinalityUtil.multiplyCardinalitiesVariadic(items.map(i => i.__cardinality__)),\n            __items__: items,\n        });\n    }\n    else {\n        if (Object.values(input).every((el) => typeKinds.has(el.__kind__))) {\n            const typeName = `tuple<${Object.entries(input)\n                .map(([key, val]) => `${key}: ${val.__name__}`)\n                .join(\", \")}>`;\n            return {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: typeName,\n                __shape__: input,\n            };\n        }\n        const exprShape = {};\n        const typeShape = {};\n        for (const [key, val] of Object.entries(input)) {\n            exprShape[key] = (0, castMaps_1.literalToTypeSet)(val);\n            typeShape[key] = exprShape[key].__element__;\n        }\n        const name = `tuple<${Object.entries(exprShape)\n            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n            .join(\", \")}>`;\n        return (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.NamedTuple,\n            __element__: {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: name,\n                __shape__: typeShape,\n            },\n            __cardinality__: index_1.cardinalityUtil.multiplyCardinalitiesVariadic(Object.values(exprShape).map(val => val.__cardinality__)),\n            __shape__: exprShape,\n        });\n    }\n}\nexports.tuple = tuple;\n"},{"path":"detached.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detached = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction detached(expr) {\n    return (0, path_1.$expressionify)({\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n        __kind__: index_1.ExpressionKind.Detached,\n    });\n}\nexports.detached = detached;\n"},{"path":"external.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detached = exports.params = exports.optional = exports.with = exports.alias = exports.for = exports.tuple = exports.array = exports.insert = exports.update = exports.select = exports.delete = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = exports.cast = exports.set = exports.literal = void 0;\nvar literal_1 = require(\"./literal\");\nObject.defineProperty(exports, \"literal\", { enumerable: true, get: function () { return literal_1.literal; } });\nvar set_1 = require(\"./set\");\nObject.defineProperty(exports, \"set\", { enumerable: true, get: function () { return set_1.set; } });\nvar cast_1 = require(\"./cast\");\nObject.defineProperty(exports, \"cast\", { enumerable: true, get: function () { return cast_1.cast; } });\nvar select_1 = require(\"./select\");\nObject.defineProperty(exports, \"ASC\", { enumerable: true, get: function () { return select_1.ASC; } });\nObject.defineProperty(exports, \"DESC\", { enumerable: true, get: function () { return select_1.DESC; } });\nObject.defineProperty(exports, \"EMPTY_FIRST\", { enumerable: true, get: function () { return select_1.EMPTY_FIRST; } });\nObject.defineProperty(exports, \"EMPTY_LAST\", { enumerable: true, get: function () { return select_1.EMPTY_LAST; } });\nObject.defineProperty(exports, \"is\", { enumerable: true, get: function () { return select_1.is; } });\nObject.defineProperty(exports, \"delete\", { enumerable: true, get: function () { return select_1.delete; } });\nObject.defineProperty(exports, \"select\", { enumerable: true, get: function () { return select_1.select; } });\nvar update_1 = require(\"./update\");\nObject.defineProperty(exports, \"update\", { enumerable: true, get: function () { return update_1.update; } });\nvar insert_1 = require(\"./insert\");\nObject.defineProperty(exports, \"insert\", { enumerable: true, get: function () { return insert_1.insert; } });\nvar collections_1 = require(\"./collections\");\nObject.defineProperty(exports, \"array\", { enumerable: true, get: function () { return collections_1.array; } });\nObject.defineProperty(exports, \"tuple\", { enumerable: true, get: function () { return collections_1.tuple; } });\nvar for_1 = require(\"./for\");\nObject.defineProperty(exports, \"for\", { enumerable: true, get: function () { return for_1.for; } });\nvar with_1 = require(\"./with\");\nObject.defineProperty(exports, \"alias\", { enumerable: true, get: function () { return with_1.alias; } });\nObject.defineProperty(exports, \"with\", { enumerable: true, get: function () { return with_1.with; } });\nvar params_1 = require(\"./params\");\nObject.defineProperty(exports, \"optional\", { enumerable: true, get: function () { return params_1.optional; } });\nObject.defineProperty(exports, \"params\", { enumerable: true, get: function () { return params_1.params; } });\nvar detached_1 = require(\"./detached\");\nObject.defineProperty(exports, \"detached\", { enumerable: true, get: function () { return detached_1.detached; } });\n"},{"path":"for.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.for = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction _for(set, expr) {\n    const forVar = (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.ForVar,\n        __element__: set.__element__,\n        __cardinality__: index_1.Cardinality.One,\n    });\n    const returnExpr = expr(forVar);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.For,\n        __element__: returnExpr.__element__,\n        __cardinality__: index_1.cardinalityUtil.multiplyCardinalities(set.__cardinality__, returnExpr.__cardinality__),\n        __iterSet__: set,\n        __expr__: returnExpr,\n        __forVar__: forVar,\n    });\n}\nexports.for = _for;\n"},{"path":"funcops.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$resolveOverload = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst cast_1 = require(\"./cast\");\nconst castMaps_1 = require(\"../castMaps\");\nconst literal_1 = require(\"./literal\");\nfunction mapLiteralToTypeSet(literals) {\n    if (Array.isArray(literals)) {\n        return literals.map(lit => (lit != null ? (0, castMaps_1.literalToTypeSet)(lit) : lit));\n    }\n    const obj = {};\n    for (const key of Object.keys(literals)) {\n        obj[key] =\n            literals[key] != null ? (0, castMaps_1.literalToTypeSet)(literals[key]) : literals[key];\n    }\n    return obj;\n}\nfunction $resolveOverload(funcName, args, typeSpec, funcDefs) {\n    const positionalArgs = [];\n    let namedArgs;\n    if (args.length) {\n        if (args[0] !== undefined) {\n            try {\n                positionalArgs.push((0, castMaps_1.literalToTypeSet)(args[0]));\n            }\n            catch {\n                namedArgs = mapLiteralToTypeSet(args[0]);\n            }\n        }\n        else {\n            positionalArgs.push(undefined);\n        }\n        positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n    }\n    for (const def of funcDefs) {\n        const resolvedOverload = _tryOverload(funcName, positionalArgs, namedArgs, typeSpec, def);\n        if (resolvedOverload !== null) {\n            return resolvedOverload;\n        }\n    }\n    throw new Error(`No function overload found for ${funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\")[1]}()'`\n        : `operator '${funcName}'`} with args: ${args.map(arg => `${arg}`).join(\", \")}`);\n}\nexports.$resolveOverload = $resolveOverload;\nconst ANYTYPE_ARG = Symbol();\nfunction _tryOverload(funcName, args, namedArgs, typeSpec, funcDef) {\n    var _a, _b;\n    if ((funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n        (namedArgs === undefined &&\n            funcDef.namedArgs &&\n            Object.values(funcDef.namedArgs).some(arg => !arg.optional))) {\n        return null;\n    }\n    const lastParamVariadic = (_a = funcDef.args[funcDef.args.length - 1]) === null || _a === void 0 ? void 0 : _a.variadic;\n    if (!lastParamVariadic && args.length > funcDef.args.length) {\n        return null;\n    }\n    const paramCardinalities = [\n        index_1.Cardinality.One,\n    ];\n    if (namedArgs) {\n        for (const [key, value] of Object.entries(namedArgs)) {\n            const argDef = (_b = funcDef.namedArgs) === null || _b === void 0 ? void 0 : _b[key];\n            if (!argDef ||\n                !compareType(typeSpec, argDef.typeId, value.__element__).match) {\n                return null;\n            }\n            paramCardinalities.push(argDef.setoftype\n                ? funcDef.preservesOptionality\n                    ? index_1.cardinalityUtil.overrideUpperBound(value.__cardinality__, \"One\")\n                    : index_1.Cardinality.One\n                : argDef.optional\n                    ? index_1.cardinalityUtil.overrideLowerBound(value.__cardinality__, \"One\")\n                    : value.__cardinality__);\n        }\n    }\n    let positionalArgs = [];\n    let returnAnytype;\n    let needsAnytypeReplacement = false;\n    for (let i = 0; i < funcDef.args.length; i++) {\n        const argDef = funcDef.args[i];\n        const arg = args[i];\n        if (arg === undefined) {\n            if (!argDef.optional) {\n                return null;\n            }\n            if (i < args.length) {\n                const argTypeName = typeSpec.get(argDef.typeId).name;\n                if (argTypeName.includes(\"anytype\") ||\n                    argTypeName.includes(\"std::anypoint\")) {\n                    if (!returnAnytype) {\n                        positionalArgs.push(ANYTYPE_ARG);\n                        needsAnytypeReplacement = true;\n                    }\n                    else {\n                        positionalArgs.push((0, cast_1.cast)(returnAnytype, null));\n                    }\n                }\n                else {\n                    const argType = (0, index_1.makeType)(typeSpec, argDef.typeId, literal_1.literal);\n                    positionalArgs.push((0, cast_1.cast)(argType, null));\n                }\n            }\n        }\n        else {\n            const { match, anytype } = compareType(typeSpec, argDef.typeId, arg.__element__);\n            if (!match) {\n                return null;\n            }\n            if (!returnAnytype && anytype) {\n                returnAnytype = anytype;\n            }\n            positionalArgs.push(...(argDef.variadic ? args.slice(i) : [arg]));\n            if (argDef.setoftype) {\n                paramCardinalities.push(funcDef.preservesOptionality\n                    ? index_1.cardinalityUtil.overrideUpperBound(arg.__cardinality__, \"One\")\n                    : index_1.Cardinality.One);\n            }\n            else {\n                const card = argDef.variadic\n                    ? index_1.cardinalityUtil.multiplyCardinalitiesVariadic(args.slice(i).map(el => el.__cardinality__))\n                    : arg.__cardinality__;\n                paramCardinalities.push(argDef.optional\n                    ? index_1.cardinalityUtil.overrideLowerBound(card, \"One\")\n                    : card);\n            }\n        }\n    }\n    let cardinality;\n    if (funcName === \"if_else\") {\n        cardinality = index_1.cardinalityUtil.multiplyCardinalities(index_1.cardinalityUtil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[2].__cardinality__), positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"std::assert_exists\") {\n        cardinality = index_1.cardinalityUtil.overrideLowerBound(positionalArgs[0].__cardinality__, \"One\");\n    }\n    else if (funcName === \"union\") {\n        cardinality = index_1.cardinalityUtil.mergeCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"??\") {\n        cardinality = index_1.cardinalityUtil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"distinct\") {\n        cardinality = positionalArgs[0].__cardinality__;\n    }\n    else {\n        cardinality =\n            funcDef.returnTypemod === \"SetOfType\"\n                ? index_1.Cardinality.Many\n                : index_1.cardinalityUtil.multiplyCardinalitiesVariadic(paramCardinalities);\n        if (funcDef.returnTypemod === \"OptionalType\" &&\n            !funcDef.preservesOptionality) {\n            cardinality = index_1.cardinalityUtil.overrideLowerBound(cardinality, \"Zero\");\n        }\n    }\n    if (needsAnytypeReplacement) {\n        if (!returnAnytype) {\n            throw new Error(`could not resolve anytype for ${funcName}`);\n        }\n        positionalArgs = positionalArgs.map(arg => arg === ANYTYPE_ARG ? (0, cast_1.cast)(returnAnytype, null) : arg);\n    }\n    return {\n        kind: funcDef.kind,\n        returnType: (0, index_1.makeType)(typeSpec, funcDef.returnTypeId, literal_1.literal, returnAnytype),\n        cardinality,\n        args: positionalArgs,\n        namedArgs: namedArgs !== null && namedArgs !== void 0 ? namedArgs : {},\n    };\n}\nconst nameRemapping = {\n    \"std::int16\": \"std::number\",\n    \"std::int32\": \"std::number\",\n    \"std::int64\": \"std::number\",\n    \"std::float32\": \"std::number\",\n    \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map();\nfunction getDescendantNames(typeSpec, typeId) {\n    if (descendantCache.has(typeId)) {\n        return descendantCache.get(typeId);\n    }\n    const descendants = [\n        ...new Set([...typeSpec.values()]\n            .filter(type => type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId))\n            .flatMap(type => type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name])),\n    ];\n    descendantCache.set(typeId, descendants);\n    return descendants;\n}\nfunction compareType(typeSpec, typeId, arg) {\n    var _a;\n    const type = typeSpec.get(typeId);\n    if (type.name === \"anytype\") {\n        return { match: true, anytype: arg };\n    }\n    if (type.name === \"std::anypoint\") {\n        const descendants = getDescendantNames(typeSpec, typeId);\n        if (descendants.includes(arg.__name__)) {\n            return { match: true, anytype: arg };\n        }\n    }\n    if (type.name === \"std::anyenum\") {\n        return { match: arg.__kind__ === index_1.TypeKind.enum };\n    }\n    if (type.kind === \"scalar\") {\n        arg = (_a = arg.__casttype__) !== null && _a !== void 0 ? _a : arg;\n        return {\n            match: (arg.__kind__ === index_1.TypeKind.scalar || arg.__kind__ === index_1.TypeKind.enum) &&\n                (arg.__name__ === type.name ||\n                    (0, castMaps_1.isImplicitlyCastableTo)(arg.__name__, type.name)),\n        };\n    }\n    if (type.kind === \"array\") {\n        if (arg.__kind__ === index_1.TypeKind.array) {\n            return compareType(typeSpec, type.array_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"range\") {\n        if (arg.__kind__ === index_1.TypeKind.range) {\n            return compareType(typeSpec, type.range_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"object\") {\n        if (arg.__kind__ !== index_1.TypeKind.object)\n            return { match: false };\n        const objectArg = arg;\n        let match = true;\n        for (const ptr of type.pointers) {\n            if (objectArg.__pointers__[ptr.name]) {\n                const argPtr = objectArg.__pointers__[ptr.name];\n                const ptrTarget = typeSpec.get(ptr.target_id);\n                if (ptrTarget.name !== argPtr.target.__name__ ||\n                    ptr.real_cardinality !== argPtr.cardinality) {\n                    match = false;\n                }\n            }\n        }\n        return {\n            match,\n        };\n    }\n    if (type.kind === \"tuple\") {\n        const items = arg.__kind__ === index_1.TypeKind.tuple\n            ? arg.__items__\n            : arg.__kind__ === index_1.TypeKind.namedtuple\n                ? arg.__shape__\n                : null;\n        if (items) {\n            const keys = Object.keys(items);\n            if (keys.length === type.tuple_elements.length) {\n                let anytype;\n                for (let i = 0; i < keys.length; i++) {\n                    if (keys[i] !== type.tuple_elements[i].name) {\n                        return { match: false };\n                    }\n                    const { match: m, anytype: a } = compareType(typeSpec, type.tuple_elements[i].target_id, items[keys[i]]);\n                    if (!m) {\n                        return { match: false };\n                    }\n                    if (a)\n                        anytype = a;\n                }\n                return { match: true, anytype };\n            }\n        }\n    }\n    return { match: false };\n}\n"},{"path":"globals.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeGlobal = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction makeGlobal(name, type, card) {\n    return (0, path_1.$expressionify)({\n        __name__: name,\n        __element__: type,\n        __cardinality__: card,\n        __kind__: index_1.ExpressionKind.Global,\n    });\n}\nexports.makeGlobal = makeGlobal;\n"},{"path":"group.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.group = exports.isGroupingSet = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst __spec__1 = require(\"../__spec__\");\nconst literal_1 = require(\"./literal\");\nconst select_1 = require(\"./select\");\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nexports.isGroupingSet = isGroupingSet;\nconst makeGroupingSet = (prefix) => (grps) => {\n    const seenKeys = new Map();\n    const unfiltered = Object.entries(grps).flatMap(([k, grp]) => isGroupingSet(grp)\n        ? grp.__exprs__\n        : [[k, grp]]);\n    const filtered = unfiltered.filter(([k, expr]) => {\n        if (!seenKeys.has(k)) {\n            seenKeys.set(k, expr);\n            return true;\n        }\n        if (expr !== seenKeys.get(k)) {\n            throw new Error(`Cannot override pre-existing expression with key \"${k}\"`);\n        }\n        return false;\n    });\n    return {\n        [`${Math.round(1000000 * Math.random())}___`]: {\n            __kind__: \"groupingset\",\n            __settype__: prefix,\n            __elements__: grps,\n            __exprs__: filtered,\n        },\n    };\n};\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\nconst setFuncs = { set, tuple, rollup, cube };\nconst groupFunc = (expr, getter) => {\n    const { shape, scope, modifiers } = resolveShape(getter, expr);\n    const groupSet = tuple(modifiers.by);\n    const key = Object.keys(groupSet)[0];\n    const grouping = groupSet[key];\n    const keyShape = {};\n    const keyPointers = {};\n    const keyShapeElement = {};\n    for (const [k, e] of grouping.__exprs__) {\n        keyShape[k] = (0, path_1.$expressionify)({\n            __element__: e.__element__,\n            __cardinality__: index_1.Cardinality.AtMostOne,\n        });\n        keyPointers[k] = {\n            __kind__: \"property\",\n            target: e.__element__,\n            cardinality: index_1.Cardinality.AtMostOne,\n            exclusive: false,\n            computed: false,\n            readonly: false,\n            hasDefault: false,\n        };\n        keyShapeElement[k] = true;\n    }\n    const $FreeObject = (0, index_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find(s => s.name === \"std::FreeObject\").id, literal_1.literal);\n    const str = (0, index_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find(s => s.name === \"std::str\").id, literal_1.literal);\n    return (0, path_1.$expressionify)({\n        __element__: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n                ...$FreeObject.__pointers__,\n                __name__: \"std::FreeObject\",\n                grouping: {\n                    __kind__: \"property\",\n                    target: str,\n                    cardinality: index_1.Cardinality.Many,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                key: {\n                    __kind__: \"link\",\n                    target: {\n                        ...$FreeObject,\n                        __name__: \"std::FreeObject\",\n                        __pointers__: {\n                            ...$FreeObject.__pointers__,\n                            ...keyPointers,\n                        },\n                        __shape__: keyShape,\n                    },\n                    properties: {},\n                    cardinality: index_1.Cardinality.One,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                elements: {\n                    __kind__: \"link\",\n                    target: expr.__element__,\n                    cardinality: index_1.Cardinality.Many,\n                    properties: {},\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n            },\n            __shape__: {\n                grouping: (0, path_1.$expressionify)({\n                    __element__: str,\n                    __cardinality__: index_1.Cardinality.Many,\n                }),\n                key: (0, path_1.$expressionify)({\n                    __element__: {\n                        ...$FreeObject,\n                        __shape__: keyShape,\n                    },\n                    __cardinality__: index_1.Cardinality.One,\n                }),\n                elements: (0, path_1.$expressionify)({\n                    __element__: { ...expr.__element__, __shape__: shape },\n                    __cardinality__: index_1.Cardinality.Many,\n                }),\n            },\n        },\n        __cardinality__: index_1.Cardinality.Many,\n        __expr__: expr,\n        __modifiers__: { by: grouping },\n        __kind__: index_1.ExpressionKind.Group,\n        __scope__: scope,\n    });\n};\nObject.assign(groupFunc, setFuncs);\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = (0, path_1.$getScopedExpr)(expr);\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"by\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== index_1.TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = (0, select_1.resolveShapeElement)(key, value, scope);\n        }\n    }\n    if (Object.keys(shape).length === 0) {\n        shape.id = true;\n    }\n    if (!modifiers.by) {\n        throw new Error(\"Must provide a `by` key in `e.group`\");\n    }\n    return { shape, modifiers, scope };\n}\nexports.group = groupFunc;\n"},{"path":"insert.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.insert = exports.$normaliseInsertShape = exports.$insertify = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst cast_1 = require(\"./cast\");\nconst set_1 = require(\"./set\");\nconst literal_1 = require(\"./literal\");\nconst literal_2 = require(\"./literal\");\nfunction unlessConflict(conflictGetter) {\n    const expr = {\n        __kind__: index_1.ExpressionKind.InsertUnlessConflict,\n        __element__: this.__element__,\n        __cardinality__: index_1.Cardinality.AtMostOne,\n        __expr__: this,\n    };\n    if (!conflictGetter) {\n        expr.__conflict__ = { on: null };\n        return (0, path_1.$expressionify)(expr);\n    }\n    else {\n        const scopedExpr = (0, path_1.$getScopedExpr)(this.__expr__);\n        const conflict = conflictGetter(scopedExpr);\n        expr.__conflict__ = conflict;\n        if (conflict.else) {\n            expr.__cardinality__ = conflict.else.__cardinality__;\n            if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n                expr.__element__ = (0, literal_2.$getTypeByName)(\"std::Object\");\n            }\n        }\n        return (0, path_1.$expressionify)(expr);\n    }\n}\nfunction $insertify(expr) {\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return expr;\n}\nexports.$insertify = $insertify;\nfunction $normaliseInsertShape(root, shape, isUpdate = false) {\n    const newShape = {};\n    for (const [key, _val] of Object.entries(shape)) {\n        let val = _val;\n        let setModify = null;\n        if (isUpdate && _val != null && typeof _val === \"object\") {\n            const valKeys = Object.keys(_val);\n            if (valKeys.length === 1 &&\n                (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")) {\n                val = _val[valKeys[0]];\n                setModify = valKeys[0];\n            }\n        }\n        const pointer = root.__element__.__pointers__[key];\n        const isLinkProp = key[0] === \"@\";\n        if (!pointer && !isLinkProp) {\n            throw new Error(`Could not find property pointer for ${isUpdate ? \"update\" : \"insert\"} shape key: '${key}'`);\n        }\n        if (val === undefined)\n            continue;\n        if (val === null || val === void 0 ? void 0 : val.__kind__) {\n            if (val.__kind__ === index_1.ExpressionKind.Literal &&\n                val.__element__.__kind__ === index_1.TypeKind.range &&\n                val.__element__.__element__.__name__ === \"std::number\") {\n                newShape[key] = literal_1.literal(pointer.target, val.__value__);\n            }\n            else {\n                newShape[key] = _val;\n            }\n            continue;\n        }\n        if (isLinkProp) {\n            throw new Error(`Cannot assign plain data to link property '${key}'. Provide an expression instead.`);\n        }\n        if (pointer.__kind__ !== \"property\" && val !== null) {\n            throw new Error(`Must provide subquery when assigning to link '${key}' in ${isUpdate ? \"update\" : \"insert\"} query.`);\n        }\n        const isMulti = pointer.cardinality === index_1.Cardinality.AtLeastOne ||\n            pointer.cardinality === index_1.Cardinality.Many;\n        if (pointer.__kind__ === \"property\") {\n            if (pointer.target.__name__ === \"std::json\") {\n            }\n        }\n        const wrappedVal = val === null\n            ? (0, cast_1.cast)(pointer.target, null)\n            : isMulti && Array.isArray(val)\n                ? val.length === 0\n                    ? (0, cast_1.cast)(pointer.target, null)\n                    : (0, set_1.set)(...val.map(v => literal_1.literal(pointer.target, v)))\n                : literal_1.literal(pointer.target, val);\n        newShape[key] = setModify\n            ? { [setModify]: wrappedVal }\n            : wrappedVal;\n    }\n    return newShape;\n}\nexports.$normaliseInsertShape = $normaliseInsertShape;\nfunction insert(root, shape) {\n    if (typeof shape !== \"object\") {\n        throw new Error(`invalid insert shape.${typeof shape === \"function\"\n            ? \" Hint: Insert shape is expected to be an object, \" +\n                \"not a function returning a shape object.\"\n            : \"\"}`);\n    }\n    const expr = {\n        __kind__: index_1.ExpressionKind.Insert,\n        __element__: root.__element__,\n        __cardinality__: index_1.Cardinality.One,\n        __expr__: root,\n        __shape__: $normaliseInsertShape(root, shape),\n    };\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return (0, path_1.$expressionify)($insertify(expr));\n}\nexports.insert = insert;\n"},{"path":"json.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.jsonifyComplexParams = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nfunction jsonStringify(type, val) {\n    if (type.__kind__ === index_1.TypeKind.array) {\n        if (Array.isArray(val)) {\n            return `[${val\n                .map(item => jsonStringify(type.__element__, item))\n                .join()}]`;\n        }\n        throw new Error(`Param with array type is not an array`);\n    }\n    if (type.__kind__ === index_1.TypeKind.tuple) {\n        if (!Array.isArray(val)) {\n            throw new Error(`Param with tuple type is not an array`);\n        }\n        if (val.length !== type.__items__.length) {\n            throw new Error(`Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`);\n        }\n        return `[${val\n            .map((item, i) => jsonStringify(type.__items__[i], item))\n            .join()}]`;\n    }\n    if (type.__kind__ === index_1.TypeKind.namedtuple) {\n        if (typeof val !== \"object\") {\n            throw new Error(`Param with named tuple type is not an object`);\n        }\n        if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n            throw new Error(`Param with named tuple type has incorrect number of items. Got ${Object.keys(val).length} expected ${Object.keys(type.__shape__).length}`);\n        }\n        return `{${Object.entries(val)\n            .map(([key, item]) => {\n            if (!type.__shape__[key]) {\n                throw new Error(`Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(type.__shape__).join()}`);\n            }\n            return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n        })\n            .join()}}`;\n    }\n    if (type.__kind__ === index_1.TypeKind.scalar) {\n        switch (type.__name__) {\n            case \"std::bigint\":\n                return val.toString();\n            case \"std::json\":\n                return JSON.stringify(val);\n            case \"std::bytes\":\n                return `\"${val.toString(\"base64\")}\"`;\n            case \"cfg::memory\":\n                return `\"${val.toString()}\"`;\n            default:\n                return JSON.stringify(val);\n        }\n    }\n    if (type.__kind__ === index_1.TypeKind.enum) {\n        return JSON.stringify(val);\n    }\n    throw new Error(`Invalid param type: ${type.__kind__}`);\n}\nfunction jsonifyComplexParams(expr, _args) {\n    if (_args && expr.__kind__ === index_1.ExpressionKind.WithParams) {\n        const args = { ..._args };\n        for (const param of expr.__params__) {\n            if (param.__isComplex__) {\n                args[param.__name__] = jsonStringify(param.__element__, args[param.__name__]);\n            }\n        }\n        return args;\n    }\n    return _args;\n}\nexports.jsonifyComplexParams = jsonifyComplexParams;\n"},{"path":"literal.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$getTypeByName = exports.$getType = exports.$nameMapping = exports.literal = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst __spec__1 = require(\"../__spec__\");\nfunction literal(type, value) {\n    return (0, path_1.$expressionify)({\n        __element__: type,\n        __cardinality__: index_1.Cardinality.One,\n        __kind__: index_1.ExpressionKind.Literal,\n        __value__: value,\n    });\n}\nexports.literal = literal;\nexports.$nameMapping = new Map([\n    ...[...__spec__1.spec.values()].map(type => [type.name, type.id]),\n    [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\nfunction $getType(id) {\n    return (0, index_1.makeType)(__spec__1.spec, id, literal);\n}\nexports.$getType = $getType;\nfunction $getTypeByName(name) {\n    return (0, index_1.makeType)(__spec__1.spec, exports.$nameMapping.get(name), literal);\n}\nexports.$getTypeByName = $getTypeByName;\n"},{"path":"params.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.params = exports.optional = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction optional(type) {\n    return {\n        __kind__: index_1.ExpressionKind.OptionalParam,\n        __type__: type,\n    };\n}\nexports.optional = optional;\nconst complexParamKinds = new Set([index_1.TypeKind.tuple, index_1.TypeKind.namedtuple]);\nfunction params(paramsDef, expr) {\n    const paramExprs = {};\n    for (const [key, param] of Object.entries(paramsDef)) {\n        const paramType = param.__kind__ === index_1.ExpressionKind.OptionalParam ? param.__type__ : param;\n        const isComplex = complexParamKinds.has(paramType.__kind__) ||\n            (paramType.__kind__ === index_1.TypeKind.array &&\n                complexParamKinds.has(paramType.__element__.__kind__));\n        paramExprs[key] = (0, path_1.$expressionify)({\n            __kind__: index_1.ExpressionKind.Param,\n            __element__: paramType,\n            __cardinality__: param.__kind__ === index_1.ExpressionKind.OptionalParam\n                ? index_1.Cardinality.AtMostOne\n                : index_1.Cardinality.One,\n            __name__: key,\n            __isComplex__: isComplex,\n        });\n    }\n    const returnExpr = expr(paramExprs);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.WithParams,\n        __element__: returnExpr.__element__,\n        __cardinality__: returnExpr.__cardinality__,\n        __expr__: returnExpr,\n        __params__: Object.values(paramExprs),\n    });\n}\nexports.params = params;\n"},{"path":"path.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$PathNode = exports.$PathLeaf = exports.$pathify = exports.$getScopedExpr = exports.$expressionify = exports.$jsonDestructure = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst castMaps_1 = require(\"../castMaps\");\nconst collections_1 = require(\"./collections\");\nconst toEdgeQL_1 = require(\"./toEdgeQL\");\nconst query_1 = require(\"./query\");\nfunction PathLeaf(root, parent, exclusive, scopeRoot = null) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.PathLeaf,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __exclusive__: exclusive,\n        __scopeRoot__: scopeRoot,\n    });\n}\nexports.$PathLeaf = PathLeaf;\nfunction PathNode(root, parent, exclusive, scopeRoot = null) {\n    const obj = {\n        __kind__: index_1.ExpressionKind.PathNode,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __exclusive__: exclusive,\n        __scopeRoot__: scopeRoot,\n    };\n    const shape = {};\n    Object.entries(obj.__element__.__pointers__).map(([key, ptr]) => {\n        if (ptr.__kind__ === \"property\") {\n            shape[key] = true;\n        }\n    });\n    Object.defineProperty(obj, \"*\", {\n        writable: false,\n        value: shape,\n    });\n    return $expressionify(obj);\n}\nexports.$PathNode = PathNode;\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\nconst pathifyProxyHandlers = {\n    get(target, prop, proxy) {\n        var _a, _b, _c;\n        const ptr = target[_pointers][prop];\n        if (ptr) {\n            return ((_a = target[_pathCache][prop]) !== null && _a !== void 0 ? _a : (target[_pathCache][prop] = (ptr.__kind__ === \"property\" ? PathLeaf : PathNode)({\n                __element__: ptr.target,\n                __cardinality__: index_1.cardinalityUtil.multiplyCardinalities(target.__cardinality__, ptr.cardinality),\n            }, {\n                linkName: prop,\n                type: proxy,\n            }, (_b = ptr.exclusive) !== null && _b !== void 0 ? _b : false, (_c = target.__scopeRoot__) !== null && _c !== void 0 ? _c : (scopeRoots.has(proxy) ? proxy : null))));\n        }\n        return target[prop];\n    },\n};\nfunction _$pathify(_root) {\n    if (_root.__element__.__kind__ !== index_1.TypeKind.object) {\n        return _root;\n    }\n    const root = _root;\n    let pointers = {\n        ...root.__element__.__pointers__,\n    };\n    if (root.__parent__) {\n        const { type, linkName } = root.__parent__;\n        const parentPointer = type.__element__.__pointers__[linkName];\n        if ((parentPointer === null || parentPointer === void 0 ? void 0 : parentPointer.__kind__) === \"link\") {\n            pointers = { ...pointers, ...parentPointer.properties };\n        }\n    }\n    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {\n        if (pointers[key])\n            continue;\n        const valType = val === null || val === void 0 ? void 0 : val.__element__;\n        if (!valType)\n            continue;\n        pointers[key] = {\n            __kind__: valType.__kind__ === index_1.TypeKind.object ? \"link\" : \"property\",\n            properties: {},\n            target: val.__element__,\n            cardinality: val.__cardinality__,\n            exclusive: false,\n            computed: true,\n            readonly: true,\n            hasDefault: false,\n        };\n    }\n    root[_pointers] = pointers;\n    root[_pathCache] = {};\n    return new Proxy(root, pathifyProxyHandlers);\n}\nexports.$pathify = _$pathify;\nfunction isFunc(expr) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.TypeIntersection,\n        __cardinality__: this.__cardinality__,\n        __element__: {\n            ...expr.__element__,\n            __shape__: { id: true },\n        },\n        __expr__: this,\n    });\n}\nfunction assert_single(expr) {\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.Function,\n        __element__: expr.__element__,\n        __cardinality__: index_1.cardinalityUtil.overrideUpperBound(expr.__cardinality__, \"One\"),\n        __name__: \"std::assert_single\",\n        __args__: [expr],\n        __namedargs__: {},\n    });\n}\nconst jsonDestructureProxyHandlers = {\n    get(target, prop, proxy) {\n        if (typeof prop === \"string\" && !(prop in target)) {\n            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n            return jsonDestructure.call(proxy, parsedProp);\n        }\n        return target[prop];\n    },\n};\nfunction jsonDestructure(path) {\n    const pathTypeSet = (0, castMaps_1.literalToTypeSet)(path);\n    return $expressionify({\n        __kind__: index_1.ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: index_1.cardinalityUtil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, pathTypeSet],\n    });\n}\nfunction $jsonDestructure(_expr) {\n    if (_expr.__element__.__kind__ === index_1.TypeKind.scalar &&\n        _expr.__element__.__name__ === \"std::json\") {\n        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);\n        expr.destructure = jsonDestructure.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexports.$jsonDestructure = $jsonDestructure;\nfunction $expressionify(_expr) {\n    const expr = _$pathify($jsonDestructure((0, collections_1.$arrayLikeIndexify)((0, collections_1.$tuplePathify)(_expr))));\n    expr.run = query_1.$queryFunc.bind(expr);\n    expr.runJSON = query_1.$queryFuncJSON.bind(expr);\n    expr.is = isFunc.bind(expr);\n    expr.toEdgeQL = toEdgeQL_1.$toEdgeQL.bind(expr);\n    expr.assert_single = () => assert_single(expr);\n    return Object.freeze(expr);\n}\nexports.$expressionify = $expressionify;\nconst scopedExprCache = new WeakMap();\nconst scopeRoots = new WeakSet();\nfunction $getScopedExpr(expr, existingScopes) {\n    let scopedExpr = scopedExprCache.get(expr);\n    if (!scopedExpr || (existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.has(scopedExpr))) {\n        const isFreeObject = expr.__cardinality__ === index_1.Cardinality.One &&\n            expr.__element__.__name__ === \"std::FreeObject\";\n        const isInsert = expr.__kind__ === index_1.ExpressionKind.Insert;\n        scopedExpr =\n            isFreeObject || isInsert\n                ? expr\n                : $expressionify({\n                    ...expr,\n                    __cardinality__: index_1.Cardinality.One,\n                    __scopedFrom__: expr,\n                    \"*\": expr[\"*\"],\n                });\n        scopeRoots.add(scopedExpr);\n        const uncached = !scopedExpr;\n        if (uncached) {\n            scopedExprCache.set(expr, scopedExpr);\n        }\n    }\n    existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.add(scopedExpr);\n    return scopedExpr;\n}\nexports.$getScopedExpr = $getScopedExpr;\n"},{"path":"query.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$queryFuncJSON = exports.$queryFunc = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst json_1 = require(\"./json\");\nconst select_1 = require(\"./select\");\nconst runnableExpressionKinds = new Set([\n    index_1.ExpressionKind.Select,\n    index_1.ExpressionKind.Update,\n    index_1.ExpressionKind.Insert,\n    index_1.ExpressionKind.InsertUnlessConflict,\n    index_1.ExpressionKind.Delete,\n    index_1.ExpressionKind.Group,\n    index_1.ExpressionKind.For,\n    index_1.ExpressionKind.With,\n    index_1.ExpressionKind.WithParams,\n]);\nconst wrappedExprCache = new WeakMap();\nasync function $queryFunc(cxn, args) {\n    var _a;\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : (_a = wrappedExprCache.get(this)) !== null && _a !== void 0 ? _a : wrappedExprCache.set(this, (0, select_1.select)(this)).get(this);\n    const _args = (0, json_1.jsonifyComplexParams)(expr, args);\n    const query = expr.toEdgeQL();\n    if (expr.__cardinality__ === index_1.Cardinality.One ||\n        expr.__cardinality__ === index_1.Cardinality.AtMostOne ||\n        expr.__cardinality__ === index_1.Cardinality.Empty) {\n        return cxn.querySingle(query, _args);\n    }\n    else {\n        return cxn.query(query, _args);\n    }\n}\nexports.$queryFunc = $queryFunc;\nasync function $queryFuncJSON(cxn, args) {\n    var _a;\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : (_a = wrappedExprCache.get(this)) !== null && _a !== void 0 ? _a : wrappedExprCache.set(this, (0, select_1.select)(this)).get(this);\n    const _args = (0, json_1.jsonifyComplexParams)(expr, args);\n    if (expr.__cardinality__ === index_1.Cardinality.One ||\n        expr.__cardinality__ === index_1.Cardinality.AtMostOne) {\n        return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n    }\n    else {\n        return cxn.queryJSON(expr.toEdgeQL(), _args);\n    }\n}\nexports.$queryFuncJSON = $queryFuncJSON;\n"},{"path":"range.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$range = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst castMaps_1 = require(\"../castMaps\");\nconst __spec__1 = require(\"../__spec__\");\nconst literal_1 = require(\"./literal\");\nconst funcops_1 = require(\"./funcops\");\nconst path_1 = require(\"./path\");\nfunction range(...args) {\n    var _a;\n    if (args.length === 1) {\n        const arg = args[0];\n        if (arg instanceof edgedb_1.Range) {\n            if (arg.lower === null && arg.upper === null) {\n                throw new Error(`Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`);\n            }\n            if (arg.isEmpty) {\n                throw new Error(`Can't create literal expression from empty range.`);\n            }\n            return (0, literal_1.literal)(range((0, castMaps_1.literalToTypeSet)((_a = arg.lower) !== null && _a !== void 0 ? _a : arg.upper).__element__), arg);\n        }\n        if (arg.__kind__ && !arg.__element__) {\n            return {\n                __kind__: index_1.TypeKind.range,\n                __name__: `range<${arg.__name__}>`,\n                __element__: arg,\n            };\n        }\n    }\n    const { returnType, cardinality, args: positionalArgs, namedArgs, } = (0, funcops_1.$resolveOverload)(\"std::range\", args, __spec__1.spec, [\n        {\n            args: [\n                {\n                    typeId: literal_1.$nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                {\n                    typeId: literal_1.$nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            ],\n            namedArgs: {\n                inc_lower: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                inc_upper: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                empty: {\n                    typeId: literal_1.$nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            },\n            returnTypeId: literal_1.$nameMapping.get(\"range<std::anypoint>\"),\n        },\n    ]);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Function,\n        __element__: returnType,\n        __cardinality__: cardinality,\n        __name__: \"std::range\",\n        __args__: positionalArgs,\n        __namedargs__: namedArgs,\n    });\n}\nexports.$range = range;\n"},{"path":"select.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveShapeElement = exports.select = exports.shape = exports.$existingScopes = exports.$selectify = exports.delete = exports.$handleModifiers = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst literal_1 = require(\"./literal\");\nconst __spec__1 = require(\"../__spec__\");\nconst castMaps_1 = require(\"../castMaps\");\nexports.ASC = \"ASC\";\nexports.DESC = \"DESC\";\nexports.EMPTY_FIRST = \"EMPTY FIRST\";\nexports.EMPTY_LAST = \"EMPTY LAST\";\nfunction is(expr, shape) {\n    const mappedShape = {};\n    for (const [key, value] of Object.entries(shape)) {\n        mappedShape[key] = {\n            __kind__: index_1.ExpressionKind.PolyShapeElement,\n            __polyType__: expr,\n            __shapeElement__: value,\n        };\n    }\n    return mappedShape;\n}\nexports.is = is;\nfunction computeFilterCardinality(expr, cardinality, base) {\n    var _b, _c, _d;\n    let card = cardinality;\n    const filter = expr;\n    const baseIsObjectExpr = ((_b = base === null || base === void 0 ? void 0 : base.__element__) === null || _b === void 0 ? void 0 : _b.__kind__) === index_1.TypeKind.object;\n    const filterExprIsEq = filter.__kind__ === index_1.ExpressionKind.Operator && filter.__name__ === \"=\";\n    const arg0 = (_c = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _c === void 0 ? void 0 : _c[0];\n    const arg1 = (_d = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _d === void 0 ? void 0 : _d[1];\n    const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\n    const arg0IsUnique = (arg0 === null || arg0 === void 0 ? void 0 : arg0.__exclusive__) === true;\n    if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\n        const newCard = arg1.__cardinality__ === index_1.Cardinality.One ||\n            arg1.__cardinality__ === index_1.Cardinality.AtMostOne\n            ? index_1.Cardinality.AtMostOne\n            : arg1.__cardinality__ === index_1.Cardinality.Empty\n                ? index_1.Cardinality.Empty\n                : cardinality;\n        if (arg0.__kind__ === index_1.ExpressionKind.PathLeaf) {\n            const arg0ParentMatchesBase = arg0.__parent__.type.__element__.__name__ ===\n                base.__element__.__name__;\n            if (arg0ParentMatchesBase) {\n                card = newCard;\n            }\n        }\n        else if (arg0.__kind__ === index_1.ExpressionKind.PathNode) {\n            const parent = arg0.__parent__;\n            if (parent === null) {\n                const arg0MatchesBase = arg0.__element__.__name__ === base.__element__.__name__;\n                if (arg0MatchesBase) {\n                    card = newCard;\n                }\n            }\n            else {\n                const arg0ParentMatchesBase = (parent === null || parent === void 0 ? void 0 : parent.type.__element__.__name__) === base.__element__.__name__;\n                if (arg0ParentMatchesBase) {\n                    card = newCard;\n                }\n            }\n        }\n    }\n    return card;\n}\nfunction $handleModifiers(modifiers, rootExpr) {\n    const mods = { ...modifiers };\n    let card = rootExpr.__cardinality__;\n    if (mods.filter && rootExpr.__element__.__kind__ === index_1.TypeKind.object) {\n        card = computeFilterCardinality(mods.filter, card, rootExpr);\n    }\n    if (mods.order_by) {\n        const orderExprs = Array.isArray(mods.order_by)\n            ? mods.order_by\n            : [mods.order_by];\n        mods.order_by = orderExprs.map(expr => typeof expr.__element__ === \"undefined\"\n            ? expr\n            : { expression: expr });\n    }\n    if (mods.offset) {\n        mods.offset =\n            typeof mods.offset === \"number\"\n                ? (0, literal_1.$getTypeByName)(\"std::number\")(mods.offset)\n                : mods.offset;\n        card = index_1.cardinalityUtil.overrideLowerBound(card, \"Zero\");\n    }\n    if (mods.limit) {\n        let expr = mods.limit;\n        if (typeof expr === \"number\") {\n            expr = (0, literal_1.$getTypeByName)(\"std::number\")(expr);\n        }\n        else if (expr.__kind__ === index_1.ExpressionKind.Set) {\n            expr = expr.__exprs__[0];\n        }\n        mods.limit = expr;\n        card = index_1.cardinalityUtil.overrideLowerBound(card, \"Zero\");\n    }\n    return { modifiers: mods, cardinality: card };\n}\nexports.$handleModifiers = $handleModifiers;\nfunction deleteExpr(expr, modifiersGetter) {\n    const selectExpr = select(expr, modifiersGetter);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Delete,\n        __element__: selectExpr.__element__,\n        __cardinality__: selectExpr.__cardinality__,\n        __expr__: selectExpr,\n    });\n}\nexports.delete = deleteExpr;\nfunction $selectify(expr) {\n    return expr;\n}\nexports.$selectify = $selectify;\nconst $FreeObject = (0, index_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find(s => s.name === \"std::FreeObject\").id, literal_1.literal);\nconst FreeObject = {\n    __kind__: index_1.ExpressionKind.PathNode,\n    __element__: $FreeObject,\n    __cardinality__: index_1.Cardinality.One,\n    __parent__: null,\n    __exclusive__: true,\n    __scopeRoot__: null,\n};\nexports.$existingScopes = new Set();\nfunction $shape(_a, b) {\n    return b;\n}\nexports.shape = $shape;\nfunction select(...args) {\n    const firstArg = args[0];\n    if (typeof firstArg !== \"object\" ||\n        firstArg instanceof Buffer ||\n        firstArg instanceof Date ||\n        firstArg instanceof edgedb_1.Duration ||\n        firstArg instanceof edgedb_1.LocalDateTime ||\n        firstArg instanceof edgedb_1.LocalDate ||\n        firstArg instanceof edgedb_1.LocalTime ||\n        firstArg instanceof edgedb_1.RelativeDuration ||\n        firstArg instanceof edgedb_1.DateDuration ||\n        firstArg instanceof edgedb_1.ConfigMemory) {\n        const literalExpr = (0, castMaps_1.literalToTypeSet)(firstArg);\n        return (0, path_1.$expressionify)($selectify({\n            __kind__: index_1.ExpressionKind.Select,\n            __element__: literalExpr.__element__,\n            __cardinality__: literalExpr.__cardinality__,\n            __expr__: literalExpr,\n            __modifiers__: {},\n        }));\n    }\n    const exprPair = typeof args[0].__element__ !== \"undefined\"\n        ? args\n        : [FreeObject, () => args[0]];\n    let expr = exprPair[0];\n    const shapeGetter = exprPair[1];\n    if (expr === FreeObject) {\n        const freeObjectPtrs = {};\n        for (const [k, v] of Object.entries(args[0])) {\n            freeObjectPtrs[k] = {\n                __kind__: v.__element__.__kind__ === index_1.TypeKind.object ? \"link\" : \"property\",\n                target: v.__element__,\n                cardinality: v.__cardinality__,\n                exclusive: false,\n                computed: true,\n                readonly: true,\n                hasDefault: false,\n                properties: {},\n            };\n        }\n        expr = {\n            ...FreeObject,\n            __element__: {\n                ...FreeObject.__element__,\n                __pointers__: {\n                    ...FreeObject.__element__.__pointers__,\n                    ...freeObjectPtrs,\n                },\n            },\n        };\n    }\n    if (!shapeGetter) {\n        if (expr.__element__.__kind__ === index_1.TypeKind.object) {\n            const objectExpr = expr;\n            return (0, path_1.$expressionify)($selectify({\n                __kind__: index_1.ExpressionKind.Select,\n                __element__: {\n                    __kind__: index_1.TypeKind.object,\n                    __name__: `${objectExpr.__element__.__name__}`,\n                    __pointers__: objectExpr.__element__.__pointers__,\n                    __shape__: objectExpr.__element__.__shape__,\n                },\n                __cardinality__: objectExpr.__cardinality__,\n                __expr__: objectExpr,\n                __modifiers__: {},\n            }));\n        }\n        else {\n            return (0, path_1.$expressionify)($selectify({\n                __kind__: index_1.ExpressionKind.Select,\n                __element__: expr.__element__,\n                __cardinality__: expr.__cardinality__,\n                __expr__: expr,\n                __modifiers__: {},\n            }));\n        }\n    }\n    const cleanScopedExprs = exports.$existingScopes.size === 0;\n    const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\n    if (cleanScopedExprs) {\n        exports.$existingScopes.clear();\n    }\n    const { modifiers, cardinality } = $handleModifiers(mods, expr);\n    return (0, path_1.$expressionify)($selectify({\n        __kind__: index_1.ExpressionKind.Select,\n        __element__: expr.__element__.__kind__ === index_1.TypeKind.object\n            ? {\n                __kind__: index_1.TypeKind.object,\n                __name__: `${expr.__element__.__name__}`,\n                __pointers__: expr.__element__.__pointers__,\n                __shape__: shape,\n            }\n            : expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __modifiers__: modifiers,\n        __scope__: expr !== scope\n            ? scope\n            : undefined,\n    }));\n}\nexports.select = select;\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = expr.__element__.__kind__ === index_1.TypeKind.object\n        ? (0, path_1.$getScopedExpr)(expr, exports.$existingScopes)\n        : expr;\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"filter\" ||\n            key === \"order_by\" ||\n            key === \"offset\" ||\n            key === \"limit\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== index_1.TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    return { shape, modifiers, scope };\n}\nfunction resolveShapeElement(key, value, scope) {\n    var _b, _c, _d, _e, _f;\n    const isSubshape = typeof value === \"object\" &&\n        typeof value.__kind__ === \"undefined\";\n    const isClosure = typeof value === \"function\" &&\n        ((_b = scope.__element__.__pointers__[key]) === null || _b === void 0 ? void 0 : _b.__kind__) === \"link\";\n    if (isSubshape || isClosure) {\n        const childExpr = scope[key];\n        if (!childExpr) {\n            throw new Error(`Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`);\n        }\n        const { shape: childShape, scope: childScope, modifiers: mods, } = resolveShape(value, childExpr);\n        const { modifiers } = $handleModifiers(mods, childExpr);\n        return {\n            __kind__: index_1.ExpressionKind.Select,\n            __element__: {\n                __kind__: index_1.TypeKind.object,\n                __name__: `${childExpr.__element__.__name__}`,\n                __pointers__: childExpr.__element__.__pointers__,\n                __shape__: childShape,\n            },\n            __cardinality__: ((_d = (_c = scope.__element__.__pointers__) === null || _c === void 0 ? void 0 : _c[key]) === null || _d === void 0 ? void 0 : _d.cardinality) ||\n                ((_f = (_e = scope.__element__.__shape__) === null || _e === void 0 ? void 0 : _e[key]) === null || _f === void 0 ? void 0 : _f.__cardinality__),\n            __expr__: childExpr,\n            __modifiers__: modifiers,\n            __scope__: childExpr !== childScope ? childScope : undefined,\n        };\n    }\n    else if ((value === null || value === void 0 ? void 0 : value.__kind__) === index_1.ExpressionKind.PolyShapeElement) {\n        const polyElement = value;\n        const polyScope = scope.is(polyElement.__polyType__);\n        return {\n            __kind__: index_1.ExpressionKind.PolyShapeElement,\n            __polyType__: polyScope,\n            __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),\n        };\n    }\n    else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n        const linkProp = scope[key];\n        if (!linkProp) {\n            throw new Error(scope.__parent__\n                ? `link property '${key}' does not exist on link ${scope.__parent__.linkName}`\n                : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`);\n        }\n        return value ? linkProp : false;\n    }\n    else {\n        return value;\n    }\n}\nexports.resolveShapeElement = resolveShapeElement;\n"},{"path":"set.js","content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.set = exports.getSharedParent = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst castMaps = __importStar(require(\"../castMaps\"));\nfunction getSharedParent(a, b) {\n    if (a.__kind__ !== b.__kind__) {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    if (a.__kind__ === index_1.TypeKind.scalar && b.__kind__ === index_1.TypeKind.scalar) {\n        return castMaps.getSharedParentScalar(a, b);\n    }\n    else if (a.__kind__ === index_1.TypeKind.object &&\n        b.__kind__ === index_1.TypeKind.object) {\n        return (0, index_1.$mergeObjectTypes)(a, b);\n    }\n    else if (a.__kind__ === index_1.TypeKind.tuple && b.__kind__ === index_1.TypeKind.tuple) {\n        if (a.__items__.length !== b.__items__.length) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = a.__items__.map((_, i) => {\n                if (!a.__items__[i] || !b.__items__[i]) {\n                    throw new Error();\n                }\n                return getSharedParent(a.__items__[i], b.__items__[i]);\n            });\n            return {\n                __kind__: index_1.TypeKind.tuple,\n                __name__: `tuple<${items.map(item => item.__name__).join(\", \")}>`,\n                __items__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.namedtuple &&\n        b.__kind__ === index_1.TypeKind.namedtuple) {\n        const aKeys = Object.keys(a);\n        const bKeys = new Set(Object.keys(b));\n        const sameKeys = aKeys.length === bKeys.size && aKeys.every(k => bKeys.has(k));\n        if (!sameKeys) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = {};\n            for (const [i] of Object.entries(a.__shape__)) {\n                if (!a.__shape__[i] || !b.__shape__[i]) {\n                    throw new Error();\n                }\n                items[i] = getSharedParent(a.__shape__[i], b.__shape__[i]);\n            }\n            return {\n                __kind__: index_1.TypeKind.namedtuple,\n                __name__: `tuple<${Object.entries(items)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`,\n                __shape__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.array && b.__kind__ === index_1.TypeKind.array) {\n        try {\n            const mergedEl = getSharedParent(a.__element__, b.__element__);\n            return {\n                __kind__: index_1.TypeKind.array,\n                __name__: a.__name__,\n                __element__: mergedEl,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === index_1.TypeKind.enum && b.__kind__ === index_1.TypeKind.enum) {\n        if (a.__name__ === b.__name__)\n            return a;\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    else {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n}\nexports.getSharedParent = getSharedParent;\nvar setImpl_1 = require(\"./setImpl\");\nObject.defineProperty(exports, \"set\", { enumerable: true, get: function () { return setImpl_1.set; } });\n"},{"path":"syntax.js","content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./literal\"), exports);\n__exportStar(require(\"./path\"), exports);\n__exportStar(require(\"./set\"), exports);\n__exportStar(require(\"./cast\"), exports);\n__exportStar(require(\"./select\"), exports);\n__exportStar(require(\"./update\"), exports);\n__exportStar(require(\"./insert\"), exports);\n__exportStar(require(\"./group\"), exports);\n__exportStar(require(\"./collections\"), exports);\n__exportStar(require(\"./funcops\"), exports);\n__exportStar(require(\"./for\"), exports);\n__exportStar(require(\"./with\"), exports);\n__exportStar(require(\"./params\"), exports);\n__exportStar(require(\"./globals\"), exports);\n__exportStar(require(\"./detached\"), exports);\n__exportStar(require(\"./toEdgeQL\"), exports);\n__exportStar(require(\"./range\"), exports);\n"},{"path":"toEdgeQL.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$toEdgeQL = void 0;\nconst edgedb_1 = require(\"edgedb\");\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst reservedKeywords_1 = require(\"edgedb/dist/reflection/reservedKeywords.js\");\nconst toEdgeQLCache = new WeakMap();\nfunction $toEdgeQL() {\n    var _a;\n    if (toEdgeQLCache.has(this)) {\n        return toEdgeQLCache.get(this);\n    }\n    const walkExprCtx = {\n        seen: new Map(),\n        rootScope: null,\n    };\n    walkExprTree(this, null, walkExprCtx);\n    const withBlocks = new Map();\n    const withVars = new Map();\n    const seen = new Map(walkExprCtx.seen);\n    const linkProps = new Map();\n    for (const [expr, refData] of seen) {\n        seen.delete(expr);\n        if (refData.linkProps.length) {\n            linkProps.set(expr, refData.linkProps.map(linkProp => linkProp.__parent__.linkName.slice(1)));\n        }\n        if (withVars.has(expr)) {\n            continue;\n        }\n        if (!refData.boundScope &&\n            (expr.__kind__ === index_1.ExpressionKind.PathLeaf ||\n                expr.__kind__ === index_1.ExpressionKind.PathNode ||\n                expr.__kind__ === index_1.ExpressionKind.TypeIntersection)) {\n            continue;\n        }\n        if (expr.__kind__ === index_1.ExpressionKind.ForVar ||\n            expr.__kind__ === index_1.ExpressionKind.Param) {\n            continue;\n        }\n        if ((expr.__kind__ === index_1.ExpressionKind.Select ||\n            expr.__kind__ === index_1.ExpressionKind.Update ||\n            expr.__kind__ === index_1.ExpressionKind.Group) &&\n            expr.__scope__ &&\n            !withVars.has(expr.__scope__)) {\n            const withBlock = expr;\n            const scopeVar = expr.__scope__;\n            const scopeVarName = `__scope_${withVars.size}_${scopeVar.__element__.__name__.split(\"::\")[1]}`;\n            withVars.set(scopeVar, {\n                name: scopeVarName,\n                scope: withBlock,\n                childExprs: new Set(),\n                scopedExpr: expr.__element__.__kind__ === index_1.TypeKind.object\n                    ? expr.__expr__\n                    : undefined,\n            });\n        }\n        if (refData.refCount > 1 ||\n            refData.boundScope ||\n            refData.aliases.length > 0) {\n            let withBlock = refData.boundScope;\n            const parentScopes = [...refData.parentScopes].filter(scope => scope !== null);\n            if (!withBlock) {\n                if (parentScopes.some(parentScope => seen.has(parentScope))) {\n                    seen.set(expr, refData);\n                    continue;\n                }\n                const resolvedParentScopes = parentScopes.map(parentScope => { var _a, _b; return (_b = (_a = withVars.get(parentScope)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : parentScope; });\n                withBlock =\n                    (_a = resolvedParentScopes.find(parentScope => {\n                        const childExprs = new Set(walkExprCtx.seen.get(parentScope).childExprs);\n                        return resolvedParentScopes.every(scope => childExprs.has(scope) || scope === parentScope);\n                    })) !== null && _a !== void 0 ? _a : walkExprCtx.rootScope;\n            }\n            if (!withBlock) {\n                throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                    `query has no 'WITH'able expressions`);\n            }\n            if (!withBlocks.has(withBlock)) {\n                withBlocks.set(withBlock, new Set());\n            }\n            const validScopes = new Set([\n                withBlock,\n                ...walkExprCtx.seen.get(withBlock).childExprs,\n            ]);\n            for (const scope of [\n                ...refData.parentScopes,\n                ...index_1.util.flatMap(refData.aliases, alias => [\n                    ...walkExprCtx.seen.get(alias).parentScopes,\n                ]),\n            ]) {\n                if (scope === null || !validScopes.has(scope)) {\n                    throw new Error(refData.boundScope\n                        ? `Expr or its aliases used outside of declared 'WITH' block scope`\n                        : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                            `expression or its aliases appear outside root scope`);\n                }\n            }\n            for (const withVar of [expr, ...refData.aliases]) {\n                const withVarBoundScope = walkExprCtx.seen.get(withVar).boundScope;\n                if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n                    continue;\n                }\n                const withVarName = `__withVar_${withVars.size}`;\n                withBlocks.get(withBlock).add(withVar);\n                withVars.set(withVar, {\n                    name: withVarName,\n                    scope: withBlock,\n                    childExprs: new Set(walkExprCtx.seen.get(withVar).childExprs),\n                });\n            }\n        }\n    }\n    let edgeQL = renderEdgeQL(this, {\n        withBlocks,\n        withVars,\n        forVars: new Map(),\n        linkProps,\n    });\n    if (edgeQL.startsWith(\"(\") &&\n        edgeQL.endsWith(\")\") &&\n        !(this.__kind__ === index_1.ExpressionKind.Tuple ||\n            this.__kind__ === index_1.ExpressionKind.NamedTuple ||\n            this.__kind__ === index_1.ExpressionKind.Literal)) {\n        edgeQL = edgeQL.slice(1, -1);\n    }\n    toEdgeQLCache.set(this, edgeQL);\n    return edgeQL;\n}\nexports.$toEdgeQL = $toEdgeQL;\nfunction walkExprTree(_expr, parentScope, ctx) {\n    var _a, _b, _c, _d;\n    if (!_expr.__kind__) {\n        throw new Error(`Expected a valid querybuilder expression, ` +\n            `instead received ${typeof _expr}${typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"}.` +\n            getErrorHint(_expr));\n    }\n    const expr = _expr;\n    function walkShape(shape) {\n        for (let param of Object.values(shape)) {\n            if (param.__kind__ === index_1.ExpressionKind.PolyShapeElement) {\n                param = param.__shapeElement__;\n            }\n            if (typeof param === \"object\") {\n                if (!!param.__kind__) {\n                    childExprs.push(...walkExprTree(param, expr, ctx));\n                }\n                else {\n                    walkShape(param);\n                }\n            }\n        }\n    }\n    if (!ctx.rootScope && parentScope) {\n        ctx.rootScope = parentScope;\n    }\n    const seenExpr = ctx.seen.get(expr);\n    if (seenExpr) {\n        seenExpr.refCount += 1;\n        seenExpr.parentScopes.add(parentScope);\n        return [expr, ...seenExpr.childExprs];\n    }\n    const childExprs = [];\n    ctx.seen.set(expr, {\n        refCount: 1,\n        parentScopes: new Set([parentScope]),\n        childExprs,\n        boundScope: null,\n        aliases: [],\n        linkProps: [],\n    });\n    switch (expr.__kind__) {\n        case index_1.ExpressionKind.Alias:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            ctx.seen.get(expr.__expr__).aliases.push(expr);\n            break;\n        case index_1.ExpressionKind.With:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            for (const refExpr of expr.__refs__) {\n                walkExprTree(refExpr, expr.__expr__, ctx);\n                const seenRef = ctx.seen.get(refExpr);\n                if (seenRef.boundScope) {\n                    throw new Error(`Expression bound to multiple 'WITH' blocks`);\n                }\n                seenRef.boundScope = expr.__expr__;\n            }\n            break;\n        case index_1.ExpressionKind.Literal:\n        case index_1.ExpressionKind.ForVar:\n        case index_1.ExpressionKind.Param:\n            break;\n        case index_1.ExpressionKind.PathLeaf:\n        case index_1.ExpressionKind.PathNode:\n            if (expr.__parent__) {\n                if (expr.__parent__.type.__scopedFrom__) {\n                    childExprs.push(expr.__parent__.type);\n                }\n                else {\n                    childExprs.push(...walkExprTree(expr.__parent__.type, parentScope, ctx));\n                }\n                if (expr.__kind__ === index_1.ExpressionKind.PathLeaf &&\n                    expr.__parent__.linkName.startsWith(\"@\")) {\n                    const parentScopeVar = parentScope.__scope__;\n                    if (parentScopeVar === expr.__parent__.type) {\n                        (_a = ctx.seen.get(parentScope)) === null || _a === void 0 ? void 0 : _a.linkProps.push(expr);\n                    }\n                }\n            }\n            break;\n        case index_1.ExpressionKind.Cast:\n            if (expr.__expr__ === null)\n                break;\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Set:\n            for (const subExpr of expr.__exprs__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.Array:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.Tuple:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.NamedTuple:\n            for (const subExpr of Object.values(expr.__shape__)) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case index_1.ExpressionKind.TuplePath:\n            childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Select:\n        case index_1.ExpressionKind.Update: {\n            const modifiers = expr.__modifiers__;\n            if (modifiers.filter) {\n                childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n            }\n            if (modifiers.order_by) {\n                for (const orderExpr of modifiers.order_by) {\n                    childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n                }\n            }\n            if (modifiers.offset) {\n                childExprs.push(...walkExprTree(modifiers.offset, expr, ctx));\n            }\n            if (modifiers.limit) {\n                childExprs.push(...walkExprTree(modifiers.limit, expr, ctx));\n            }\n            if (expr.__kind__ === index_1.ExpressionKind.Select) {\n                if ((0, index_1.isObjectType)(expr.__element__) &&\n                    expr.__element__.__shape__ !==\n                        expr.__expr__.__element__.__shape__) {\n                    walkShape((_b = expr.__element__.__shape__) !== null && _b !== void 0 ? _b : {});\n                }\n            }\n            else {\n                const shape = (_c = expr.__shape__) !== null && _c !== void 0 ? _c : {};\n                for (const _element of Object.values(shape)) {\n                    let element = _element;\n                    if (!element.__element__) {\n                        if (element[\"+=\"])\n                            element = element[\"+=\"];\n                        else if (element[\"-=\"])\n                            element = element[\"-=\"];\n                    }\n                    childExprs.push(...walkExprTree(element, expr, ctx));\n                }\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Delete: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Insert: {\n            const shape = (_d = expr.__shape__) !== null && _d !== void 0 ? _d : {};\n            for (const element of Object.values(shape)) {\n                childExprs.push(...walkExprTree(element, expr, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.InsertUnlessConflict: {\n            if (expr.__conflict__.on) {\n                childExprs.push(...walkExprTree(expr.__conflict__.on, expr.__expr__, ctx));\n            }\n            if (expr.__conflict__.else) {\n                childExprs.push(...walkExprTree(expr.__conflict__.else, expr.__expr__, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Group: {\n            const groupingSet = expr.__modifiers__.by;\n            for (const [_k, groupExpr] of groupingSet.__exprs__) {\n                const seen = new Set();\n                if (!seen.has(expr)) {\n                    childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n                    seen.add(expr);\n                }\n            }\n            if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n                throw new Error(\"Missing shape in GROUP statement\");\n            }\n            walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.TypeIntersection:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case index_1.ExpressionKind.Operator:\n        case index_1.ExpressionKind.Function:\n            for (const subExpr of expr.__args__) {\n                if (Array.isArray(subExpr)) {\n                    for (const arg of subExpr) {\n                        if (arg)\n                            childExprs.push(...walkExprTree(arg, parentScope, ctx));\n                    }\n                }\n                else {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            if (expr.__kind__ === index_1.ExpressionKind.Function) {\n                for (const subExpr of Object.values(expr.__namedargs__)) {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            break;\n        case index_1.ExpressionKind.For: {\n            childExprs.push(...walkExprTree(expr.__iterSet__, expr, ctx));\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.WithParams: {\n            if (parentScope !== null) {\n                throw new Error(`'withParams' does not support being used as a nested expression`);\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Detached: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case index_1.ExpressionKind.Global:\n            break;\n        default:\n            index_1.util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n    return [expr, ...childExprs];\n}\nfunction renderEdgeQL(_expr, ctx, renderShape = true, noImplicitDetached = false) {\n    var _a, _b;\n    if (!_expr.__kind__) {\n        throw new Error(\"Invalid expression.\");\n    }\n    const expr = _expr;\n    const withVar = ctx.withVars.get(expr);\n    if (withVar && ctx.renderWithVar !== expr) {\n        return renderShape &&\n            expr.__kind__ === index_1.ExpressionKind.Select &&\n            (0, index_1.isObjectType)(expr.__element__)\n            ? `(${withVar.name} ${shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, null, true)})`\n            : withVar.name;\n    }\n    function renderWithBlockExpr(varExpr, _noImplicitDetached) {\n        var _a, _b;\n        const withBlockElement = ctx.withVars.get(varExpr);\n        let renderedExpr = renderEdgeQL((_a = withBlockElement.scopedExpr) !== null && _a !== void 0 ? _a : varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, _noImplicitDetached);\n        const renderedExprNoDetached = renderEdgeQL((_b = withBlockElement.scopedExpr) !== null && _b !== void 0 ? _b : varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, true);\n        if (ctx.linkProps.has(expr)) {\n            renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n                .get(expr)\n                .map(linkPropName => `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`)\n                .join(\",\\n\")}\\n})`;\n        }\n        return `  ${withBlockElement.name} := ${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}`;\n    }\n    const scopeExpr = (expr.__kind__ === index_1.ExpressionKind.Select ||\n        expr.__kind__ === index_1.ExpressionKind.Update ||\n        expr.__kind__ === index_1.ExpressionKind.Group) &&\n        ctx.withVars.has(expr.__scope__)\n        ? expr.__scope__\n        : undefined;\n    const scopeExprVar = [];\n    const unscopedWithBlock = [];\n    const scopedWithBlock = [];\n    if (ctx.withBlocks.has(expr) || scopeExpr) {\n        const sortedBlockVars = topoSortWithVars((_a = ctx.withBlocks.get(expr)) !== null && _a !== void 0 ? _a : new Set(), ctx);\n        if (!scopeExpr) {\n            unscopedWithBlock.push(...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar)));\n        }\n        else {\n            const scopeVar = ctx.withVars.get(scopeExpr);\n            const scopedVars = sortedBlockVars.filter(blockVarExpr => { var _a; return (_a = ctx.withVars.get(blockVarExpr)) === null || _a === void 0 ? void 0 : _a.childExprs.has(scopeExpr); });\n            unscopedWithBlock.push(...sortedBlockVars\n                .filter(blockVar => !scopedVars.includes(blockVar))\n                .map(blockVar => renderWithBlockExpr(blockVar)));\n            if (!scopedVars.length) {\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n            }\n            else {\n                const scopeName = scopeVar.name;\n                scopeVar.name = scopeName + \"_expr\";\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n                scopeVar.name = scopeName + \"_inner\";\n                scopeExprVar.push(`  ${scopeName} := (FOR ${scopeVar.name} IN {${scopeName + \"_expr\"}} UNION (\\n    WITH\\n${indent(scopedVars\n                    .map(blockVar => renderWithBlockExpr(blockVar))\n                    .join(\",\\n\"), 4)}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n                    .map(blockVar => {\n                    const name = ctx.withVars.get(blockVar).name;\n                    return `      ${name} := ${name}`;\n                })\n                    .join(\",\\n\")}\\n    }\\n  ))`);\n                scopeVar.name = scopeName;\n                for (const blockVarExpr of scopedVars) {\n                    const blockVar = ctx.withVars.get(blockVarExpr);\n                    blockVar.name = `${scopeName}.${blockVar.name}`;\n                }\n            }\n        }\n    }\n    const withBlockElements = [\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        ...scopedWithBlock,\n    ];\n    const withBlock = withBlockElements.length\n        ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n        : \"\";\n    if (expr.__kind__ === index_1.ExpressionKind.With) {\n        return renderEdgeQL(expr.__expr__, ctx);\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.WithParams) {\n        return `(WITH\\n${expr.__params__\n            .map(param => {\n            const optional = param.__cardinality__ === index_1.Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n            return `  __param__${param.__name__} := ${param.__isComplex__\n                ? `<${param.__element__.__name__}>to_json(<${optional}str>$${param.__name__})`\n                : `<${optional}${param.__element__.__name__}>$${param.__name__}`}`;\n        })\n            .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Alias) {\n        const aliasedExprVar = ctx.withVars.get(expr.__expr__);\n        if (!aliasedExprVar) {\n            throw new Error(`Expression referenced by alias does not exist in 'WITH' block`);\n        }\n        return aliasedExprVar.name;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.PathNode ||\n        expr.__kind__ === index_1.ExpressionKind.PathLeaf) {\n        if (!expr.__parent__) {\n            return `${noImplicitDetached ? \"\" : \"DETACHED \"}${expr.__element__.__name__}`;\n        }\n        else {\n            const isScopedLinkProp = expr.__parent__.linkName.startsWith(\"@\") &&\n                ctx.withVars.has(expr.__parent__.type);\n            const linkName = isScopedLinkProp\n                ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n                : expr.__parent__.linkName;\n            const parent = renderEdgeQL(expr.__parent__.type, ctx, false, noImplicitDetached);\n            return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Literal) {\n        return literalToEdgeQL(expr.__element__, expr.__value__);\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Set) {\n        const exprs = expr.__exprs__;\n        if (exprs.every(ex => ex.__element__.__kind__ === index_1.TypeKind.object) ||\n            exprs.every(ex => ex.__element__.__kind__ !== index_1.TypeKind.object)) {\n            if (exprs.length === 0)\n                return `<${expr.__element__.__name__}>{}`;\n            return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n        }\n        else {\n            throw new Error(`Invalid arguments to set constructor: ${exprs\n                .map(ex => ex.__element__.__name__)\n                .join(\", \")}`);\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Array) {\n        return `[${expr.__items__\n            .map(item => renderEdgeQL(item, ctx))\n            .join(\", \")}]`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Tuple) {\n        return `(\\n${expr.__items__\n            .map(item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached))\n            .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.NamedTuple) {\n        return `(\\n${Object.keys(expr.__shape__)\n            .map(key => `  ${key} := ${renderEdgeQL(expr.__shape__[key], ctx, renderShape, noImplicitDetached)}`)\n            .join(\",\\n\")}\\n)`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.TuplePath) {\n        return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Cast) {\n        const typeName = expr.__element__.__name__ === \"std::number\"\n            ? \"std::float64\"\n            : expr.__element__.__name__;\n        if (expr.__expr__ === null) {\n            return `<${typeName}>{}`;\n        }\n        return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Select) {\n        const lines = [];\n        if ((0, index_1.isObjectType)(expr.__element__)) {\n            const selectionTarget = renderEdgeQL((_b = expr.__scope__) !== null && _b !== void 0 ? _b : expr.__expr__, ctx, false);\n            lines.push(`SELECT${selectionTarget === \"DETACHED std::FreeObject\"\n                ? \"\"\n                : ` ${selectionTarget}`}`);\n            if (expr.__element__.__shape__ !==\n                expr.__expr__.__element__.__shape__) {\n                lines.push(shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, expr.__element__));\n            }\n        }\n        else {\n            const needsScalarVar = (expr.__modifiers__.filter ||\n                expr.__modifiers__.order_by ||\n                expr.__modifiers__.offset ||\n                expr.__modifiers__.limit) &&\n                !ctx.withVars.has(expr.__expr__);\n            lines.push(`SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(expr.__expr__, ctx)}`);\n            if (needsScalarVar) {\n                ctx = { ...ctx, withVars: new Map(ctx.withVars) };\n                ctx.withVars.set(expr.__expr__, {\n                    name: \"_\",\n                    childExprs: new Set(),\n                    scope: expr,\n                });\n            }\n        }\n        const modifiers = [];\n        if (expr.__modifiers__.filter) {\n            modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n        }\n        if (expr.__modifiers__.order_by) {\n            modifiers.push(...expr.__modifiers__.order_by.map(({ expression, direction, empty }, i) => {\n                return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(expression, ctx)}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n            }));\n        }\n        if (expr.__modifiers__.offset) {\n            modifiers.push(`OFFSET ${renderEdgeQL(expr.__modifiers__.offset, ctx)}`);\n        }\n        if (expr.__modifiers__.limit) {\n            modifiers.push(`LIMIT ${renderEdgeQL(expr.__modifiers__.limit, ctx)}`);\n        }\n        return (\"(\" +\n            withBlock +\n            lines.join(\" \") +\n            (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n            \")\");\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Update) {\n        return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${expr.__modifiers__.filter\n            ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n            : \" \"}SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Delete) {\n        return `(${withBlock}DELETE ${renderEdgeQL(expr.__expr__, ctx, undefined, noImplicitDetached)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Insert) {\n        return `(${withBlock}INSERT ${renderEdgeQL(expr.__expr__, ctx, false, true)} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.InsertUnlessConflict) {\n        const $on = expr.__conflict__.on;\n        const $else = expr.__conflict__.else;\n        const clause = [];\n        if (!$on) {\n            clause.push(\"\\nUNLESS CONFLICT\");\n        }\n        if ($on) {\n            clause.push(`\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`);\n        }\n        if ($else) {\n            clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n        }\n        return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(1, -1)} ${clause.join(\"\")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Group) {\n        const groupingSet = expr.__modifiers__.by;\n        const elementsShape = expr.__element__.__shape__.elements.__element__.__shape__;\n        const selectStatement = [];\n        const groupStatement = [];\n        const groupTarget = renderEdgeQL(expr.__scope__, ctx);\n        groupStatement.push(`GROUP ${groupTarget}`);\n        const combinedBlock = [\n            ...groupingSet.__exprs__.map(([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`),\n        ];\n        groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n        let by = renderGroupingSet(groupingSet).trim();\n        if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n            by = by.slice(1, by.length - 1);\n        }\n        groupStatement.push(`BY ` + by);\n        const selectTarget = `${groupTarget}_groups`;\n        selectStatement.push(`WITH\\n${[\n            ...unscopedWithBlock,\n            ...scopeExprVar,\n        ].join(\",\\n\")},\n  ${selectTarget} := (\n${indent(groupStatement.join(\"\\n\"), 4)}\n)`);\n        const scopeVar = ctx.withVars.get(expr.__scope__);\n        const elementsShapeQuery = indent(shapeToEdgeQL(elementsShape, { ...ctx }, expr.__element__), 2)\n            .trim()\n            .split(scopeVar.name + \".\")\n            .join(`${selectTarget}.elements.`);\n        selectStatement.push(`SELECT ${selectTarget} {\n  key: {${groupingSet.__exprs__.map(e => e[0]).join(\", \")}},\n  grouping,\n  elements: ${elementsShapeQuery}\n}`);\n        return `(${selectStatement.join(\"\\n\")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Function) {\n        const args = expr.__args__.map(arg => `${renderEdgeQL(arg, ctx, false)}`);\n        for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n            args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n        }\n        return `${expr.__name__}(${args.join(\", \")})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Operator) {\n        const operator = expr.__name__;\n        const args = expr.__args__;\n        switch (expr.__opkind__) {\n            case index_1.OperatorKind.Infix:\n                if (operator === \"[]\") {\n                    let index = \"\";\n                    if (Array.isArray(args[1])) {\n                        const [start, end] = args[1];\n                        if (start) {\n                            index += renderEdgeQL(start, ctx);\n                        }\n                        index += \":\";\n                        if (end) {\n                            index += renderEdgeQL(end, ctx);\n                        }\n                    }\n                    else {\n                        index = renderEdgeQL(args[1], ctx);\n                    }\n                    return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n                }\n                return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(args[1], ctx)})`;\n            case index_1.OperatorKind.Postfix:\n                return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n            case index_1.OperatorKind.Prefix:\n                return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n            case index_1.OperatorKind.Ternary:\n                if (operator === \"if_else\") {\n                    return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(args[1], ctx)} ELSE ${renderEdgeQL(args[2], ctx)})`;\n                }\n                else {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n            default:\n                index_1.util.assertNever(expr.__opkind__, new Error(`Unknown operator kind: ${expr.__opkind__}`));\n        }\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.TypeIntersection) {\n        return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${expr.__element__.__name__}]`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.For) {\n        ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n        return `(${withBlock}FOR ${ctx.forVars.get(expr.__forVar__)} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.ForVar) {\n        const forVar = ctx.forVars.get(expr);\n        if (!forVar) {\n            throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n        }\n        return forVar;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Param) {\n        return `__param__${expr.__name__}`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Detached) {\n        return `(DETACHED ${renderEdgeQL(expr.__expr__, {\n            ...ctx,\n            renderWithVar: expr.__expr__,\n        }, undefined, true)})`;\n    }\n    else if (expr.__kind__ === index_1.ExpressionKind.Global) {\n        return `(GLOBAL ${expr.__name__})`;\n    }\n    else {\n        index_1.util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n}\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nfunction renderGroupingSet(set) {\n    const contents = Object.entries(set.__elements__)\n        .map(([k, v]) => {\n        return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n        .join(\", \");\n    if (set.__settype__ === \"tuple\") {\n        return `(${contents})`;\n    }\n    else if (set.__settype__ === \"set\") {\n        return `{${contents}}`;\n    }\n    else if (set.__settype__ === \"cube\") {\n        return `cube(${contents})`;\n    }\n    else if (set.__settype__ === \"rollup\") {\n        return `rollup(${contents})`;\n    }\n    else {\n        throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n    }\n}\nfunction shapeToEdgeQL(shape, ctx, type = null, keysOnly = false, injectImplicitId = true) {\n    const pointers = (type === null || type === void 0 ? void 0 : type.__pointers__) || null;\n    const isFreeObject = (type === null || type === void 0 ? void 0 : type.__name__) === \"std::FreeObject\";\n    if (shape === null) {\n        return ``;\n    }\n    const lines = [];\n    const addLine = (line) => lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n    const seen = new Set();\n    for (const key in shape) {\n        if (!shape.hasOwnProperty(key))\n            continue;\n        if (seen.has(key)) {\n            console.warn(`Invalid: duplicate key \"${key}\"`);\n            continue;\n        }\n        seen.add(key);\n        let val = shape[key];\n        let operator = \":=\";\n        let polyType = null;\n        if (typeof val === \"object\" && !val.__element__) {\n            if (!!val[\"+=\"]) {\n                operator = \"+=\";\n                val = val[\"+=\"];\n            }\n            else if (!!val[\"-=\"]) {\n                operator = \"-=\";\n                val = val[\"-=\"];\n            }\n        }\n        if (val.__kind__ === index_1.ExpressionKind.PolyShapeElement) {\n            polyType = val.__polyType__;\n            val = val.__shapeElement__;\n        }\n        const polyIntersection = polyType\n            ? `[IS ${polyType.__element__.__name__}].`\n            : \"\";\n        const ptr = pointers === null || pointers === void 0 ? void 0 : pointers[key];\n        const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n        const expectedCardinality = addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n            ? val.__cardinality__ === index_1.Cardinality.Many ||\n                val.__cardinality__ === index_1.Cardinality.AtLeastOne\n                ? \"multi \"\n                : \"single \"\n            : \"\";\n        const wrapAssertExists = (ptr === null || ptr === void 0 ? void 0 : ptr.cardinality) === index_1.Cardinality.AtLeastOne;\n        if (typeof val === \"boolean\") {\n            if (!(pointers === null || pointers === void 0 ? void 0 : pointers[key]) &&\n                key[0] !== \"@\" &&\n                type &&\n                (type === null || type === void 0 ? void 0 : type.__name__) !== \"std::FreeObject\" &&\n                !polyIntersection) {\n                throw new Error(`Field \"${key}\" does not exist in ${type === null || type === void 0 ? void 0 : type.__name__}`);\n            }\n            if (val) {\n                addLine(`${polyIntersection}${q(key)}`);\n            }\n            continue;\n        }\n        if (typeof val !== \"object\") {\n            throw new Error(`Invalid shape element at \"${key}\".`);\n        }\n        const valIsExpression = val.hasOwnProperty(\"__kind__\");\n        if (!valIsExpression) {\n            addLine(`${polyIntersection}${q(key, false)}: ${indent(shapeToEdgeQL(val, ctx, ptr === null || ptr === void 0 ? void 0 : ptr.target), 2).trim()}`);\n            continue;\n        }\n        if (keysOnly) {\n            addLine(q(key, false) +\n                ((0, index_1.isObjectType)(val.__element__)\n                    ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n                    : \"\"));\n            continue;\n        }\n        const renderedExpr = renderEdgeQL(val, ctx);\n        addLine(`${expectedCardinality}${q(key, false)} ${operator} ${wrapAssertExists ? \"assert_exists(\" : \"\"}${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}${wrapAssertExists ? \")\" : \"\"}`);\n    }\n    if (lines.length === 0 && injectImplicitId) {\n        addLine(\"id\");\n    }\n    return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\nfunction topoSortWithVars(vars, ctx) {\n    if (!vars.size) {\n        return [];\n    }\n    const sorted = [];\n    const unvisited = new Set(vars);\n    const visiting = new Set();\n    for (const withVar of unvisited) {\n        visit(withVar);\n    }\n    function visit(withVar) {\n        if (!unvisited.has(withVar)) {\n            return;\n        }\n        if (visiting.has(withVar)) {\n            throw new Error(`'WITH' variables contain a cyclic dependency`);\n        }\n        visiting.add(withVar);\n        for (const child of ctx.withVars.get(withVar).childExprs) {\n            if (vars.has(child)) {\n                visit(child);\n            }\n        }\n        visiting.delete(withVar);\n        unvisited.delete(withVar);\n        sorted.push(withVar);\n    }\n    return sorted;\n}\nconst numericalTypes = {\n    \"std::number\": true,\n    \"std::int16\": true,\n    \"std::int32\": true,\n    \"std::int64\": true,\n    \"std::float32\": true,\n    \"std::float64\": true,\n};\nfunction literalToEdgeQL(type, val) {\n    let skipCast = false;\n    let stringRep;\n    if (type.__name__ === \"std::json\") {\n        skipCast = true;\n        stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n    }\n    else if (typeof val === \"string\") {\n        if (numericalTypes[type.__name__]) {\n            skipCast = true;\n            stringRep = val;\n        }\n        else if (type.__kind__ === index_1.TypeKind.enum) {\n            skipCast = true;\n            const vals = type.__values__;\n            if (vals.includes(val)) {\n                skipCast = true;\n                if (val.includes(\" \")) {\n                    stringRep = `<${type.__name__}>\"${val}\"`;\n                }\n                else {\n                    stringRep = `${type.__name__}.${val}`;\n                }\n            }\n            else {\n                throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n            }\n        }\n        else {\n            if (type.__name__ === \"std::str\") {\n                skipCast = true;\n            }\n            stringRep = JSON.stringify(val);\n        }\n    }\n    else if (typeof val === \"number\") {\n        if (numericalTypes[type.__name__]) {\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Unknown numerical type: ${type.__name__}!`);\n        }\n        stringRep = `${val.toString()}`;\n    }\n    else if (typeof val === \"boolean\") {\n        stringRep = `${val.toString()}`;\n        skipCast = true;\n    }\n    else if (typeof val === \"bigint\") {\n        stringRep = `${val.toString()}n`;\n    }\n    else if (Array.isArray(val)) {\n        skipCast = val.length !== 0;\n        if ((0, index_1.isArrayType)(type)) {\n            stringRep = `[${val\n                .map(el => literalToEdgeQL(type.__element__, el))\n                .join(\", \")}]`;\n        }\n        else if ((0, index_1.isTupleType)(type)) {\n            stringRep = `( ${val\n                .map((el, j) => literalToEdgeQL(type.__items__[j], el))\n                .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else if (val instanceof Date) {\n        stringRep = `'${val.toISOString()}'`;\n    }\n    else if (val instanceof edgedb_1.LocalDate ||\n        val instanceof edgedb_1.LocalDateTime ||\n        val instanceof edgedb_1.LocalTime ||\n        val instanceof edgedb_1.Duration ||\n        val instanceof edgedb_1.RelativeDuration ||\n        val instanceof edgedb_1.DateDuration) {\n        stringRep = `'${val.toString()}'`;\n    }\n    else if (val instanceof Buffer) {\n        stringRep = bufferToStringRep(val);\n        skipCast = true;\n    }\n    else if (val instanceof edgedb_1.Range) {\n        const elType = type.__element__;\n        const elTypeName = elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n        return `std::range(${val.lower === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.lower)}, ${val.upper === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.upper)}, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n    }\n    else if (typeof val === \"object\") {\n        if ((0, index_1.isNamedTupleType)(type)) {\n            stringRep = `( ${Object.entries(val).map(([key, value]) => `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`)} )`;\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else {\n        throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n    }\n    if (skipCast) {\n        return stringRep;\n    }\n    return `<${type.__name__}>${stringRep}`;\n}\nfunction indent(str, depth) {\n    return str\n        .split(\"\\n\")\n        .map(line => \" \".repeat(depth) + line)\n        .join(\"\\n\");\n}\nfunction q(ident, allowBacklinks = true) {\n    if (!ident ||\n        ident.startsWith(\"@\") ||\n        (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))) {\n        return ident;\n    }\n    const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n    if (isAlphaNum) {\n        const lident = ident.toLowerCase();\n        const isReserved = lident !== \"__type__\" &&\n            lident !== \"__std__\" &&\n            reservedKeywords_1.reservedKeywords.includes(lident);\n        if (!isReserved) {\n            return ident;\n        }\n    }\n    return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\nfunction bufferToStringRep(buf) {\n    let stringRep = \"\";\n    for (const byte of buf) {\n        if (byte < 32 || byte > 126) {\n            switch (byte) {\n                case 8:\n                    stringRep += \"\\\\b\";\n                    break;\n                case 9:\n                    stringRep += \"\\\\t\";\n                    break;\n                case 10:\n                    stringRep += \"\\\\n\";\n                    break;\n                case 12:\n                    stringRep += \"\\\\f\";\n                    break;\n                case 13:\n                    stringRep += \"\\\\r\";\n                    break;\n                default:\n                    stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n            }\n        }\n        else {\n            stringRep +=\n                (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n        }\n    }\n    return `b'${stringRep}'`;\n}\nfunction getErrorHint(expr) {\n    let literalConstructor = null;\n    switch (typeof expr) {\n        case \"string\":\n            literalConstructor = \"e.str()\";\n            break;\n        case \"number\":\n            literalConstructor = Number.isInteger(expr)\n                ? \"e.int64()\"\n                : \"e.float64()\";\n            break;\n        case \"bigint\":\n            literalConstructor = \"e.bigint()\";\n            break;\n        case \"boolean\":\n            literalConstructor = \"e.bool()\";\n            break;\n    }\n    switch (true) {\n        case expr instanceof Date:\n            literalConstructor = \"e.datetime()\";\n            break;\n        case expr instanceof edgedb_1.Duration:\n            literalConstructor = \"e.duration()\";\n            break;\n        case expr instanceof edgedb_1.LocalDate:\n            literalConstructor = \"e.cal.local_date()\";\n            break;\n        case expr instanceof edgedb_1.LocalDateTime:\n            literalConstructor = \"e.cal.local_datetime()\";\n            break;\n        case expr instanceof edgedb_1.LocalTime:\n            literalConstructor = \"e.cal.local_time()\";\n            break;\n        case expr instanceof edgedb_1.RelativeDuration:\n            literalConstructor = \"e.cal.relative_duration()\";\n            break;\n        case expr instanceof edgedb_1.DateDuration:\n            literalConstructor = \"e.cal.date_duration()\";\n            break;\n    }\n    return literalConstructor\n        ? `\\nHint: Maybe you meant to wrap the value in ` +\n            `a '${literalConstructor}' expression?`\n        : \"\";\n}\n"},{"path":"update.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.update = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nconst select_1 = require(\"./select\");\nconst insert_1 = require(\"./insert\");\nfunction update(expr, shape) {\n    const cleanScopedExprs = select_1.$existingScopes.size === 0;\n    const scope = (0, path_1.$getScopedExpr)(expr, select_1.$existingScopes);\n    const resolvedShape = shape(scope);\n    if (cleanScopedExprs) {\n        select_1.$existingScopes.clear();\n    }\n    const mods = {};\n    let updateShape;\n    for (const [key, val] of Object.entries(resolvedShape)) {\n        if (key === \"filter\") {\n            mods[key] = val;\n        }\n        else if (key === \"set\") {\n            updateShape = val;\n        }\n        else {\n            throw new Error(`Invalid update shape key '${key}', only 'filter', ` +\n                `and 'set' are allowed`);\n        }\n    }\n    if (!updateShape) {\n        throw new Error(`Update shape must contain 'set' shape`);\n    }\n    const { modifiers, cardinality } = (0, select_1.$handleModifiers)(mods, expr);\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Update,\n        __element__: expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __shape__: (0, insert_1.$normaliseInsertShape)(expr, updateShape, true),\n        __modifiers__: modifiers,\n        __scope__: scope,\n    });\n}\nexports.update = update;\n"},{"path":"with.js","content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.with = exports.alias = void 0;\nconst index_1 = require(\"edgedb/dist/reflection/index.js\");\nconst path_1 = require(\"./path\");\nfunction alias(expr) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.Alias,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n    });\n}\nexports.alias = alias;\nfunction _with(refs, expr) {\n    return (0, path_1.$expressionify)({\n        __kind__: index_1.ExpressionKind.With,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __refs__: refs,\n        __expr__: expr,\n    });\n}\nexports.with = _with;\n"},{"path":"cast.d.ts","content":"import { Expression, ExpressionKind, BaseType, TypeSet, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { orScalarLiteral } from \"../castMaps\";\nexport declare function cast<Target extends BaseType>(target: Target, arg: null): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Expr>;\nexport declare type $expr_Cast<Target extends BaseType = BaseType, Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Target;\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Cast;\n    __expr__: Expr | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, cardinalityUtil, Cardinality, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType } from \"edgedb/dist/reflection/index\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"../castMaps\";\nexport declare type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ndeclare type assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport declare type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport declare type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardinalityUtil.assignable<Set[\"__cardinality__\"]>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardinalityUtil.assignable<cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ndeclare type getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ndeclare type castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport declare type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardinalityUtil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"collections.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, cardinalityUtil, ExpressionRoot, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, TupleType, TypeSet, typeutil } from \"edgedb/dist/reflection/index\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral, scalarLiterals } from \"../castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardinalityUtil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport type { ArrayType as $Array, NamedTupleType as $NamedTuple, TupleType as $Tuple, } from \"edgedb/dist/reflection/index\";\n"},{"path":"detached.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport declare type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: Expr;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Expression, BaseType, BaseTypeSet, Cardinality, ExpressionKind, cardinalityUtil } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_For<IterSet extends BaseTypeSet = BaseTypeSet, Expr extends Expression = Expression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: cardinalityUtil.multiplyCardinalities<IterSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>;\n    __kind__: ExpressionKind.For;\n    __iterSet__: IterSet;\n    __forVar__: $expr_ForVar;\n    __expr__: Expr;\n}>;\nexport declare type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<IteratorSet, Expr>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { BaseType, BaseTypeSet, Cardinality, introspect } from \"edgedb/dist/reflection/index\";\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { Expression, ExpressionKind, BaseType, Cardinality } from \"edgedb/dist/reflection/index\";\nexport declare function makeGlobal<Name extends string, Type extends BaseType, Card extends Cardinality>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card>;\nexport declare type $expr_Global<Name extends string = string, Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: Name;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"edgedb/dist/reflection/index\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"../modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ndeclare type SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ndeclare type SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ndeclare type GroupModifiers = {\n    by: SimpleGroupElements;\n};\ndeclare type NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport declare type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport declare type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: Expr;\n    __scope__: ObjectTypeSet;\n}>;\ndeclare type noUndefined<T> = T extends undefined ? never : T;\ndeclare type groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"insert.d.ts","content":"import { Cardinality, Expression, ExpressionKind, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, typeutil, $scopify, stripSet, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"edgedb/dist/reflection/path\";\nimport type { $Object } from \"../modules/std\";\nimport type { scalarLiterals } from \"../castMaps\";\nexport declare type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport declare type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<RawInsertShape<Root>>;\nexport declare type RawInsertShape<Root extends ObjectTypeSet> = $expr_PathNode extends Root ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ndeclare type InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport declare type $expr_Insert<Root extends $expr_PathNode = $expr_PathNode> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: Root;\n    __shape__: InsertShape<Root>;\n    unlessConflict(): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, Conflict>;\n}>;\nexport declare type $expr_InsertUnlessConflict<Root extends InsertBaseExpression = InsertBaseExpression, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"] ? Root[\"__element__\"] : $Object : Root[\"__element__\"];\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: Root;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root>): $expr_Insert<Root>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import { BaseType, BaseTypeToTsType, ScalarType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { Expression, ExpressionKind, ParamType, Cardinality, setToTsType, TypeSet, BaseTypeToTsType } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport declare type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport declare type $expr_WithParams<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ndeclare type paramsToParamArgs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key]>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null> : never;\n};\nexport declare type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ndeclare type paramsToParamExprs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ObjectTypeSet, TypeSet, Expression } from \"edgedb/dist/reflection/index\";\nimport type { PathParent, $expr_PathLeaf, $expr_PathNode, $pathify, ExpressionRoot } from \"edgedb/dist/reflection/path\";\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent, Exclusive>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent, Exclusive>;\ndeclare function _$pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { _$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport { RangeType, $expr_Literal, getPrimitiveBaseType, TypeSet, $expr_Function, cardinalityUtil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"../modules/std\";\nimport type { $local_date, $local_datetime } from \"../modules/cal\";\nimport type { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral } from \"../castMaps\";\ndeclare type $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, mapLiteralToTypeSet<NamedArgs>, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, {}, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>>>;\nexport { range as $range };\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"../modules/std\";\nimport { $expr_PolyShapeElement, $scopify, Cardinality, cardinalityUtil, Expression, ExpressionKind, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, typeutil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_PathLeaf, $expr_PathNode, $linkPropify, ExpressionRoot, PathParent } from \"edgedb/dist/reflection/path\";\nimport type { anonymizeObject } from \"./casting\";\nimport type { $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport { scalarLiterals, literalToScalarType } from \"../castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport declare type OrderByDirection = \"ASC\" | \"DESC\";\nexport declare type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport declare type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport declare type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport declare type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport declare type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport declare type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\nexport declare type SelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport declare type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport declare type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n};\nexport declare type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\ndeclare type argCardToResultCard<OpCard extends Cardinality, BaseCase extends Cardinality> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One] ? Cardinality.AtMostOne : [OpCard] extends [Cardinality.Empty] ? Cardinality.Empty : BaseCase;\nexport declare type InferFilterCardinality<Base extends TypeSet, Filter> = Filter extends TypeSet ? Base extends ObjectTypeSet ? Filter extends $expr_Operator<\"=\", any, infer Args, any> ? Args[0] extends $expr_PathLeaf ? Args[0][\"__exclusive__\"] extends true ? typeutil.assertEqual<Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Args[0] extends $expr_PathNode<any, any, any> ? Args[0][\"__exclusive__\"] extends true ? Args[0][\"__parent__\"] extends null ? typeutil.assertEqual<Args[0][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Args[0][\"__parent__\"] extends infer Parent ? Parent extends PathParent ? typeutil.assertEqual<Parent[\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"];\nexport declare type InferOffsetLimitCardinality<Card extends Cardinality, Modifers extends UnknownSelectModifiers> = Modifers[\"limit\"] extends number | LimitExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Modifers[\"offset\"] extends number | OffsetExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport declare type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<InferFilterCardinality<Expr, Modifiers[\"filter\"]>, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, rootExpr: TypeSet): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n};\nexport declare type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport declare type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>, {\n        type: $scopify<Desc[\"target\"]>;\n        linkName: k;\n    }, Desc[\"properties\"][k][\"exclusive\"]>;\n};\nexport declare type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, {}>;\ndeclare type linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\nexport declare type linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardinalityUtil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\nexport declare type objectTypeToSelectShape<T extends ObjectType = ObjectType> = Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc ? boolean | TypeSet<T[\"__pointers__\"][k][\"target\"], cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>> : T[\"__pointers__\"][k] extends LinkDesc ? linkDescToSelectElement<T[\"__pointers__\"][k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport declare type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport declare type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>, true>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers>(expr: Expr, _shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Expr[\"__element__\"][\"__shape__\"]>;\n    __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Omit<normaliseShape<Shape>, SelectModifierNames>>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ExpressionKind, mergeObjectTypes, ObjectType, Cardinality, getPrimitiveBaseType, SomeType } from \"edgedb/dist/reflection/index\";\nimport * as castMaps from \"../castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport declare type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: Expression<Set>[];\n    __kind__: ExpressionKind.Set;\n}>;\ndeclare type mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport declare type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ndeclare type _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport declare type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport declare type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ndeclare type _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport declare type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport declare type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport declare type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport declare type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, $expr_TuplePath } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"edgedb/dist/reflection/path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport declare type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"update.d.ts","content":"import { Expression, ExpressionKind, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, typeutil, ObjectTypeExpression, $scopify, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { SelectModifiers, NormalisedSelectModifiers, ComputeSelectCardinality } from \"./select\";\nimport { pointerIsOptional } from \"./insert\";\nexport declare type $expr_Update<Set extends TypeSet = TypeSet, Expr extends ObjectTypeSet = ObjectTypeSet, Shape extends UpdateShape<Expr> = any> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: Expr;\n    __shape__: Shape;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport declare type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n}, Expr, Shape[\"set\"]>;\n"},{"path":"with.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport declare type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Alias;\n    __expr__: Expr;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr>;\nexport declare type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport declare type $expr_With<Refs extends TypeSet[] = TypeSet[], Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: Refs;\n}>;\ndeclare function _with<Refs extends Expression[], Expr extends WithableExpression>(refs: Refs, expr: Expr): $expr_With<Refs, Expr>;\nexport { _with as with };\n"}],"esm":[{"path":"cast.mjs","content":"import { ExpressionKind, Cardinality, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nimport { literalToTypeSet } from \"../castMaps.mjs\";\nexport function cast(target, expr) {\n    const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\n    return $expressionify({\n        __element__: target,\n        __cardinality__: cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\n        __expr__: cleanedExpr,\n        __kind__: ExpressionKind.Cast,\n    });\n}\n"},{"path":"casting.mjs","content":"export {};\n"},{"path":"collections.mjs","content":"import { Cardinality, cardinalityUtil, ExpressionKind, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nimport { literalToTypeSet, } from \"../castMaps.mjs\";\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\nconst arrayLikeProxyHandlers = {\n    get(target, prop, proxy) {\n        var _a;\n        const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n        if (match) {\n            const start = match[1];\n            const end = (_a = match[3]) !== null && _a !== void 0 ? _a : match[4];\n            const isIndex = start && !match[2];\n            return $expressionify({\n                __kind__: ExpressionKind.Operator,\n                __element__: target.__element__.__kind__ === TypeKind.array && isIndex\n                    ? target.__element__.__element__\n                    : target.__element__,\n                __cardinality__: target.__cardinality__,\n                __name__: \"[]\",\n                __opkind__: \"Infix\",\n                __args__: [\n                    proxy,\n                    isIndex\n                        ? literalToTypeSet(Number(start))\n                        : [\n                            start && literalToTypeSet(Number(start)),\n                            end && literalToTypeSet(Number(end)),\n                        ],\n                ],\n            });\n        }\n        return target[prop];\n    },\n};\nfunction arrayLikeIndex(index) {\n    const indexTypeSet = literalToTypeSet(index);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__.__kind__ === TypeKind.array\n            ? this.__element__.__element__\n            : this.__element__,\n        __cardinality__: cardinalityUtil.multiplyCardinalities(this.__cardinality__, indexTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, indexTypeSet],\n    });\n}\nfunction arrayLikeSlice(start, end) {\n    var _a, _b;\n    const startTypeSet = start && literalToTypeSet(start);\n    const endTypeSet = end && literalToTypeSet(end);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardinalityUtil.multiplyCardinalities(cardinalityUtil.multiplyCardinalities(this.__cardinality__, (_a = startTypeSet === null || startTypeSet === void 0 ? void 0 : startTypeSet.__cardinality__) !== null && _a !== void 0 ? _a : Cardinality.One), (_b = endTypeSet === null || endTypeSet === void 0 ? void 0 : endTypeSet.__cardinality__) !== null && _b !== void 0 ? _b : Cardinality.One),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, [startTypeSet, endTypeSet]],\n    });\n}\nexport function $arrayLikeIndexify(_expr) {\n    if (_expr.__element__.__kind__ === TypeKind.array ||\n        (_expr.__element__.__kind__ === TypeKind.scalar &&\n            (_expr.__element__.__name__ === \"std::str\" ||\n                _expr.__element__.__name__ === \"std::bytes\"))) {\n        const expr = new Proxy(_expr, arrayLikeProxyHandlers);\n        expr.index = arrayLikeIndex.bind(expr);\n        expr.slice = arrayLikeSlice.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexport function array(arg) {\n    if (Array.isArray(arg)) {\n        const items = arg.map(a => literalToTypeSet(a));\n        return $expressionify({\n            __kind__: ExpressionKind.Array,\n            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(items.map(item => item.__cardinality__)),\n            __element__: {\n                __kind__: TypeKind.array,\n                __name__: `array<${items[0].__element__.__name__}>`,\n                __element__: items[0].__element__,\n            },\n            __items__: items,\n        });\n    }\n    if (arg.__kind__) {\n        return {\n            __kind__: TypeKind.array,\n            __name__: `array<${arg.__name__}>`,\n            __element__: arg,\n        };\n    }\n    throw new Error(\"Invalid array input.\");\n}\nconst tupleProxyHandlers = {\n    get(target, prop, proxy) {\n        const type = target.__element__;\n        const items = type.__kind__ === TypeKind.tuple\n            ? type.__items__\n            : type.__kind__ === TypeKind.namedtuple\n                ? type.__shape__\n                : null;\n        return (items === null || items === void 0 ? void 0 : items.hasOwnProperty(prop))\n            ? tuplePath(proxy, items[prop], prop)\n            : target[prop];\n    },\n};\nexport function $tuplePathify(expr) {\n    if (expr.__element__.__kind__ !== TypeKind.tuple &&\n        expr.__element__.__kind__ !== TypeKind.namedtuple) {\n        return expr;\n    }\n    return new Proxy(expr, tupleProxyHandlers);\n}\nfunction tuplePath(parent, itemType, index) {\n    return $expressionify({\n        __kind__: ExpressionKind.TuplePath,\n        __element__: itemType,\n        __cardinality__: parent.__cardinality__,\n        __parent__: parent,\n        __index__: index,\n    });\n}\nfunction makeTupleType(name, items) {\n    return {\n        __kind__: TypeKind.tuple,\n        __name__: name,\n        __items__: items,\n    };\n}\nconst typeKinds = new Set(Object.values(TypeKind));\nexport function tuple(input) {\n    if (Array.isArray(input)) {\n        if (input.every(item => typeKinds.has(item.__kind__))) {\n            const typeItems = input;\n            const typeName = `tuple<${typeItems\n                .map(item => item.__name__)\n                .join(\", \")}>`;\n            return makeTupleType(typeName, typeItems);\n        }\n        const items = input.map(item => literalToTypeSet(item));\n        const name = `tuple<${items\n            .map(item => item.__element__.__name__)\n            .join(\", \")}>`;\n        return $expressionify({\n            __kind__: ExpressionKind.Tuple,\n            __element__: makeTupleType(name, items.map(item => item.__element__)),\n            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(items.map(i => i.__cardinality__)),\n            __items__: items,\n        });\n    }\n    else {\n        if (Object.values(input).every((el) => typeKinds.has(el.__kind__))) {\n            const typeName = `tuple<${Object.entries(input)\n                .map(([key, val]) => `${key}: ${val.__name__}`)\n                .join(\", \")}>`;\n            return {\n                __kind__: TypeKind.namedtuple,\n                __name__: typeName,\n                __shape__: input,\n            };\n        }\n        const exprShape = {};\n        const typeShape = {};\n        for (const [key, val] of Object.entries(input)) {\n            exprShape[key] = literalToTypeSet(val);\n            typeShape[key] = exprShape[key].__element__;\n        }\n        const name = `tuple<${Object.entries(exprShape)\n            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n            .join(\", \")}>`;\n        return $expressionify({\n            __kind__: ExpressionKind.NamedTuple,\n            __element__: {\n                __kind__: TypeKind.namedtuple,\n                __name__: name,\n                __shape__: typeShape,\n            },\n            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(Object.values(exprShape).map(val => val.__cardinality__)),\n            __shape__: exprShape,\n        });\n    }\n}\n"},{"path":"detached.mjs","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function detached(expr) {\n    return $expressionify({\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n        __kind__: ExpressionKind.Detached,\n    });\n}\n"},{"path":"external.mjs","content":"export { literal } from \"./literal.mjs\";\nexport { set } from \"./set.mjs\";\nexport { cast } from \"./cast.mjs\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select.mjs\";\nexport { update } from \"./update.mjs\";\nexport { insert } from \"./insert.mjs\";\nexport { array, tuple } from \"./collections.mjs\";\nexport { for } from \"./for.mjs\";\nexport { alias, with } from \"./with.mjs\";\nexport { optional, params } from \"./params.mjs\";\nexport { detached } from \"./detached.mjs\";\n"},{"path":"for.mjs","content":"import { Cardinality, ExpressionKind, cardinalityUtil, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nfunction _for(set, expr) {\n    const forVar = $expressionify({\n        __kind__: ExpressionKind.ForVar,\n        __element__: set.__element__,\n        __cardinality__: Cardinality.One,\n    });\n    const returnExpr = expr(forVar);\n    return $expressionify({\n        __kind__: ExpressionKind.For,\n        __element__: returnExpr.__element__,\n        __cardinality__: cardinalityUtil.multiplyCardinalities(set.__cardinality__, returnExpr.__cardinality__),\n        __iterSet__: set,\n        __expr__: returnExpr,\n        __forVar__: forVar,\n    });\n}\nexport { _for as for };\n"},{"path":"funcops.mjs","content":"import { Cardinality, makeType, TypeKind, cardinalityUtil, } from \"edgedb/dist/reflection/index.js\";\nimport { cast } from \"./cast.mjs\";\nimport { isImplicitlyCastableTo, literalToTypeSet } from \"../castMaps.mjs\";\nimport { literal } from \"./literal.mjs\";\nfunction mapLiteralToTypeSet(literals) {\n    if (Array.isArray(literals)) {\n        return literals.map(lit => (lit != null ? literalToTypeSet(lit) : lit));\n    }\n    const obj = {};\n    for (const key of Object.keys(literals)) {\n        obj[key] =\n            literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\n    }\n    return obj;\n}\nexport function $resolveOverload(funcName, args, typeSpec, funcDefs) {\n    const positionalArgs = [];\n    let namedArgs;\n    if (args.length) {\n        if (args[0] !== undefined) {\n            try {\n                positionalArgs.push(literalToTypeSet(args[0]));\n            }\n            catch {\n                namedArgs = mapLiteralToTypeSet(args[0]);\n            }\n        }\n        else {\n            positionalArgs.push(undefined);\n        }\n        positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n    }\n    for (const def of funcDefs) {\n        const resolvedOverload = _tryOverload(funcName, positionalArgs, namedArgs, typeSpec, def);\n        if (resolvedOverload !== null) {\n            return resolvedOverload;\n        }\n    }\n    throw new Error(`No function overload found for ${funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\")[1]}()'`\n        : `operator '${funcName}'`} with args: ${args.map(arg => `${arg}`).join(\", \")}`);\n}\nconst ANYTYPE_ARG = Symbol();\nfunction _tryOverload(funcName, args, namedArgs, typeSpec, funcDef) {\n    var _a, _b;\n    if ((funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n        (namedArgs === undefined &&\n            funcDef.namedArgs &&\n            Object.values(funcDef.namedArgs).some(arg => !arg.optional))) {\n        return null;\n    }\n    const lastParamVariadic = (_a = funcDef.args[funcDef.args.length - 1]) === null || _a === void 0 ? void 0 : _a.variadic;\n    if (!lastParamVariadic && args.length > funcDef.args.length) {\n        return null;\n    }\n    const paramCardinalities = [\n        Cardinality.One,\n    ];\n    if (namedArgs) {\n        for (const [key, value] of Object.entries(namedArgs)) {\n            const argDef = (_b = funcDef.namedArgs) === null || _b === void 0 ? void 0 : _b[key];\n            if (!argDef ||\n                !compareType(typeSpec, argDef.typeId, value.__element__).match) {\n                return null;\n            }\n            paramCardinalities.push(argDef.setoftype\n                ? funcDef.preservesOptionality\n                    ? cardinalityUtil.overrideUpperBound(value.__cardinality__, \"One\")\n                    : Cardinality.One\n                : argDef.optional\n                    ? cardinalityUtil.overrideLowerBound(value.__cardinality__, \"One\")\n                    : value.__cardinality__);\n        }\n    }\n    let positionalArgs = [];\n    let returnAnytype;\n    let needsAnytypeReplacement = false;\n    for (let i = 0; i < funcDef.args.length; i++) {\n        const argDef = funcDef.args[i];\n        const arg = args[i];\n        if (arg === undefined) {\n            if (!argDef.optional) {\n                return null;\n            }\n            if (i < args.length) {\n                const argTypeName = typeSpec.get(argDef.typeId).name;\n                if (argTypeName.includes(\"anytype\") ||\n                    argTypeName.includes(\"std::anypoint\")) {\n                    if (!returnAnytype) {\n                        positionalArgs.push(ANYTYPE_ARG);\n                        needsAnytypeReplacement = true;\n                    }\n                    else {\n                        positionalArgs.push(cast(returnAnytype, null));\n                    }\n                }\n                else {\n                    const argType = makeType(typeSpec, argDef.typeId, literal);\n                    positionalArgs.push(cast(argType, null));\n                }\n            }\n        }\n        else {\n            const { match, anytype } = compareType(typeSpec, argDef.typeId, arg.__element__);\n            if (!match) {\n                return null;\n            }\n            if (!returnAnytype && anytype) {\n                returnAnytype = anytype;\n            }\n            positionalArgs.push(...(argDef.variadic ? args.slice(i) : [arg]));\n            if (argDef.setoftype) {\n                paramCardinalities.push(funcDef.preservesOptionality\n                    ? cardinalityUtil.overrideUpperBound(arg.__cardinality__, \"One\")\n                    : Cardinality.One);\n            }\n            else {\n                const card = argDef.variadic\n                    ? cardinalityUtil.multiplyCardinalitiesVariadic(args.slice(i).map(el => el.__cardinality__))\n                    : arg.__cardinality__;\n                paramCardinalities.push(argDef.optional\n                    ? cardinalityUtil.overrideLowerBound(card, \"One\")\n                    : card);\n            }\n        }\n    }\n    let cardinality;\n    if (funcName === \"if_else\") {\n        cardinality = cardinalityUtil.multiplyCardinalities(cardinalityUtil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[2].__cardinality__), positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"std::assert_exists\") {\n        cardinality = cardinalityUtil.overrideLowerBound(positionalArgs[0].__cardinality__, \"One\");\n    }\n    else if (funcName === \"union\") {\n        cardinality = cardinalityUtil.mergeCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"??\") {\n        cardinality = cardinalityUtil.orCardinalities(positionalArgs[0].__cardinality__, positionalArgs[1].__cardinality__);\n    }\n    else if (funcName === \"distinct\") {\n        cardinality = positionalArgs[0].__cardinality__;\n    }\n    else {\n        cardinality =\n            funcDef.returnTypemod === \"SetOfType\"\n                ? Cardinality.Many\n                : cardinalityUtil.multiplyCardinalitiesVariadic(paramCardinalities);\n        if (funcDef.returnTypemod === \"OptionalType\" &&\n            !funcDef.preservesOptionality) {\n            cardinality = cardinalityUtil.overrideLowerBound(cardinality, \"Zero\");\n        }\n    }\n    if (needsAnytypeReplacement) {\n        if (!returnAnytype) {\n            throw new Error(`could not resolve anytype for ${funcName}`);\n        }\n        positionalArgs = positionalArgs.map(arg => arg === ANYTYPE_ARG ? cast(returnAnytype, null) : arg);\n    }\n    return {\n        kind: funcDef.kind,\n        returnType: makeType(typeSpec, funcDef.returnTypeId, literal, returnAnytype),\n        cardinality,\n        args: positionalArgs,\n        namedArgs: namedArgs !== null && namedArgs !== void 0 ? namedArgs : {},\n    };\n}\nconst nameRemapping = {\n    \"std::int16\": \"std::number\",\n    \"std::int32\": \"std::number\",\n    \"std::int64\": \"std::number\",\n    \"std::float32\": \"std::number\",\n    \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map();\nfunction getDescendantNames(typeSpec, typeId) {\n    if (descendantCache.has(typeId)) {\n        return descendantCache.get(typeId);\n    }\n    const descendants = [\n        ...new Set([...typeSpec.values()]\n            .filter(type => type.kind === \"scalar\" && type.bases.some(({ id }) => id === typeId))\n            .flatMap(type => type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name])),\n    ];\n    descendantCache.set(typeId, descendants);\n    return descendants;\n}\nfunction compareType(typeSpec, typeId, arg) {\n    var _a;\n    const type = typeSpec.get(typeId);\n    if (type.name === \"anytype\") {\n        return { match: true, anytype: arg };\n    }\n    if (type.name === \"std::anypoint\") {\n        const descendants = getDescendantNames(typeSpec, typeId);\n        if (descendants.includes(arg.__name__)) {\n            return { match: true, anytype: arg };\n        }\n    }\n    if (type.name === \"std::anyenum\") {\n        return { match: arg.__kind__ === TypeKind.enum };\n    }\n    if (type.kind === \"scalar\") {\n        arg = (_a = arg.__casttype__) !== null && _a !== void 0 ? _a : arg;\n        return {\n            match: (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\n                (arg.__name__ === type.name ||\n                    isImplicitlyCastableTo(arg.__name__, type.name)),\n        };\n    }\n    if (type.kind === \"array\") {\n        if (arg.__kind__ === TypeKind.array) {\n            return compareType(typeSpec, type.array_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"range\") {\n        if (arg.__kind__ === TypeKind.range) {\n            return compareType(typeSpec, type.range_element_id, arg.__element__);\n        }\n    }\n    if (type.kind === \"object\") {\n        if (arg.__kind__ !== TypeKind.object)\n            return { match: false };\n        const objectArg = arg;\n        let match = true;\n        for (const ptr of type.pointers) {\n            if (objectArg.__pointers__[ptr.name]) {\n                const argPtr = objectArg.__pointers__[ptr.name];\n                const ptrTarget = typeSpec.get(ptr.target_id);\n                if (ptrTarget.name !== argPtr.target.__name__ ||\n                    ptr.real_cardinality !== argPtr.cardinality) {\n                    match = false;\n                }\n            }\n        }\n        return {\n            match,\n        };\n    }\n    if (type.kind === \"tuple\") {\n        const items = arg.__kind__ === TypeKind.tuple\n            ? arg.__items__\n            : arg.__kind__ === TypeKind.namedtuple\n                ? arg.__shape__\n                : null;\n        if (items) {\n            const keys = Object.keys(items);\n            if (keys.length === type.tuple_elements.length) {\n                let anytype;\n                for (let i = 0; i < keys.length; i++) {\n                    if (keys[i] !== type.tuple_elements[i].name) {\n                        return { match: false };\n                    }\n                    const { match: m, anytype: a } = compareType(typeSpec, type.tuple_elements[i].target_id, items[keys[i]]);\n                    if (!m) {\n                        return { match: false };\n                    }\n                    if (a)\n                        anytype = a;\n                }\n                return { match: true, anytype };\n            }\n        }\n    }\n    return { match: false };\n}\n"},{"path":"globals.mjs","content":"import { ExpressionKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function makeGlobal(name, type, card) {\n    return $expressionify({\n        __name__: name,\n        __element__: type,\n        __cardinality__: card,\n        __kind__: ExpressionKind.Global,\n    });\n}\n"},{"path":"group.mjs","content":"import { Cardinality, ExpressionKind, TypeKind, makeType, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { spec } from \"../__spec__.mjs\";\nimport { literal } from \"./literal.mjs\";\nimport { resolveShapeElement } from \"./select.mjs\";\nexport function isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nconst makeGroupingSet = (prefix) => (grps) => {\n    const seenKeys = new Map();\n    const unfiltered = Object.entries(grps).flatMap(([k, grp]) => isGroupingSet(grp)\n        ? grp.__exprs__\n        : [[k, grp]]);\n    const filtered = unfiltered.filter(([k, expr]) => {\n        if (!seenKeys.has(k)) {\n            seenKeys.set(k, expr);\n            return true;\n        }\n        if (expr !== seenKeys.get(k)) {\n            throw new Error(`Cannot override pre-existing expression with key \"${k}\"`);\n        }\n        return false;\n    });\n    return {\n        [`${Math.round(1000000 * Math.random())}___`]: {\n            __kind__: \"groupingset\",\n            __settype__: prefix,\n            __elements__: grps,\n            __exprs__: filtered,\n        },\n    };\n};\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\nconst setFuncs = { set, tuple, rollup, cube };\nconst groupFunc = (expr, getter) => {\n    const { shape, scope, modifiers } = resolveShape(getter, expr);\n    const groupSet = tuple(modifiers.by);\n    const key = Object.keys(groupSet)[0];\n    const grouping = groupSet[key];\n    const keyShape = {};\n    const keyPointers = {};\n    const keyShapeElement = {};\n    for (const [k, e] of grouping.__exprs__) {\n        keyShape[k] = $expressionify({\n            __element__: e.__element__,\n            __cardinality__: Cardinality.AtMostOne,\n        });\n        keyPointers[k] = {\n            __kind__: \"property\",\n            target: e.__element__,\n            cardinality: Cardinality.AtMostOne,\n            exclusive: false,\n            computed: false,\n            readonly: false,\n            hasDefault: false,\n        };\n        keyShapeElement[k] = true;\n    }\n    const $FreeObject = makeType(spec, [...spec.values()].find(s => s.name === \"std::FreeObject\").id, literal);\n    const str = makeType(spec, [...spec.values()].find(s => s.name === \"std::str\").id, literal);\n    return $expressionify({\n        __element__: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n                ...$FreeObject.__pointers__,\n                __name__: \"std::FreeObject\",\n                grouping: {\n                    __kind__: \"property\",\n                    target: str,\n                    cardinality: Cardinality.Many,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                key: {\n                    __kind__: \"link\",\n                    target: {\n                        ...$FreeObject,\n                        __name__: \"std::FreeObject\",\n                        __pointers__: {\n                            ...$FreeObject.__pointers__,\n                            ...keyPointers,\n                        },\n                        __shape__: keyShape,\n                    },\n                    properties: {},\n                    cardinality: Cardinality.One,\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n                elements: {\n                    __kind__: \"link\",\n                    target: expr.__element__,\n                    cardinality: Cardinality.Many,\n                    properties: {},\n                    exclusive: false,\n                    computed: false,\n                    readonly: false,\n                    hasDefault: false,\n                },\n            },\n            __shape__: {\n                grouping: $expressionify({\n                    __element__: str,\n                    __cardinality__: Cardinality.Many,\n                }),\n                key: $expressionify({\n                    __element__: {\n                        ...$FreeObject,\n                        __shape__: keyShape,\n                    },\n                    __cardinality__: Cardinality.One,\n                }),\n                elements: $expressionify({\n                    __element__: { ...expr.__element__, __shape__: shape },\n                    __cardinality__: Cardinality.Many,\n                }),\n            },\n        },\n        __cardinality__: Cardinality.Many,\n        __expr__: expr,\n        __modifiers__: { by: grouping },\n        __kind__: ExpressionKind.Group,\n        __scope__: scope,\n    });\n};\nObject.assign(groupFunc, setFuncs);\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = $getScopedExpr(expr);\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"by\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    if (Object.keys(shape).length === 0) {\n        shape.id = true;\n    }\n    if (!modifiers.by) {\n        throw new Error(\"Must provide a `by` key in `e.group`\");\n    }\n    return { shape, modifiers, scope };\n}\nexport const group = groupFunc;\n"},{"path":"insert.mjs","content":"import { Cardinality, ExpressionKind, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { cast } from \"./cast.mjs\";\nimport { set } from \"./set.mjs\";\nimport { literal } from \"./literal.mjs\";\nimport { $getTypeByName } from \"./literal.mjs\";\nfunction unlessConflict(conflictGetter) {\n    const expr = {\n        __kind__: ExpressionKind.InsertUnlessConflict,\n        __element__: this.__element__,\n        __cardinality__: Cardinality.AtMostOne,\n        __expr__: this,\n    };\n    if (!conflictGetter) {\n        expr.__conflict__ = { on: null };\n        return $expressionify(expr);\n    }\n    else {\n        const scopedExpr = $getScopedExpr(this.__expr__);\n        const conflict = conflictGetter(scopedExpr);\n        expr.__conflict__ = conflict;\n        if (conflict.else) {\n            expr.__cardinality__ = conflict.else.__cardinality__;\n            if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n                expr.__element__ = $getTypeByName(\"std::Object\");\n            }\n        }\n        return $expressionify(expr);\n    }\n}\nexport function $insertify(expr) {\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return expr;\n}\nexport function $normaliseInsertShape(root, shape, isUpdate = false) {\n    const newShape = {};\n    for (const [key, _val] of Object.entries(shape)) {\n        let val = _val;\n        let setModify = null;\n        if (isUpdate && _val != null && typeof _val === \"object\") {\n            const valKeys = Object.keys(_val);\n            if (valKeys.length === 1 &&\n                (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")) {\n                val = _val[valKeys[0]];\n                setModify = valKeys[0];\n            }\n        }\n        const pointer = root.__element__.__pointers__[key];\n        const isLinkProp = key[0] === \"@\";\n        if (!pointer && !isLinkProp) {\n            throw new Error(`Could not find property pointer for ${isUpdate ? \"update\" : \"insert\"} shape key: '${key}'`);\n        }\n        if (val === undefined)\n            continue;\n        if (val === null || val === void 0 ? void 0 : val.__kind__) {\n            if (val.__kind__ === ExpressionKind.Literal &&\n                val.__element__.__kind__ === TypeKind.range &&\n                val.__element__.__element__.__name__ === \"std::number\") {\n                newShape[key] = literal(pointer.target, val.__value__);\n            }\n            else {\n                newShape[key] = _val;\n            }\n            continue;\n        }\n        if (isLinkProp) {\n            throw new Error(`Cannot assign plain data to link property '${key}'. Provide an expression instead.`);\n        }\n        if (pointer.__kind__ !== \"property\" && val !== null) {\n            throw new Error(`Must provide subquery when assigning to link '${key}' in ${isUpdate ? \"update\" : \"insert\"} query.`);\n        }\n        const isMulti = pointer.cardinality === Cardinality.AtLeastOne ||\n            pointer.cardinality === Cardinality.Many;\n        if (pointer.__kind__ === \"property\") {\n            if (pointer.target.__name__ === \"std::json\") {\n            }\n        }\n        const wrappedVal = val === null\n            ? cast(pointer.target, null)\n            : isMulti && Array.isArray(val)\n                ? val.length === 0\n                    ? cast(pointer.target, null)\n                    : set(...val.map(v => literal(pointer.target, v)))\n                : literal(pointer.target, val);\n        newShape[key] = setModify\n            ? { [setModify]: wrappedVal }\n            : wrappedVal;\n    }\n    return newShape;\n}\nexport function insert(root, shape) {\n    if (typeof shape !== \"object\") {\n        throw new Error(`invalid insert shape.${typeof shape === \"function\"\n            ? \" Hint: Insert shape is expected to be an object, \" +\n                \"not a function returning a shape object.\"\n            : \"\"}`);\n    }\n    const expr = {\n        __kind__: ExpressionKind.Insert,\n        __element__: root.__element__,\n        __cardinality__: Cardinality.One,\n        __expr__: root,\n        __shape__: $normaliseInsertShape(root, shape),\n    };\n    expr.unlessConflict = unlessConflict.bind(expr);\n    return $expressionify($insertify(expr));\n}\n"},{"path":"json.mjs","content":"import { ExpressionKind, TypeKind } from \"edgedb/dist/reflection/index.js\";\nfunction jsonStringify(type, val) {\n    if (type.__kind__ === TypeKind.array) {\n        if (Array.isArray(val)) {\n            return `[${val\n                .map(item => jsonStringify(type.__element__, item))\n                .join()}]`;\n        }\n        throw new Error(`Param with array type is not an array`);\n    }\n    if (type.__kind__ === TypeKind.tuple) {\n        if (!Array.isArray(val)) {\n            throw new Error(`Param with tuple type is not an array`);\n        }\n        if (val.length !== type.__items__.length) {\n            throw new Error(`Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`);\n        }\n        return `[${val\n            .map((item, i) => jsonStringify(type.__items__[i], item))\n            .join()}]`;\n    }\n    if (type.__kind__ === TypeKind.namedtuple) {\n        if (typeof val !== \"object\") {\n            throw new Error(`Param with named tuple type is not an object`);\n        }\n        if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n            throw new Error(`Param with named tuple type has incorrect number of items. Got ${Object.keys(val).length} expected ${Object.keys(type.__shape__).length}`);\n        }\n        return `{${Object.entries(val)\n            .map(([key, item]) => {\n            if (!type.__shape__[key]) {\n                throw new Error(`Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(type.__shape__).join()}`);\n            }\n            return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n        })\n            .join()}}`;\n    }\n    if (type.__kind__ === TypeKind.scalar) {\n        switch (type.__name__) {\n            case \"std::bigint\":\n                return val.toString();\n            case \"std::json\":\n                return JSON.stringify(val);\n            case \"std::bytes\":\n                return `\"${val.toString(\"base64\")}\"`;\n            case \"cfg::memory\":\n                return `\"${val.toString()}\"`;\n            default:\n                return JSON.stringify(val);\n        }\n    }\n    if (type.__kind__ === TypeKind.enum) {\n        return JSON.stringify(val);\n    }\n    throw new Error(`Invalid param type: ${type.__kind__}`);\n}\nexport function jsonifyComplexParams(expr, _args) {\n    if (_args && expr.__kind__ === ExpressionKind.WithParams) {\n        const args = { ..._args };\n        for (const param of expr.__params__) {\n            if (param.__isComplex__) {\n                args[param.__name__] = jsonStringify(param.__element__, args[param.__name__]);\n            }\n        }\n        return args;\n    }\n    return _args;\n}\n"},{"path":"literal.mjs","content":"import { Cardinality, ExpressionKind, makeType, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nimport { spec } from \"../__spec__.mjs\";\nexport function literal(type, value) {\n    return $expressionify({\n        __element__: type,\n        __cardinality__: Cardinality.One,\n        __kind__: ExpressionKind.Literal,\n        __value__: value,\n    });\n}\nexport const $nameMapping = new Map([\n    ...[...spec.values()].map(type => [type.name, type.id]),\n    [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\nexport function $getType(id) {\n    return makeType(spec, id, literal);\n}\nexport function $getTypeByName(name) {\n    return makeType(spec, $nameMapping.get(name), literal);\n}\n"},{"path":"params.mjs","content":"import { ExpressionKind, Cardinality, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function optional(type) {\n    return {\n        __kind__: ExpressionKind.OptionalParam,\n        __type__: type,\n    };\n}\nconst complexParamKinds = new Set([TypeKind.tuple, TypeKind.namedtuple]);\nexport function params(paramsDef, expr) {\n    const paramExprs = {};\n    for (const [key, param] of Object.entries(paramsDef)) {\n        const paramType = param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\n        const isComplex = complexParamKinds.has(paramType.__kind__) ||\n            (paramType.__kind__ === TypeKind.array &&\n                complexParamKinds.has(paramType.__element__.__kind__));\n        paramExprs[key] = $expressionify({\n            __kind__: ExpressionKind.Param,\n            __element__: paramType,\n            __cardinality__: param.__kind__ === ExpressionKind.OptionalParam\n                ? Cardinality.AtMostOne\n                : Cardinality.One,\n            __name__: key,\n            __isComplex__: isComplex,\n        });\n    }\n    const returnExpr = expr(paramExprs);\n    return $expressionify({\n        __kind__: ExpressionKind.WithParams,\n        __element__: returnExpr.__element__,\n        __cardinality__: returnExpr.__cardinality__,\n        __expr__: returnExpr,\n        __params__: Object.values(paramExprs),\n    });\n}\n"},{"path":"path.mjs","content":"import { cardinalityUtil, ExpressionKind, TypeKind, Cardinality, } from \"edgedb/dist/reflection/index.js\";\nimport { literalToTypeSet } from \"../castMaps.mjs\";\nimport { $arrayLikeIndexify, $tuplePathify } from \"./collections.mjs\";\nimport { $toEdgeQL } from \"./toEdgeQL.mjs\";\nimport { $queryFunc, $queryFuncJSON } from \"./query.mjs\";\nfunction PathLeaf(root, parent, exclusive, scopeRoot = null) {\n    return $expressionify({\n        __kind__: ExpressionKind.PathLeaf,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __exclusive__: exclusive,\n        __scopeRoot__: scopeRoot,\n    });\n}\nfunction PathNode(root, parent, exclusive, scopeRoot = null) {\n    const obj = {\n        __kind__: ExpressionKind.PathNode,\n        __element__: root.__element__,\n        __cardinality__: root.__cardinality__,\n        __parent__: parent,\n        __exclusive__: exclusive,\n        __scopeRoot__: scopeRoot,\n    };\n    const shape = {};\n    Object.entries(obj.__element__.__pointers__).map(([key, ptr]) => {\n        if (ptr.__kind__ === \"property\") {\n            shape[key] = true;\n        }\n    });\n    Object.defineProperty(obj, \"*\", {\n        writable: false,\n        value: shape,\n    });\n    return $expressionify(obj);\n}\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\nconst pathifyProxyHandlers = {\n    get(target, prop, proxy) {\n        var _a, _b, _c;\n        const ptr = target[_pointers][prop];\n        if (ptr) {\n            return ((_a = target[_pathCache][prop]) !== null && _a !== void 0 ? _a : (target[_pathCache][prop] = (ptr.__kind__ === \"property\" ? PathLeaf : PathNode)({\n                __element__: ptr.target,\n                __cardinality__: cardinalityUtil.multiplyCardinalities(target.__cardinality__, ptr.cardinality),\n            }, {\n                linkName: prop,\n                type: proxy,\n            }, (_b = ptr.exclusive) !== null && _b !== void 0 ? _b : false, (_c = target.__scopeRoot__) !== null && _c !== void 0 ? _c : (scopeRoots.has(proxy) ? proxy : null))));\n        }\n        return target[prop];\n    },\n};\nfunction _$pathify(_root) {\n    if (_root.__element__.__kind__ !== TypeKind.object) {\n        return _root;\n    }\n    const root = _root;\n    let pointers = {\n        ...root.__element__.__pointers__,\n    };\n    if (root.__parent__) {\n        const { type, linkName } = root.__parent__;\n        const parentPointer = type.__element__.__pointers__[linkName];\n        if ((parentPointer === null || parentPointer === void 0 ? void 0 : parentPointer.__kind__) === \"link\") {\n            pointers = { ...pointers, ...parentPointer.properties };\n        }\n    }\n    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {\n        if (pointers[key])\n            continue;\n        const valType = val === null || val === void 0 ? void 0 : val.__element__;\n        if (!valType)\n            continue;\n        pointers[key] = {\n            __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\n            properties: {},\n            target: val.__element__,\n            cardinality: val.__cardinality__,\n            exclusive: false,\n            computed: true,\n            readonly: true,\n            hasDefault: false,\n        };\n    }\n    root[_pointers] = pointers;\n    root[_pathCache] = {};\n    return new Proxy(root, pathifyProxyHandlers);\n}\nfunction isFunc(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.TypeIntersection,\n        __cardinality__: this.__cardinality__,\n        __element__: {\n            ...expr.__element__,\n            __shape__: { id: true },\n        },\n        __expr__: this,\n    });\n}\nfunction assert_single(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.Function,\n        __element__: expr.__element__,\n        __cardinality__: cardinalityUtil.overrideUpperBound(expr.__cardinality__, \"One\"),\n        __name__: \"std::assert_single\",\n        __args__: [expr],\n        __namedargs__: {},\n    });\n}\nconst jsonDestructureProxyHandlers = {\n    get(target, prop, proxy) {\n        if (typeof prop === \"string\" && !(prop in target)) {\n            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n            return jsonDestructure.call(proxy, parsedProp);\n        }\n        return target[prop];\n    },\n};\nfunction jsonDestructure(path) {\n    const pathTypeSet = literalToTypeSet(path);\n    return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__: this.__element__,\n        __cardinality__: cardinalityUtil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [this, pathTypeSet],\n    });\n}\nexport function $jsonDestructure(_expr) {\n    if (_expr.__element__.__kind__ === TypeKind.scalar &&\n        _expr.__element__.__name__ === \"std::json\") {\n        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);\n        expr.destructure = jsonDestructure.bind(expr);\n        return expr;\n    }\n    return _expr;\n}\nexport function $expressionify(_expr) {\n    const expr = _$pathify($jsonDestructure($arrayLikeIndexify($tuplePathify(_expr))));\n    expr.run = $queryFunc.bind(expr);\n    expr.runJSON = $queryFuncJSON.bind(expr);\n    expr.is = isFunc.bind(expr);\n    expr.toEdgeQL = $toEdgeQL.bind(expr);\n    expr.assert_single = () => assert_single(expr);\n    return Object.freeze(expr);\n}\nconst scopedExprCache = new WeakMap();\nconst scopeRoots = new WeakSet();\nexport function $getScopedExpr(expr, existingScopes) {\n    let scopedExpr = scopedExprCache.get(expr);\n    if (!scopedExpr || (existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.has(scopedExpr))) {\n        const isFreeObject = expr.__cardinality__ === Cardinality.One &&\n            expr.__element__.__name__ === \"std::FreeObject\";\n        const isInsert = expr.__kind__ === ExpressionKind.Insert;\n        scopedExpr =\n            isFreeObject || isInsert\n                ? expr\n                : $expressionify({\n                    ...expr,\n                    __cardinality__: Cardinality.One,\n                    __scopedFrom__: expr,\n                    \"*\": expr[\"*\"],\n                });\n        scopeRoots.add(scopedExpr);\n        const uncached = !scopedExpr;\n        if (uncached) {\n            scopedExprCache.set(expr, scopedExpr);\n        }\n    }\n    existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.add(scopedExpr);\n    return scopedExpr;\n}\nexport { _$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.mjs","content":"import { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { jsonifyComplexParams } from \"./json.mjs\";\nimport { select } from \"./select.mjs\";\nconst runnableExpressionKinds = new Set([\n    ExpressionKind.Select,\n    ExpressionKind.Update,\n    ExpressionKind.Insert,\n    ExpressionKind.InsertUnlessConflict,\n    ExpressionKind.Delete,\n    ExpressionKind.Group,\n    ExpressionKind.For,\n    ExpressionKind.With,\n    ExpressionKind.WithParams,\n]);\nconst wrappedExprCache = new WeakMap();\nexport async function $queryFunc(cxn, args) {\n    var _a;\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : (_a = wrappedExprCache.get(this)) !== null && _a !== void 0 ? _a : wrappedExprCache.set(this, select(this)).get(this);\n    const _args = jsonifyComplexParams(expr, args);\n    const query = expr.toEdgeQL();\n    if (expr.__cardinality__ === Cardinality.One ||\n        expr.__cardinality__ === Cardinality.AtMostOne ||\n        expr.__cardinality__ === Cardinality.Empty) {\n        return cxn.querySingle(query, _args);\n    }\n    else {\n        return cxn.query(query, _args);\n    }\n}\nexport async function $queryFuncJSON(cxn, args) {\n    var _a;\n    const expr = runnableExpressionKinds.has(this.__kind__)\n        ? this\n        : (_a = wrappedExprCache.get(this)) !== null && _a !== void 0 ? _a : wrappedExprCache.set(this, select(this)).get(this);\n    const _args = jsonifyComplexParams(expr, args);\n    if (expr.__cardinality__ === Cardinality.One ||\n        expr.__cardinality__ === Cardinality.AtMostOne) {\n        return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n    }\n    else {\n        return cxn.queryJSON(expr.toEdgeQL(), _args);\n    }\n}\n"},{"path":"range.mjs","content":"import { Range } from \"edgedb\";\nimport { TypeKind, ExpressionKind, } from \"edgedb/dist/reflection/index.js\";\nimport { literalToTypeSet } from \"../castMaps.mjs\";\nimport { spec } from \"../__spec__.mjs\";\nimport { literal, $nameMapping } from \"./literal.mjs\";\nimport { $resolveOverload } from \"./funcops.mjs\";\nimport { $expressionify } from \"./path.mjs\";\nfunction range(...args) {\n    var _a;\n    if (args.length === 1) {\n        const arg = args[0];\n        if (arg instanceof Range) {\n            if (arg.lower === null && arg.upper === null) {\n                throw new Error(`Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`);\n            }\n            if (arg.isEmpty) {\n                throw new Error(`Can't create literal expression from empty range.`);\n            }\n            return literal(range(literalToTypeSet((_a = arg.lower) !== null && _a !== void 0 ? _a : arg.upper).__element__), arg);\n        }\n        if (arg.__kind__ && !arg.__element__) {\n            return {\n                __kind__: TypeKind.range,\n                __name__: `range<${arg.__name__}>`,\n                __element__: arg,\n            };\n        }\n    }\n    const { returnType, cardinality, args: positionalArgs, namedArgs, } = $resolveOverload(\"std::range\", args, spec, [\n        {\n            args: [\n                {\n                    typeId: $nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                {\n                    typeId: $nameMapping.get(\"std::anypoint\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            ],\n            namedArgs: {\n                inc_lower: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                inc_upper: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n                empty: {\n                    typeId: $nameMapping.get(\"std::bool\"),\n                    optional: true,\n                    setoftype: false,\n                    variadic: false,\n                },\n            },\n            returnTypeId: $nameMapping.get(\"range<std::anypoint>\"),\n        },\n    ]);\n    return $expressionify({\n        __kind__: ExpressionKind.Function,\n        __element__: returnType,\n        __cardinality__: cardinality,\n        __name__: \"std::range\",\n        __args__: positionalArgs,\n        __namedargs__: namedArgs,\n    });\n}\nexport { range as $range };\n"},{"path":"select.mjs","content":"import { LocalDateTime, LocalDate, LocalTime, Duration, RelativeDuration, ConfigMemory, DateDuration, } from \"edgedb\";\nimport { Cardinality, cardinalityUtil, ExpressionKind, makeType, TypeKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { $getTypeByName, literal } from \"./literal.mjs\";\nimport { spec } from \"../__spec__.mjs\";\nimport { literalToTypeSet, } from \"../castMaps.mjs\";\nexport const ASC = \"ASC\";\nexport const DESC = \"DESC\";\nexport const EMPTY_FIRST = \"EMPTY FIRST\";\nexport const EMPTY_LAST = \"EMPTY LAST\";\nexport function is(expr, shape) {\n    const mappedShape = {};\n    for (const [key, value] of Object.entries(shape)) {\n        mappedShape[key] = {\n            __kind__: ExpressionKind.PolyShapeElement,\n            __polyType__: expr,\n            __shapeElement__: value,\n        };\n    }\n    return mappedShape;\n}\nfunction computeFilterCardinality(expr, cardinality, base) {\n    var _b, _c, _d;\n    let card = cardinality;\n    const filter = expr;\n    const baseIsObjectExpr = ((_b = base === null || base === void 0 ? void 0 : base.__element__) === null || _b === void 0 ? void 0 : _b.__kind__) === TypeKind.object;\n    const filterExprIsEq = filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\n    const arg0 = (_c = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _c === void 0 ? void 0 : _c[0];\n    const arg1 = (_d = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _d === void 0 ? void 0 : _d[1];\n    const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\n    const arg0IsUnique = (arg0 === null || arg0 === void 0 ? void 0 : arg0.__exclusive__) === true;\n    if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\n        const newCard = arg1.__cardinality__ === Cardinality.One ||\n            arg1.__cardinality__ === Cardinality.AtMostOne\n            ? Cardinality.AtMostOne\n            : arg1.__cardinality__ === Cardinality.Empty\n                ? Cardinality.Empty\n                : cardinality;\n        if (arg0.__kind__ === ExpressionKind.PathLeaf) {\n            const arg0ParentMatchesBase = arg0.__parent__.type.__element__.__name__ ===\n                base.__element__.__name__;\n            if (arg0ParentMatchesBase) {\n                card = newCard;\n            }\n        }\n        else if (arg0.__kind__ === ExpressionKind.PathNode) {\n            const parent = arg0.__parent__;\n            if (parent === null) {\n                const arg0MatchesBase = arg0.__element__.__name__ === base.__element__.__name__;\n                if (arg0MatchesBase) {\n                    card = newCard;\n                }\n            }\n            else {\n                const arg0ParentMatchesBase = (parent === null || parent === void 0 ? void 0 : parent.type.__element__.__name__) === base.__element__.__name__;\n                if (arg0ParentMatchesBase) {\n                    card = newCard;\n                }\n            }\n        }\n    }\n    return card;\n}\nexport function $handleModifiers(modifiers, rootExpr) {\n    const mods = { ...modifiers };\n    let card = rootExpr.__cardinality__;\n    if (mods.filter && rootExpr.__element__.__kind__ === TypeKind.object) {\n        card = computeFilterCardinality(mods.filter, card, rootExpr);\n    }\n    if (mods.order_by) {\n        const orderExprs = Array.isArray(mods.order_by)\n            ? mods.order_by\n            : [mods.order_by];\n        mods.order_by = orderExprs.map(expr => typeof expr.__element__ === \"undefined\"\n            ? expr\n            : { expression: expr });\n    }\n    if (mods.offset) {\n        mods.offset =\n            typeof mods.offset === \"number\"\n                ? $getTypeByName(\"std::number\")(mods.offset)\n                : mods.offset;\n        card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n    }\n    if (mods.limit) {\n        let expr = mods.limit;\n        if (typeof expr === \"number\") {\n            expr = $getTypeByName(\"std::number\")(expr);\n        }\n        else if (expr.__kind__ === ExpressionKind.Set) {\n            expr = expr.__exprs__[0];\n        }\n        mods.limit = expr;\n        card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n    }\n    return { modifiers: mods, cardinality: card };\n}\nfunction deleteExpr(expr, modifiersGetter) {\n    const selectExpr = select(expr, modifiersGetter);\n    return $expressionify({\n        __kind__: ExpressionKind.Delete,\n        __element__: selectExpr.__element__,\n        __cardinality__: selectExpr.__cardinality__,\n        __expr__: selectExpr,\n    });\n}\nexport { deleteExpr as delete };\nexport function $selectify(expr) {\n    return expr;\n}\nconst $FreeObject = makeType(spec, [...spec.values()].find(s => s.name === \"std::FreeObject\").id, literal);\nconst FreeObject = {\n    __kind__: ExpressionKind.PathNode,\n    __element__: $FreeObject,\n    __cardinality__: Cardinality.One,\n    __parent__: null,\n    __exclusive__: true,\n    __scopeRoot__: null,\n};\nexport const $existingScopes = new Set();\nfunction $shape(_a, b) {\n    return b;\n}\nexport { $shape as shape };\nexport function select(...args) {\n    const firstArg = args[0];\n    if (typeof firstArg !== \"object\" ||\n        firstArg instanceof Buffer ||\n        firstArg instanceof Date ||\n        firstArg instanceof Duration ||\n        firstArg instanceof LocalDateTime ||\n        firstArg instanceof LocalDate ||\n        firstArg instanceof LocalTime ||\n        firstArg instanceof RelativeDuration ||\n        firstArg instanceof DateDuration ||\n        firstArg instanceof ConfigMemory) {\n        const literalExpr = literalToTypeSet(firstArg);\n        return $expressionify($selectify({\n            __kind__: ExpressionKind.Select,\n            __element__: literalExpr.__element__,\n            __cardinality__: literalExpr.__cardinality__,\n            __expr__: literalExpr,\n            __modifiers__: {},\n        }));\n    }\n    const exprPair = typeof args[0].__element__ !== \"undefined\"\n        ? args\n        : [FreeObject, () => args[0]];\n    let expr = exprPair[0];\n    const shapeGetter = exprPair[1];\n    if (expr === FreeObject) {\n        const freeObjectPtrs = {};\n        for (const [k, v] of Object.entries(args[0])) {\n            freeObjectPtrs[k] = {\n                __kind__: v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\n                target: v.__element__,\n                cardinality: v.__cardinality__,\n                exclusive: false,\n                computed: true,\n                readonly: true,\n                hasDefault: false,\n                properties: {},\n            };\n        }\n        expr = {\n            ...FreeObject,\n            __element__: {\n                ...FreeObject.__element__,\n                __pointers__: {\n                    ...FreeObject.__element__.__pointers__,\n                    ...freeObjectPtrs,\n                },\n            },\n        };\n    }\n    if (!shapeGetter) {\n        if (expr.__element__.__kind__ === TypeKind.object) {\n            const objectExpr = expr;\n            return $expressionify($selectify({\n                __kind__: ExpressionKind.Select,\n                __element__: {\n                    __kind__: TypeKind.object,\n                    __name__: `${objectExpr.__element__.__name__}`,\n                    __pointers__: objectExpr.__element__.__pointers__,\n                    __shape__: objectExpr.__element__.__shape__,\n                },\n                __cardinality__: objectExpr.__cardinality__,\n                __expr__: objectExpr,\n                __modifiers__: {},\n            }));\n        }\n        else {\n            return $expressionify($selectify({\n                __kind__: ExpressionKind.Select,\n                __element__: expr.__element__,\n                __cardinality__: expr.__cardinality__,\n                __expr__: expr,\n                __modifiers__: {},\n            }));\n        }\n    }\n    const cleanScopedExprs = $existingScopes.size === 0;\n    const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);\n    if (cleanScopedExprs) {\n        $existingScopes.clear();\n    }\n    const { modifiers, cardinality } = $handleModifiers(mods, expr);\n    return $expressionify($selectify({\n        __kind__: ExpressionKind.Select,\n        __element__: expr.__element__.__kind__ === TypeKind.object\n            ? {\n                __kind__: TypeKind.object,\n                __name__: `${expr.__element__.__name__}`,\n                __pointers__: expr.__element__.__pointers__,\n                __shape__: shape,\n            }\n            : expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __modifiers__: modifiers,\n        __scope__: expr !== scope\n            ? scope\n            : undefined,\n    }));\n}\nfunction resolveShape(shapeGetter, expr) {\n    const modifiers = {};\n    const shape = {};\n    const scope = expr.__element__.__kind__ === TypeKind.object\n        ? $getScopedExpr(expr, $existingScopes)\n        : expr;\n    const selectShape = typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n    for (const [key, value] of Object.entries(selectShape)) {\n        if (key === \"filter\" ||\n            key === \"order_by\" ||\n            key === \"offset\" ||\n            key === \"limit\") {\n            modifiers[key] = value;\n        }\n        else {\n            if (expr.__element__.__kind__ !== TypeKind.object) {\n                throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +\n                    `only modifiers are allowed (filter, order_by, offset and limit)`);\n            }\n            shape[key] = resolveShapeElement(key, value, scope);\n        }\n    }\n    return { shape, modifiers, scope };\n}\nexport function resolveShapeElement(key, value, scope) {\n    var _b, _c, _d, _e, _f;\n    const isSubshape = typeof value === \"object\" &&\n        typeof value.__kind__ === \"undefined\";\n    const isClosure = typeof value === \"function\" &&\n        ((_b = scope.__element__.__pointers__[key]) === null || _b === void 0 ? void 0 : _b.__kind__) === \"link\";\n    if (isSubshape || isClosure) {\n        const childExpr = scope[key];\n        if (!childExpr) {\n            throw new Error(`Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`);\n        }\n        const { shape: childShape, scope: childScope, modifiers: mods, } = resolveShape(value, childExpr);\n        const { modifiers } = $handleModifiers(mods, childExpr);\n        return {\n            __kind__: ExpressionKind.Select,\n            __element__: {\n                __kind__: TypeKind.object,\n                __name__: `${childExpr.__element__.__name__}`,\n                __pointers__: childExpr.__element__.__pointers__,\n                __shape__: childShape,\n            },\n            __cardinality__: ((_d = (_c = scope.__element__.__pointers__) === null || _c === void 0 ? void 0 : _c[key]) === null || _d === void 0 ? void 0 : _d.cardinality) ||\n                ((_f = (_e = scope.__element__.__shape__) === null || _e === void 0 ? void 0 : _e[key]) === null || _f === void 0 ? void 0 : _f.__cardinality__),\n            __expr__: childExpr,\n            __modifiers__: modifiers,\n            __scope__: childExpr !== childScope ? childScope : undefined,\n        };\n    }\n    else if ((value === null || value === void 0 ? void 0 : value.__kind__) === ExpressionKind.PolyShapeElement) {\n        const polyElement = value;\n        const polyScope = scope.is(polyElement.__polyType__);\n        return {\n            __kind__: ExpressionKind.PolyShapeElement,\n            __polyType__: polyScope,\n            __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),\n        };\n    }\n    else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n        const linkProp = scope[key];\n        if (!linkProp) {\n            throw new Error(scope.__parent__\n                ? `link property '${key}' does not exist on link ${scope.__parent__.linkName}`\n                : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`);\n        }\n        return value ? linkProp : false;\n    }\n    else {\n        return value;\n    }\n}\n"},{"path":"set.mjs","content":"import { TypeKind, $mergeObjectTypes } from \"edgedb/dist/reflection/index.js\";\nimport * as castMaps from \"../castMaps.mjs\";\nexport function getSharedParent(a, b) {\n    if (a.__kind__ !== b.__kind__) {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\n        return castMaps.getSharedParentScalar(a, b);\n    }\n    else if (a.__kind__ === TypeKind.object &&\n        b.__kind__ === TypeKind.object) {\n        return $mergeObjectTypes(a, b);\n    }\n    else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\n        if (a.__items__.length !== b.__items__.length) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = a.__items__.map((_, i) => {\n                if (!a.__items__[i] || !b.__items__[i]) {\n                    throw new Error();\n                }\n                return getSharedParent(a.__items__[i], b.__items__[i]);\n            });\n            return {\n                __kind__: TypeKind.tuple,\n                __name__: `tuple<${items.map(item => item.__name__).join(\", \")}>`,\n                __items__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.namedtuple &&\n        b.__kind__ === TypeKind.namedtuple) {\n        const aKeys = Object.keys(a);\n        const bKeys = new Set(Object.keys(b));\n        const sameKeys = aKeys.length === bKeys.size && aKeys.every(k => bKeys.has(k));\n        if (!sameKeys) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n        try {\n            const items = {};\n            for (const [i] of Object.entries(a.__shape__)) {\n                if (!a.__shape__[i] || !b.__shape__[i]) {\n                    throw new Error();\n                }\n                items[i] = getSharedParent(a.__shape__[i], b.__shape__[i]);\n            }\n            return {\n                __kind__: TypeKind.namedtuple,\n                __name__: `tuple<${Object.entries(items)\n                    .map(([key, val]) => `${key}: ${val.__name__}`)\n                    .join(\", \")}>`,\n                __shape__: items,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible tuple types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\n        try {\n            const mergedEl = getSharedParent(a.__element__, b.__element__);\n            return {\n                __kind__: TypeKind.array,\n                __name__: a.__name__,\n                __element__: mergedEl,\n            };\n        }\n        catch (err) {\n            throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n        }\n    }\n    else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\n        if (a.__name__ === b.__name__)\n            return a;\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n    else {\n        throw new Error(`Incompatible array types: ${a.__name__} and ${b.__name__}`);\n    }\n}\nexport { set } from \"./setImpl.mjs\";\n"},{"path":"syntax.mjs","content":"export * from \"./literal.mjs\";\nexport * from \"./path.mjs\";\nexport * from \"./set.mjs\";\nexport * from \"./cast.mjs\";\nexport * from \"./select.mjs\";\nexport * from \"./update.mjs\";\nexport * from \"./insert.mjs\";\nexport * from \"./group.mjs\";\nexport * from \"./collections.mjs\";\nexport * from \"./funcops.mjs\";\nexport * from \"./for.mjs\";\nexport * from \"./with.mjs\";\nexport * from \"./params.mjs\";\nexport * from \"./globals.mjs\";\nexport * from \"./detached.mjs\";\nexport * from \"./toEdgeQL.mjs\";\nexport * from \"./range.mjs\";\n"},{"path":"toEdgeQL.mjs","content":"import { Duration, LocalDate, LocalDateTime, LocalTime, RelativeDuration, DateDuration, Range, } from \"edgedb\";\nimport { Cardinality, ExpressionKind, isArrayType, isNamedTupleType, isObjectType, isTupleType, OperatorKind, TypeKind, util, } from \"edgedb/dist/reflection/index.js\";\nimport { reservedKeywords } from \"edgedb/dist/reflection/reservedKeywords.js\";\nconst toEdgeQLCache = new WeakMap();\nexport function $toEdgeQL() {\n    var _a;\n    if (toEdgeQLCache.has(this)) {\n        return toEdgeQLCache.get(this);\n    }\n    const walkExprCtx = {\n        seen: new Map(),\n        rootScope: null,\n    };\n    walkExprTree(this, null, walkExprCtx);\n    const withBlocks = new Map();\n    const withVars = new Map();\n    const seen = new Map(walkExprCtx.seen);\n    const linkProps = new Map();\n    for (const [expr, refData] of seen) {\n        seen.delete(expr);\n        if (refData.linkProps.length) {\n            linkProps.set(expr, refData.linkProps.map(linkProp => linkProp.__parent__.linkName.slice(1)));\n        }\n        if (withVars.has(expr)) {\n            continue;\n        }\n        if (!refData.boundScope &&\n            (expr.__kind__ === ExpressionKind.PathLeaf ||\n                expr.__kind__ === ExpressionKind.PathNode ||\n                expr.__kind__ === ExpressionKind.TypeIntersection)) {\n            continue;\n        }\n        if (expr.__kind__ === ExpressionKind.ForVar ||\n            expr.__kind__ === ExpressionKind.Param) {\n            continue;\n        }\n        if ((expr.__kind__ === ExpressionKind.Select ||\n            expr.__kind__ === ExpressionKind.Update ||\n            expr.__kind__ === ExpressionKind.Group) &&\n            expr.__scope__ &&\n            !withVars.has(expr.__scope__)) {\n            const withBlock = expr;\n            const scopeVar = expr.__scope__;\n            const scopeVarName = `__scope_${withVars.size}_${scopeVar.__element__.__name__.split(\"::\")[1]}`;\n            withVars.set(scopeVar, {\n                name: scopeVarName,\n                scope: withBlock,\n                childExprs: new Set(),\n                scopedExpr: expr.__element__.__kind__ === TypeKind.object\n                    ? expr.__expr__\n                    : undefined,\n            });\n        }\n        if (refData.refCount > 1 ||\n            refData.boundScope ||\n            refData.aliases.length > 0) {\n            let withBlock = refData.boundScope;\n            const parentScopes = [...refData.parentScopes].filter(scope => scope !== null);\n            if (!withBlock) {\n                if (parentScopes.some(parentScope => seen.has(parentScope))) {\n                    seen.set(expr, refData);\n                    continue;\n                }\n                const resolvedParentScopes = parentScopes.map(parentScope => { var _a, _b; return (_b = (_a = withVars.get(parentScope)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : parentScope; });\n                withBlock =\n                    (_a = resolvedParentScopes.find(parentScope => {\n                        const childExprs = new Set(walkExprCtx.seen.get(parentScope).childExprs);\n                        return resolvedParentScopes.every(scope => childExprs.has(scope) || scope === parentScope);\n                    })) !== null && _a !== void 0 ? _a : walkExprCtx.rootScope;\n            }\n            if (!withBlock) {\n                throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +\n                    `query has no 'WITH'able expressions`);\n            }\n            if (!withBlocks.has(withBlock)) {\n                withBlocks.set(withBlock, new Set());\n            }\n            const validScopes = new Set([\n                withBlock,\n                ...walkExprCtx.seen.get(withBlock).childExprs,\n            ]);\n            for (const scope of [\n                ...refData.parentScopes,\n                ...util.flatMap(refData.aliases, alias => [\n                    ...walkExprCtx.seen.get(alias).parentScopes,\n                ]),\n            ]) {\n                if (scope === null || !validScopes.has(scope)) {\n                    throw new Error(refData.boundScope\n                        ? `Expr or its aliases used outside of declared 'WITH' block scope`\n                        : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                            `expression or its aliases appear outside root scope`);\n                }\n            }\n            for (const withVar of [expr, ...refData.aliases]) {\n                const withVarBoundScope = walkExprCtx.seen.get(withVar).boundScope;\n                if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n                    continue;\n                }\n                const withVarName = `__withVar_${withVars.size}`;\n                withBlocks.get(withBlock).add(withVar);\n                withVars.set(withVar, {\n                    name: withVarName,\n                    scope: withBlock,\n                    childExprs: new Set(walkExprCtx.seen.get(withVar).childExprs),\n                });\n            }\n        }\n    }\n    let edgeQL = renderEdgeQL(this, {\n        withBlocks,\n        withVars,\n        forVars: new Map(),\n        linkProps,\n    });\n    if (edgeQL.startsWith(\"(\") &&\n        edgeQL.endsWith(\")\") &&\n        !(this.__kind__ === ExpressionKind.Tuple ||\n            this.__kind__ === ExpressionKind.NamedTuple ||\n            this.__kind__ === ExpressionKind.Literal)) {\n        edgeQL = edgeQL.slice(1, -1);\n    }\n    toEdgeQLCache.set(this, edgeQL);\n    return edgeQL;\n}\nfunction walkExprTree(_expr, parentScope, ctx) {\n    var _a, _b, _c, _d;\n    if (!_expr.__kind__) {\n        throw new Error(`Expected a valid querybuilder expression, ` +\n            `instead received ${typeof _expr}${typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"}.` +\n            getErrorHint(_expr));\n    }\n    const expr = _expr;\n    function walkShape(shape) {\n        for (let param of Object.values(shape)) {\n            if (param.__kind__ === ExpressionKind.PolyShapeElement) {\n                param = param.__shapeElement__;\n            }\n            if (typeof param === \"object\") {\n                if (!!param.__kind__) {\n                    childExprs.push(...walkExprTree(param, expr, ctx));\n                }\n                else {\n                    walkShape(param);\n                }\n            }\n        }\n    }\n    if (!ctx.rootScope && parentScope) {\n        ctx.rootScope = parentScope;\n    }\n    const seenExpr = ctx.seen.get(expr);\n    if (seenExpr) {\n        seenExpr.refCount += 1;\n        seenExpr.parentScopes.add(parentScope);\n        return [expr, ...seenExpr.childExprs];\n    }\n    const childExprs = [];\n    ctx.seen.set(expr, {\n        refCount: 1,\n        parentScopes: new Set([parentScope]),\n        childExprs,\n        boundScope: null,\n        aliases: [],\n        linkProps: [],\n    });\n    switch (expr.__kind__) {\n        case ExpressionKind.Alias:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            ctx.seen.get(expr.__expr__).aliases.push(expr);\n            break;\n        case ExpressionKind.With:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            for (const refExpr of expr.__refs__) {\n                walkExprTree(refExpr, expr.__expr__, ctx);\n                const seenRef = ctx.seen.get(refExpr);\n                if (seenRef.boundScope) {\n                    throw new Error(`Expression bound to multiple 'WITH' blocks`);\n                }\n                seenRef.boundScope = expr.__expr__;\n            }\n            break;\n        case ExpressionKind.Literal:\n        case ExpressionKind.ForVar:\n        case ExpressionKind.Param:\n            break;\n        case ExpressionKind.PathLeaf:\n        case ExpressionKind.PathNode:\n            if (expr.__parent__) {\n                if (expr.__parent__.type.__scopedFrom__) {\n                    childExprs.push(expr.__parent__.type);\n                }\n                else {\n                    childExprs.push(...walkExprTree(expr.__parent__.type, parentScope, ctx));\n                }\n                if (expr.__kind__ === ExpressionKind.PathLeaf &&\n                    expr.__parent__.linkName.startsWith(\"@\")) {\n                    const parentScopeVar = parentScope.__scope__;\n                    if (parentScopeVar === expr.__parent__.type) {\n                        (_a = ctx.seen.get(parentScope)) === null || _a === void 0 ? void 0 : _a.linkProps.push(expr);\n                    }\n                }\n            }\n            break;\n        case ExpressionKind.Cast:\n            if (expr.__expr__ === null)\n                break;\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case ExpressionKind.Set:\n            for (const subExpr of expr.__exprs__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.Array:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.Tuple:\n            for (const subExpr of expr.__items__) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.NamedTuple:\n            for (const subExpr of Object.values(expr.__shape__)) {\n                childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n            }\n            break;\n        case ExpressionKind.TuplePath:\n            childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n            break;\n        case ExpressionKind.Select:\n        case ExpressionKind.Update: {\n            const modifiers = expr.__modifiers__;\n            if (modifiers.filter) {\n                childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n            }\n            if (modifiers.order_by) {\n                for (const orderExpr of modifiers.order_by) {\n                    childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n                }\n            }\n            if (modifiers.offset) {\n                childExprs.push(...walkExprTree(modifiers.offset, expr, ctx));\n            }\n            if (modifiers.limit) {\n                childExprs.push(...walkExprTree(modifiers.limit, expr, ctx));\n            }\n            if (expr.__kind__ === ExpressionKind.Select) {\n                if (isObjectType(expr.__element__) &&\n                    expr.__element__.__shape__ !==\n                        expr.__expr__.__element__.__shape__) {\n                    walkShape((_b = expr.__element__.__shape__) !== null && _b !== void 0 ? _b : {});\n                }\n            }\n            else {\n                const shape = (_c = expr.__shape__) !== null && _c !== void 0 ? _c : {};\n                for (const _element of Object.values(shape)) {\n                    let element = _element;\n                    if (!element.__element__) {\n                        if (element[\"+=\"])\n                            element = element[\"+=\"];\n                        else if (element[\"-=\"])\n                            element = element[\"-=\"];\n                    }\n                    childExprs.push(...walkExprTree(element, expr, ctx));\n                }\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.Delete: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Insert: {\n            const shape = (_d = expr.__shape__) !== null && _d !== void 0 ? _d : {};\n            for (const element of Object.values(shape)) {\n                childExprs.push(...walkExprTree(element, expr, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.InsertUnlessConflict: {\n            if (expr.__conflict__.on) {\n                childExprs.push(...walkExprTree(expr.__conflict__.on, expr.__expr__, ctx));\n            }\n            if (expr.__conflict__.else) {\n                childExprs.push(...walkExprTree(expr.__conflict__.else, expr.__expr__, ctx));\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Group: {\n            const groupingSet = expr.__modifiers__.by;\n            for (const [_k, groupExpr] of groupingSet.__exprs__) {\n                const seen = new Set();\n                if (!seen.has(expr)) {\n                    childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n                    seen.add(expr);\n                }\n            }\n            if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n                throw new Error(\"Missing shape in GROUP statement\");\n            }\n            walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.TypeIntersection:\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        case ExpressionKind.Operator:\n        case ExpressionKind.Function:\n            for (const subExpr of expr.__args__) {\n                if (Array.isArray(subExpr)) {\n                    for (const arg of subExpr) {\n                        if (arg)\n                            childExprs.push(...walkExprTree(arg, parentScope, ctx));\n                    }\n                }\n                else {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            if (expr.__kind__ === ExpressionKind.Function) {\n                for (const subExpr of Object.values(expr.__namedargs__)) {\n                    childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n                }\n            }\n            break;\n        case ExpressionKind.For: {\n            childExprs.push(...walkExprTree(expr.__iterSet__, expr, ctx));\n            childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n            break;\n        }\n        case ExpressionKind.WithParams: {\n            if (parentScope !== null) {\n                throw new Error(`'withParams' does not support being used as a nested expression`);\n            }\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Detached: {\n            childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n            break;\n        }\n        case ExpressionKind.Global:\n            break;\n        default:\n            util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n    return [expr, ...childExprs];\n}\nfunction renderEdgeQL(_expr, ctx, renderShape = true, noImplicitDetached = false) {\n    var _a, _b;\n    if (!_expr.__kind__) {\n        throw new Error(\"Invalid expression.\");\n    }\n    const expr = _expr;\n    const withVar = ctx.withVars.get(expr);\n    if (withVar && ctx.renderWithVar !== expr) {\n        return renderShape &&\n            expr.__kind__ === ExpressionKind.Select &&\n            isObjectType(expr.__element__)\n            ? `(${withVar.name} ${shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, null, true)})`\n            : withVar.name;\n    }\n    function renderWithBlockExpr(varExpr, _noImplicitDetached) {\n        var _a, _b;\n        const withBlockElement = ctx.withVars.get(varExpr);\n        let renderedExpr = renderEdgeQL((_a = withBlockElement.scopedExpr) !== null && _a !== void 0 ? _a : varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, _noImplicitDetached);\n        const renderedExprNoDetached = renderEdgeQL((_b = withBlockElement.scopedExpr) !== null && _b !== void 0 ? _b : varExpr, {\n            ...ctx,\n            renderWithVar: varExpr,\n        }, !withBlockElement.scopedExpr, true);\n        if (ctx.linkProps.has(expr)) {\n            renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n                .get(expr)\n                .map(linkPropName => `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`)\n                .join(\",\\n\")}\\n})`;\n        }\n        return `  ${withBlockElement.name} := ${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}`;\n    }\n    const scopeExpr = (expr.__kind__ === ExpressionKind.Select ||\n        expr.__kind__ === ExpressionKind.Update ||\n        expr.__kind__ === ExpressionKind.Group) &&\n        ctx.withVars.has(expr.__scope__)\n        ? expr.__scope__\n        : undefined;\n    const scopeExprVar = [];\n    const unscopedWithBlock = [];\n    const scopedWithBlock = [];\n    if (ctx.withBlocks.has(expr) || scopeExpr) {\n        const sortedBlockVars = topoSortWithVars((_a = ctx.withBlocks.get(expr)) !== null && _a !== void 0 ? _a : new Set(), ctx);\n        if (!scopeExpr) {\n            unscopedWithBlock.push(...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar)));\n        }\n        else {\n            const scopeVar = ctx.withVars.get(scopeExpr);\n            const scopedVars = sortedBlockVars.filter(blockVarExpr => { var _a; return (_a = ctx.withVars.get(blockVarExpr)) === null || _a === void 0 ? void 0 : _a.childExprs.has(scopeExpr); });\n            unscopedWithBlock.push(...sortedBlockVars\n                .filter(blockVar => !scopedVars.includes(blockVar))\n                .map(blockVar => renderWithBlockExpr(blockVar)));\n            if (!scopedVars.length) {\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n            }\n            else {\n                const scopeName = scopeVar.name;\n                scopeVar.name = scopeName + \"_expr\";\n                scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n                scopeVar.name = scopeName + \"_inner\";\n                scopeExprVar.push(`  ${scopeName} := (FOR ${scopeVar.name} IN {${scopeName + \"_expr\"}} UNION (\\n    WITH\\n${indent(scopedVars\n                    .map(blockVar => renderWithBlockExpr(blockVar))\n                    .join(\",\\n\"), 4)}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n                    .map(blockVar => {\n                    const name = ctx.withVars.get(blockVar).name;\n                    return `      ${name} := ${name}`;\n                })\n                    .join(\",\\n\")}\\n    }\\n  ))`);\n                scopeVar.name = scopeName;\n                for (const blockVarExpr of scopedVars) {\n                    const blockVar = ctx.withVars.get(blockVarExpr);\n                    blockVar.name = `${scopeName}.${blockVar.name}`;\n                }\n            }\n        }\n    }\n    const withBlockElements = [\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        ...scopedWithBlock,\n    ];\n    const withBlock = withBlockElements.length\n        ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n        : \"\";\n    if (expr.__kind__ === ExpressionKind.With) {\n        return renderEdgeQL(expr.__expr__, ctx);\n    }\n    else if (expr.__kind__ === ExpressionKind.WithParams) {\n        return `(WITH\\n${expr.__params__\n            .map(param => {\n            const optional = param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n            return `  __param__${param.__name__} := ${param.__isComplex__\n                ? `<${param.__element__.__name__}>to_json(<${optional}str>$${param.__name__})`\n                : `<${optional}${param.__element__.__name__}>$${param.__name__}`}`;\n        })\n            .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Alias) {\n        const aliasedExprVar = ctx.withVars.get(expr.__expr__);\n        if (!aliasedExprVar) {\n            throw new Error(`Expression referenced by alias does not exist in 'WITH' block`);\n        }\n        return aliasedExprVar.name;\n    }\n    else if (expr.__kind__ === ExpressionKind.PathNode ||\n        expr.__kind__ === ExpressionKind.PathLeaf) {\n        if (!expr.__parent__) {\n            return `${noImplicitDetached ? \"\" : \"DETACHED \"}${expr.__element__.__name__}`;\n        }\n        else {\n            const isScopedLinkProp = expr.__parent__.linkName.startsWith(\"@\") &&\n                ctx.withVars.has(expr.__parent__.type);\n            const linkName = isScopedLinkProp\n                ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n                : expr.__parent__.linkName;\n            const parent = renderEdgeQL(expr.__parent__.type, ctx, false, noImplicitDetached);\n            return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.Literal) {\n        return literalToEdgeQL(expr.__element__, expr.__value__);\n    }\n    else if (expr.__kind__ === ExpressionKind.Set) {\n        const exprs = expr.__exprs__;\n        if (exprs.every(ex => ex.__element__.__kind__ === TypeKind.object) ||\n            exprs.every(ex => ex.__element__.__kind__ !== TypeKind.object)) {\n            if (exprs.length === 0)\n                return `<${expr.__element__.__name__}>{}`;\n            return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n        }\n        else {\n            throw new Error(`Invalid arguments to set constructor: ${exprs\n                .map(ex => ex.__element__.__name__)\n                .join(\", \")}`);\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.Array) {\n        return `[${expr.__items__\n            .map(item => renderEdgeQL(item, ctx))\n            .join(\", \")}]`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Tuple) {\n        return `(\\n${expr.__items__\n            .map(item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached))\n            .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n    }\n    else if (expr.__kind__ === ExpressionKind.NamedTuple) {\n        return `(\\n${Object.keys(expr.__shape__)\n            .map(key => `  ${key} := ${renderEdgeQL(expr.__shape__[key], ctx, renderShape, noImplicitDetached)}`)\n            .join(\",\\n\")}\\n)`;\n    }\n    else if (expr.__kind__ === ExpressionKind.TuplePath) {\n        return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Cast) {\n        const typeName = expr.__element__.__name__ === \"std::number\"\n            ? \"std::float64\"\n            : expr.__element__.__name__;\n        if (expr.__expr__ === null) {\n            return `<${typeName}>{}`;\n        }\n        return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Select) {\n        const lines = [];\n        if (isObjectType(expr.__element__)) {\n            const selectionTarget = renderEdgeQL((_b = expr.__scope__) !== null && _b !== void 0 ? _b : expr.__expr__, ctx, false);\n            lines.push(`SELECT${selectionTarget === \"DETACHED std::FreeObject\"\n                ? \"\"\n                : ` ${selectionTarget}`}`);\n            if (expr.__element__.__shape__ !==\n                expr.__expr__.__element__.__shape__) {\n                lines.push(shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, expr.__element__));\n            }\n        }\n        else {\n            const needsScalarVar = (expr.__modifiers__.filter ||\n                expr.__modifiers__.order_by ||\n                expr.__modifiers__.offset ||\n                expr.__modifiers__.limit) &&\n                !ctx.withVars.has(expr.__expr__);\n            lines.push(`SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(expr.__expr__, ctx)}`);\n            if (needsScalarVar) {\n                ctx = { ...ctx, withVars: new Map(ctx.withVars) };\n                ctx.withVars.set(expr.__expr__, {\n                    name: \"_\",\n                    childExprs: new Set(),\n                    scope: expr,\n                });\n            }\n        }\n        const modifiers = [];\n        if (expr.__modifiers__.filter) {\n            modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n        }\n        if (expr.__modifiers__.order_by) {\n            modifiers.push(...expr.__modifiers__.order_by.map(({ expression, direction, empty }, i) => {\n                return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(expression, ctx)}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n            }));\n        }\n        if (expr.__modifiers__.offset) {\n            modifiers.push(`OFFSET ${renderEdgeQL(expr.__modifiers__.offset, ctx)}`);\n        }\n        if (expr.__modifiers__.limit) {\n            modifiers.push(`LIMIT ${renderEdgeQL(expr.__modifiers__.limit, ctx)}`);\n        }\n        return (\"(\" +\n            withBlock +\n            lines.join(\" \") +\n            (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n            \")\");\n    }\n    else if (expr.__kind__ === ExpressionKind.Update) {\n        return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${expr.__modifiers__.filter\n            ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n            : \" \"}SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Delete) {\n        return `(${withBlock}DELETE ${renderEdgeQL(expr.__expr__, ctx, undefined, noImplicitDetached)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Insert) {\n        return `(${withBlock}INSERT ${renderEdgeQL(expr.__expr__, ctx, false, true)} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\n        const $on = expr.__conflict__.on;\n        const $else = expr.__conflict__.else;\n        const clause = [];\n        if (!$on) {\n            clause.push(\"\\nUNLESS CONFLICT\");\n        }\n        if ($on) {\n            clause.push(`\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`);\n        }\n        if ($else) {\n            clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n        }\n        return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(1, -1)} ${clause.join(\"\")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Group) {\n        const groupingSet = expr.__modifiers__.by;\n        const elementsShape = expr.__element__.__shape__.elements.__element__.__shape__;\n        const selectStatement = [];\n        const groupStatement = [];\n        const groupTarget = renderEdgeQL(expr.__scope__, ctx);\n        groupStatement.push(`GROUP ${groupTarget}`);\n        const combinedBlock = [\n            ...groupingSet.__exprs__.map(([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`),\n        ];\n        groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n        let by = renderGroupingSet(groupingSet).trim();\n        if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n            by = by.slice(1, by.length - 1);\n        }\n        groupStatement.push(`BY ` + by);\n        const selectTarget = `${groupTarget}_groups`;\n        selectStatement.push(`WITH\\n${[\n            ...unscopedWithBlock,\n            ...scopeExprVar,\n        ].join(\",\\n\")},\n  ${selectTarget} := (\n${indent(groupStatement.join(\"\\n\"), 4)}\n)`);\n        const scopeVar = ctx.withVars.get(expr.__scope__);\n        const elementsShapeQuery = indent(shapeToEdgeQL(elementsShape, { ...ctx }, expr.__element__), 2)\n            .trim()\n            .split(scopeVar.name + \".\")\n            .join(`${selectTarget}.elements.`);\n        selectStatement.push(`SELECT ${selectTarget} {\n  key: {${groupingSet.__exprs__.map(e => e[0]).join(\", \")}},\n  grouping,\n  elements: ${elementsShapeQuery}\n}`);\n        return `(${selectStatement.join(\"\\n\")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Function) {\n        const args = expr.__args__.map(arg => `${renderEdgeQL(arg, ctx, false)}`);\n        for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n            args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n        }\n        return `${expr.__name__}(${args.join(\", \")})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Operator) {\n        const operator = expr.__name__;\n        const args = expr.__args__;\n        switch (expr.__opkind__) {\n            case OperatorKind.Infix:\n                if (operator === \"[]\") {\n                    let index = \"\";\n                    if (Array.isArray(args[1])) {\n                        const [start, end] = args[1];\n                        if (start) {\n                            index += renderEdgeQL(start, ctx);\n                        }\n                        index += \":\";\n                        if (end) {\n                            index += renderEdgeQL(end, ctx);\n                        }\n                    }\n                    else {\n                        index = renderEdgeQL(args[1], ctx);\n                    }\n                    return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n                }\n                return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(args[1], ctx)})`;\n            case OperatorKind.Postfix:\n                return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n            case OperatorKind.Prefix:\n                return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n            case OperatorKind.Ternary:\n                if (operator === \"if_else\") {\n                    return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(args[1], ctx)} ELSE ${renderEdgeQL(args[2], ctx)})`;\n                }\n                else {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n            default:\n                util.assertNever(expr.__opkind__, new Error(`Unknown operator kind: ${expr.__opkind__}`));\n        }\n    }\n    else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\n        return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${expr.__element__.__name__}]`;\n    }\n    else if (expr.__kind__ === ExpressionKind.For) {\n        ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n        return `(${withBlock}FOR ${ctx.forVars.get(expr.__forVar__)} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n    }\n    else if (expr.__kind__ === ExpressionKind.ForVar) {\n        const forVar = ctx.forVars.get(expr);\n        if (!forVar) {\n            throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n        }\n        return forVar;\n    }\n    else if (expr.__kind__ === ExpressionKind.Param) {\n        return `__param__${expr.__name__}`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Detached) {\n        return `(DETACHED ${renderEdgeQL(expr.__expr__, {\n            ...ctx,\n            renderWithVar: expr.__expr__,\n        }, undefined, true)})`;\n    }\n    else if (expr.__kind__ === ExpressionKind.Global) {\n        return `(GLOBAL ${expr.__name__})`;\n    }\n    else {\n        util.assertNever(expr, new Error(`Unrecognized expression kind: \"${expr.__kind__}\"`));\n    }\n}\nfunction isGroupingSet(arg) {\n    return arg.__kind__ === \"groupingset\";\n}\nfunction renderGroupingSet(set) {\n    const contents = Object.entries(set.__elements__)\n        .map(([k, v]) => {\n        return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n        .join(\", \");\n    if (set.__settype__ === \"tuple\") {\n        return `(${contents})`;\n    }\n    else if (set.__settype__ === \"set\") {\n        return `{${contents}}`;\n    }\n    else if (set.__settype__ === \"cube\") {\n        return `cube(${contents})`;\n    }\n    else if (set.__settype__ === \"rollup\") {\n        return `rollup(${contents})`;\n    }\n    else {\n        throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n    }\n}\nfunction shapeToEdgeQL(shape, ctx, type = null, keysOnly = false, injectImplicitId = true) {\n    const pointers = (type === null || type === void 0 ? void 0 : type.__pointers__) || null;\n    const isFreeObject = (type === null || type === void 0 ? void 0 : type.__name__) === \"std::FreeObject\";\n    if (shape === null) {\n        return ``;\n    }\n    const lines = [];\n    const addLine = (line) => lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n    const seen = new Set();\n    for (const key in shape) {\n        if (!shape.hasOwnProperty(key))\n            continue;\n        if (seen.has(key)) {\n            console.warn(`Invalid: duplicate key \"${key}\"`);\n            continue;\n        }\n        seen.add(key);\n        let val = shape[key];\n        let operator = \":=\";\n        let polyType = null;\n        if (typeof val === \"object\" && !val.__element__) {\n            if (!!val[\"+=\"]) {\n                operator = \"+=\";\n                val = val[\"+=\"];\n            }\n            else if (!!val[\"-=\"]) {\n                operator = \"-=\";\n                val = val[\"-=\"];\n            }\n        }\n        if (val.__kind__ === ExpressionKind.PolyShapeElement) {\n            polyType = val.__polyType__;\n            val = val.__shapeElement__;\n        }\n        const polyIntersection = polyType\n            ? `[IS ${polyType.__element__.__name__}].`\n            : \"\";\n        const ptr = pointers === null || pointers === void 0 ? void 0 : pointers[key];\n        const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n        const expectedCardinality = addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n            ? val.__cardinality__ === Cardinality.Many ||\n                val.__cardinality__ === Cardinality.AtLeastOne\n                ? \"multi \"\n                : \"single \"\n            : \"\";\n        const wrapAssertExists = (ptr === null || ptr === void 0 ? void 0 : ptr.cardinality) === Cardinality.AtLeastOne;\n        if (typeof val === \"boolean\") {\n            if (!(pointers === null || pointers === void 0 ? void 0 : pointers[key]) &&\n                key[0] !== \"@\" &&\n                type &&\n                (type === null || type === void 0 ? void 0 : type.__name__) !== \"std::FreeObject\" &&\n                !polyIntersection) {\n                throw new Error(`Field \"${key}\" does not exist in ${type === null || type === void 0 ? void 0 : type.__name__}`);\n            }\n            if (val) {\n                addLine(`${polyIntersection}${q(key)}`);\n            }\n            continue;\n        }\n        if (typeof val !== \"object\") {\n            throw new Error(`Invalid shape element at \"${key}\".`);\n        }\n        const valIsExpression = val.hasOwnProperty(\"__kind__\");\n        if (!valIsExpression) {\n            addLine(`${polyIntersection}${q(key, false)}: ${indent(shapeToEdgeQL(val, ctx, ptr === null || ptr === void 0 ? void 0 : ptr.target), 2).trim()}`);\n            continue;\n        }\n        if (keysOnly) {\n            addLine(q(key, false) +\n                (isObjectType(val.__element__)\n                    ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n                    : \"\"));\n            continue;\n        }\n        const renderedExpr = renderEdgeQL(val, ctx);\n        addLine(`${expectedCardinality}${q(key, false)} ${operator} ${wrapAssertExists ? \"assert_exists(\" : \"\"}${renderedExpr.includes(\"\\n\")\n            ? `(\\n${indent(renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr, 4)}\\n  )`\n            : renderedExpr}${wrapAssertExists ? \")\" : \"\"}`);\n    }\n    if (lines.length === 0 && injectImplicitId) {\n        addLine(\"id\");\n    }\n    return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\nfunction topoSortWithVars(vars, ctx) {\n    if (!vars.size) {\n        return [];\n    }\n    const sorted = [];\n    const unvisited = new Set(vars);\n    const visiting = new Set();\n    for (const withVar of unvisited) {\n        visit(withVar);\n    }\n    function visit(withVar) {\n        if (!unvisited.has(withVar)) {\n            return;\n        }\n        if (visiting.has(withVar)) {\n            throw new Error(`'WITH' variables contain a cyclic dependency`);\n        }\n        visiting.add(withVar);\n        for (const child of ctx.withVars.get(withVar).childExprs) {\n            if (vars.has(child)) {\n                visit(child);\n            }\n        }\n        visiting.delete(withVar);\n        unvisited.delete(withVar);\n        sorted.push(withVar);\n    }\n    return sorted;\n}\nconst numericalTypes = {\n    \"std::number\": true,\n    \"std::int16\": true,\n    \"std::int32\": true,\n    \"std::int64\": true,\n    \"std::float32\": true,\n    \"std::float64\": true,\n};\nfunction literalToEdgeQL(type, val) {\n    let skipCast = false;\n    let stringRep;\n    if (type.__name__ === \"std::json\") {\n        skipCast = true;\n        stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n    }\n    else if (typeof val === \"string\") {\n        if (numericalTypes[type.__name__]) {\n            skipCast = true;\n            stringRep = val;\n        }\n        else if (type.__kind__ === TypeKind.enum) {\n            skipCast = true;\n            const vals = type.__values__;\n            if (vals.includes(val)) {\n                skipCast = true;\n                if (val.includes(\" \")) {\n                    stringRep = `<${type.__name__}>\"${val}\"`;\n                }\n                else {\n                    stringRep = `${type.__name__}.${val}`;\n                }\n            }\n            else {\n                throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n            }\n        }\n        else {\n            if (type.__name__ === \"std::str\") {\n                skipCast = true;\n            }\n            stringRep = JSON.stringify(val);\n        }\n    }\n    else if (typeof val === \"number\") {\n        if (numericalTypes[type.__name__]) {\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Unknown numerical type: ${type.__name__}!`);\n        }\n        stringRep = `${val.toString()}`;\n    }\n    else if (typeof val === \"boolean\") {\n        stringRep = `${val.toString()}`;\n        skipCast = true;\n    }\n    else if (typeof val === \"bigint\") {\n        stringRep = `${val.toString()}n`;\n    }\n    else if (Array.isArray(val)) {\n        skipCast = val.length !== 0;\n        if (isArrayType(type)) {\n            stringRep = `[${val\n                .map(el => literalToEdgeQL(type.__element__, el))\n                .join(\", \")}]`;\n        }\n        else if (isTupleType(type)) {\n            stringRep = `( ${val\n                .map((el, j) => literalToEdgeQL(type.__items__[j], el))\n                .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else if (val instanceof Date) {\n        stringRep = `'${val.toISOString()}'`;\n    }\n    else if (val instanceof LocalDate ||\n        val instanceof LocalDateTime ||\n        val instanceof LocalTime ||\n        val instanceof Duration ||\n        val instanceof RelativeDuration ||\n        val instanceof DateDuration) {\n        stringRep = `'${val.toString()}'`;\n    }\n    else if (val instanceof Buffer) {\n        stringRep = bufferToStringRep(val);\n        skipCast = true;\n    }\n    else if (val instanceof Range) {\n        const elType = type.__element__;\n        const elTypeName = elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n        return `std::range(${val.lower === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.lower)}, ${val.upper === null\n            ? `<${elTypeName}>{}`\n            : literalToEdgeQL(elType, val.upper)}, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n    }\n    else if (typeof val === \"object\") {\n        if (isNamedTupleType(type)) {\n            stringRep = `( ${Object.entries(val).map(([key, value]) => `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`)} )`;\n            skipCast = true;\n        }\n        else {\n            throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n        }\n    }\n    else {\n        throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);\n    }\n    if (skipCast) {\n        return stringRep;\n    }\n    return `<${type.__name__}>${stringRep}`;\n}\nfunction indent(str, depth) {\n    return str\n        .split(\"\\n\")\n        .map(line => \" \".repeat(depth) + line)\n        .join(\"\\n\");\n}\nfunction q(ident, allowBacklinks = true) {\n    if (!ident ||\n        ident.startsWith(\"@\") ||\n        (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))) {\n        return ident;\n    }\n    const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n    if (isAlphaNum) {\n        const lident = ident.toLowerCase();\n        const isReserved = lident !== \"__type__\" &&\n            lident !== \"__std__\" &&\n            reservedKeywords.includes(lident);\n        if (!isReserved) {\n            return ident;\n        }\n    }\n    return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\nfunction bufferToStringRep(buf) {\n    let stringRep = \"\";\n    for (const byte of buf) {\n        if (byte < 32 || byte > 126) {\n            switch (byte) {\n                case 8:\n                    stringRep += \"\\\\b\";\n                    break;\n                case 9:\n                    stringRep += \"\\\\t\";\n                    break;\n                case 10:\n                    stringRep += \"\\\\n\";\n                    break;\n                case 12:\n                    stringRep += \"\\\\f\";\n                    break;\n                case 13:\n                    stringRep += \"\\\\r\";\n                    break;\n                default:\n                    stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n            }\n        }\n        else {\n            stringRep +=\n                (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n        }\n    }\n    return `b'${stringRep}'`;\n}\nfunction getErrorHint(expr) {\n    let literalConstructor = null;\n    switch (typeof expr) {\n        case \"string\":\n            literalConstructor = \"e.str()\";\n            break;\n        case \"number\":\n            literalConstructor = Number.isInteger(expr)\n                ? \"e.int64()\"\n                : \"e.float64()\";\n            break;\n        case \"bigint\":\n            literalConstructor = \"e.bigint()\";\n            break;\n        case \"boolean\":\n            literalConstructor = \"e.bool()\";\n            break;\n    }\n    switch (true) {\n        case expr instanceof Date:\n            literalConstructor = \"e.datetime()\";\n            break;\n        case expr instanceof Duration:\n            literalConstructor = \"e.duration()\";\n            break;\n        case expr instanceof LocalDate:\n            literalConstructor = \"e.cal.local_date()\";\n            break;\n        case expr instanceof LocalDateTime:\n            literalConstructor = \"e.cal.local_datetime()\";\n            break;\n        case expr instanceof LocalTime:\n            literalConstructor = \"e.cal.local_time()\";\n            break;\n        case expr instanceof RelativeDuration:\n            literalConstructor = \"e.cal.relative_duration()\";\n            break;\n        case expr instanceof DateDuration:\n            literalConstructor = \"e.cal.date_duration()\";\n            break;\n    }\n    return literalConstructor\n        ? `\\nHint: Maybe you meant to wrap the value in ` +\n            `a '${literalConstructor}' expression?`\n        : \"\";\n}\n"},{"path":"update.mjs","content":"import { ExpressionKind, } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify, $getScopedExpr } from \"./path.mjs\";\nimport { $existingScopes, $handleModifiers, } from \"./select.mjs\";\nimport { $normaliseInsertShape } from \"./insert.mjs\";\nexport function update(expr, shape) {\n    const cleanScopedExprs = $existingScopes.size === 0;\n    const scope = $getScopedExpr(expr, $existingScopes);\n    const resolvedShape = shape(scope);\n    if (cleanScopedExprs) {\n        $existingScopes.clear();\n    }\n    const mods = {};\n    let updateShape;\n    for (const [key, val] of Object.entries(resolvedShape)) {\n        if (key === \"filter\") {\n            mods[key] = val;\n        }\n        else if (key === \"set\") {\n            updateShape = val;\n        }\n        else {\n            throw new Error(`Invalid update shape key '${key}', only 'filter', ` +\n                `and 'set' are allowed`);\n        }\n    }\n    if (!updateShape) {\n        throw new Error(`Update shape must contain 'set' shape`);\n    }\n    const { modifiers, cardinality } = $handleModifiers(mods, expr);\n    return $expressionify({\n        __kind__: ExpressionKind.Update,\n        __element__: expr.__element__,\n        __cardinality__: cardinality,\n        __expr__: expr,\n        __shape__: $normaliseInsertShape(expr, updateShape, true),\n        __modifiers__: modifiers,\n        __scope__: scope,\n    });\n}\n"},{"path":"with.mjs","content":"import { ExpressionKind } from \"edgedb/dist/reflection/index.js\";\nimport { $expressionify } from \"./path.mjs\";\nexport function alias(expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.Alias,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __expr__: expr,\n    });\n}\nfunction _with(refs, expr) {\n    return $expressionify({\n        __kind__: ExpressionKind.With,\n        __element__: expr.__element__,\n        __cardinality__: expr.__cardinality__,\n        __refs__: refs,\n        __expr__: expr,\n    });\n}\nexport { _with as with };\n"},{"path":"cast.d.ts","content":"import { Expression, ExpressionKind, BaseType, TypeSet, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { orScalarLiteral } from \"../castMaps\";\nexport declare function cast<Target extends BaseType>(target: Target, arg: null): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport declare function cast<Target extends BaseType, Expr extends TypeSet>(target: Target, expr: orScalarLiteral<Expr>): $expr_Cast<Target, Expr>;\nexport declare type $expr_Cast<Target extends BaseType = BaseType, Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Target;\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Cast;\n    __expr__: Expr | null;\n}>;\n"},{"path":"casting.d.ts","content":"import type { ArrayType, BaseType, BaseTypeTuple, BaseTypeToTsType, cardinalityUtil, Cardinality, EnumType, LinkDesc, NamedTupleType, ObjectType, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, TupleType, TypeSet, RangeType } from \"edgedb/dist/reflection/index\";\nimport type { scalarCastableFrom, scalarAssignableBy } from \"../castMaps\";\nexport declare type anonymizeObject<T extends ObjectType> = ObjectType<string, T[\"__pointers__\"], any>;\ndeclare type assignableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? assignableBy<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type assignableBy<T extends BaseType> = T extends ScalarType ? scalarAssignableBy<T> : T extends ObjectType ? anonymizeObject<T> : T extends EnumType ? T : T extends ArrayType ? ArrayType<assignableBy<T[\"__element__\"]>> : T extends TupleType ? TupleType<assignableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n}> : T extends RangeType ? RangeType<scalarAssignableBy<T[\"__element__\"]> extends ScalarType ? scalarAssignableBy<T[\"__element__\"]> : never> : never;\nexport declare type pointerToAssignmentExpression<Pointer extends PropertyDesc | LinkDesc, IsSetModifier extends boolean = false> = setToAssignmentExpression<TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>, IsSetModifier>;\nexport declare type setToAssignmentExpression<Set extends TypeSet, IsSetModifier extends boolean> = [Set] extends [PrimitiveTypeSet] ? TypeSet<assignableBy<Set[\"__element__\"]>, cardinalityUtil.assignable<Set[\"__cardinality__\"]>> | getAssignmentLiteral<Set, IsSetModifier> : [Set] extends [ObjectTypeSet] ? TypeSet<ObjectType<string, Set[\"__element__\"][\"__pointers__\"]>, cardinalityUtil.assignable<cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">>> : never;\ndeclare type getAssignmentLiteral<Set extends PrimitiveTypeSet, IsSetModifier extends boolean> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType ? TsType | (Set[\"__cardinality__\"] extends Cardinality.Many ? TsType[] : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne ? IsSetModifier extends true ? TsType[] : [TsType, ...TsType[]] : never) : never;\ndeclare type castableTuple<Items extends BaseTypeTuple> = {\n    [k in keyof Items]: Items[k] extends BaseType ? castableFrom<Items[k]> : never;\n} extends infer NewItems ? NewItems extends BaseTypeTuple ? NewItems : never : never;\nexport declare type castableFrom<T extends BaseType> = T extends ScalarType ? scalarCastableFrom<T> : T extends ObjectType ? anonymizeObject<T> : T extends ArrayType ? ArrayType<castableFrom<T[\"__element__\"]>> : T extends TupleType ? TupleType<castableTuple<T[\"__items__\"]>> : T extends NamedTupleType ? NamedTupleType<{\n    [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n}> : never;\nexport declare type pointerToCastableExpression<Pointer extends PropertyDesc | LinkDesc> = [Pointer] extends [PropertyDesc] ? {\n    __element__: castableFrom<Pointer[\"target\"]>;\n    __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n} : [Pointer] extends [LinkDesc] ? TypeSet<ObjectType<string, Pointer[\"target\"][\"__pointers__\"]>, cardinalityUtil.assignable<Pointer[\"cardinality\"]>> : never;\nexport {};\n"},{"path":"collections.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, ArrayType, BaseType, cardinalityUtil, ExpressionRoot, getPrimitiveBaseType, NamedTupleShape, NamedTupleType, NonArrayType, TupleType, TypeSet, typeutil } from \"edgedb/dist/reflection/index\";\nimport type { getCardsFromExprs } from \"./set\";\nimport { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral, scalarLiterals } from \"../castMaps\";\nexport declare function $arrayLikeIndexify(_expr: ExpressionRoot): any;\nexport declare function array<Element extends NonArrayType>(element: Element): ArrayType<Element>;\nexport declare function array<Expr extends TypeSet<NonArrayType> | scalarLiterals, Exprs extends orScalarLiteral<TypeSet<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>>[]>(arg: [Expr, ...Exprs]): $expr_Array<ArrayType<Expr extends TypeSet ? getPrimitiveBaseType<Expr[\"__element__\"]> : getPrimitiveBaseType<literalToScalarType<Expr>>>, cardinalityUtil.multiplyCardinalitiesVariadic<getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>>>;\nexport declare function $tuplePathify(expr: ExpressionRoot): ExpressionRoot;\nexport declare function tuple<Items extends typeutil.tupleOf<BaseType>>(items: Items): TupleType<Items>;\nexport declare function tuple<Item extends TypeSet | scalarLiterals, Items extends typeutil.tupleOf<TypeSet | scalarLiterals>>(items: Items): $expr_Tuple<Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never>;\nexport declare function tuple<Shape extends NamedTupleShape>(shape: Shape): NamedTupleType<Shape>;\nexport declare function tuple<Shape extends {\n    [k: string]: TypeSet | scalarLiterals;\n}>(shape: Shape): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport type { ArrayType as $Array, NamedTupleType as $NamedTuple, TupleType as $Tuple, } from \"edgedb/dist/reflection/index\";\n"},{"path":"detached.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nexport declare function detached<Expr extends TypeSet>(expr: Expr): $expr_Detached<Expr>;\nexport declare type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Detached;\n    __expr__: Expr;\n}>;\n"},{"path":"external.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport { literal } from \"./literal\";\nexport {} from \"./path\";\nexport { set } from \"./set\";\nexport { cast } from \"./cast\";\nexport { ASC, DESC, EMPTY_FIRST, EMPTY_LAST, is, delete, select, } from \"./select\";\nexport { update } from \"./update\";\nexport { insert } from \"./insert\";\nexport { array, tuple } from \"./collections\";\nexport {} from \"./funcops\";\nexport { for } from \"./for\";\nexport { alias, with } from \"./with\";\nexport { optional, params } from \"./params\";\nexport { detached } from \"./detached\";\nexport {} from \"./toEdgeQL\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.d.ts","content":"import { Expression, BaseType, BaseTypeSet, Cardinality, ExpressionKind, cardinalityUtil } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_For<IterSet extends BaseTypeSet = BaseTypeSet, Expr extends Expression = Expression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: cardinalityUtil.multiplyCardinalities<IterSet[\"__cardinality__\"], Expr[\"__cardinality__\"]>;\n    __kind__: ExpressionKind.For;\n    __iterSet__: IterSet;\n    __forVar__: $expr_ForVar;\n    __expr__: Expr;\n}>;\nexport declare type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n    __element__: Type;\n    __cardinality__: Cardinality.One;\n    __kind__: ExpressionKind.ForVar;\n}>;\ndeclare function _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(set: IteratorSet, expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr): $expr_For<IteratorSet, Expr>;\nexport { _for as for };\n"},{"path":"funcops.d.ts","content":"import { BaseType, BaseTypeSet, Cardinality, introspect } from \"edgedb/dist/reflection/index\";\ninterface OverloadFuncArgDef {\n    typeId: string;\n    optional?: boolean;\n    setoftype?: boolean;\n    variadic?: boolean;\n}\ninterface OverloadFuncDef {\n    kind?: string;\n    args: OverloadFuncArgDef[];\n    namedArgs?: {\n        [key: string]: OverloadFuncArgDef;\n    };\n    returnTypeId: string;\n    returnTypemod?: \"SetOfType\" | \"OptionalType\";\n    preservesOptionality?: boolean;\n}\nexport declare function $resolveOverload(funcName: string, args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {\n    kind?: string | undefined;\n    returnType: BaseType;\n    cardinality: Cardinality;\n    args: BaseTypeSet[];\n    namedArgs: {\n        [key: string]: BaseTypeSet;\n    };\n};\nexport {};\n"},{"path":"globals.d.ts","content":"import { Expression, ExpressionKind, BaseType, Cardinality } from \"edgedb/dist/reflection/index\";\nexport declare function makeGlobal<Name extends string, Type extends BaseType, Card extends Cardinality>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card>;\nexport declare type $expr_Global<Name extends string = string, Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{\n    __name__: Name;\n    __element__: Type;\n    __cardinality__: Card;\n    __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.d.ts","content":"import type { Expression, ObjectType, ObjectTypeSet, TypeSet, BaseType, $scopify, PropertyDesc, LinkDesc } from \"edgedb/dist/reflection/index\";\nimport { Cardinality, ExpressionKind } from \"edgedb/dist/reflection/index\";\nimport type { $FreeObjectλShape, $str } from \"../modules/std\";\nimport type { normaliseShape, objectTypeToSelectShape } from \"./select\";\ndeclare type SingletonSet = Expression<TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>>;\ndeclare type SimpleGroupElements = {\n    [k: string]: SingletonSet;\n};\ndeclare type GroupModifiers = {\n    by: SimpleGroupElements;\n};\ndeclare type NestedGroupElements = {\n    [k: string]: SingletonSet | GroupingSet;\n};\nexport declare type GroupingSet = {\n    __kind__: \"groupingset\";\n    __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n    __elements__: NestedGroupElements;\n    __exprs__: [string, SingletonSet][];\n};\nexport declare function isGroupingSet(arg: any): arg is GroupingSet;\ndeclare const setFuncs: {\n    set: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    tuple: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    rollup: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n    cube: <T extends SimpleGroupElements>(grps: T) => { [k in keyof T]?: T[k] | undefined; };\n};\nexport declare type $expr_Group<Expr extends ObjectTypeSet = ObjectTypeSet, Mods extends GroupModifiers = GroupModifiers, Shape extends object = {\n    id: true;\n}> = Expression<{\n    __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape & {\n        grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n        key: LinkDesc<ObjectType<\"std::FreeObject\", {\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType ? never : PropertyDesc<Mods[\"by\"][k][\"__element__\"], Cardinality.AtMostOne>;\n        }>, Cardinality.One, {}, false, true, true, false>;\n        elements: LinkDesc<Expr[\"__element__\"], Cardinality.Many, {}, false, true, true, false>;\n    }, {\n        grouping: TypeSet<$str, Cardinality.Many>;\n        key: Expression<{\n            __element__: ObjectType<\"std::FreeObject\", $FreeObjectλShape, {\n                [k in keyof Mods[\"by\"]]: Expression<{\n                    __element__: Mods[\"by\"][k][\"__element__\"];\n                    __cardinality__: Cardinality.AtMostOne;\n                }>;\n            }>;\n            __cardinality__: Cardinality.One;\n        }>;\n        elements: Expression<{\n            __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], normaliseShape<Shape, \"by\">>;\n            __cardinality__: Cardinality.Many;\n        }>;\n    }>;\n    __cardinality__: Cardinality.Many;\n    __modifiers__: Mods;\n    __kind__: ExpressionKind.Group;\n    __expr__: Expr;\n    __scope__: ObjectTypeSet;\n}>;\ndeclare type noUndefined<T> = T extends undefined ? never : T;\ndeclare type groupFunc = <Expr extends ObjectTypeSet, Shape extends {\n    by?: SimpleGroupElements;\n} & objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>) => $expr_Group<Expr, {\n    by: noUndefined<Shape[\"by\"]>;\n}, normaliseShape<Shape, \"by\">>;\ndeclare const groupFunc: groupFunc;\nexport declare const group: typeof setFuncs & groupFunc;\nexport {};\n"},{"path":"insert.d.ts","content":"import { Cardinality, Expression, ExpressionKind, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonInsertables, typeutil, $scopify, stripSet, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport type { $expr_PathNode } from \"edgedb/dist/reflection/path\";\nimport type { $Object } from \"../modules/std\";\nimport type { scalarLiterals } from \"../castMaps\";\nexport declare type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T[\"cardinality\"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;\nexport declare type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<RawInsertShape<Root>>;\nexport declare type RawInsertShape<Root extends ObjectTypeSet> = $expr_PathNode extends Root ? never : typeutil.stripNever<stripNonInsertables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{\n    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never) | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n}> & {\n    [k in `@${string}`]: TypeSet | scalarLiterals;\n} : never : never;\ninterface UnlessConflict {\n    on: TypeSet | null;\n    else?: TypeSet;\n}\ndeclare type InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: stripSet<Root>;\n    __shape__: any;\n};\nexport declare type $expr_Insert<Root extends $expr_PathNode = $expr_PathNode> = Expression<{\n    __kind__: ExpressionKind.Insert;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Cardinality.One;\n    __expr__: Root;\n    __shape__: InsertShape<Root>;\n    unlessConflict(): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, {\n        on: null;\n    }>;\n    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict): $expr_InsertUnlessConflict<Expression<{\n        __kind__: ExpressionKind.Insert;\n        __element__: Root[\"__element__\"];\n        __cardinality__: Cardinality.One;\n        __expr__: Root;\n        __shape__: InsertShape<Root>;\n    }>, Conflict>;\n}>;\nexport declare type $expr_InsertUnlessConflict<Root extends InsertBaseExpression = InsertBaseExpression, Conflict extends UnlessConflict = UnlessConflict> = Expression<{\n    __kind__: ExpressionKind.InsertUnlessConflict;\n    __element__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"] ? Root[\"__element__\"] : $Object : Root[\"__element__\"];\n    __cardinality__: Conflict[\"else\"] extends TypeSet ? Conflict[\"else\"][\"__cardinality__\"] : Cardinality.AtMostOne;\n    __expr__: Root;\n    __conflict__: Conflict;\n}>;\nexport declare function $insertify(expr: Omit<$expr_Insert, \"unlessConflict\">): $expr_Insert;\nexport declare function $normaliseInsertShape(root: ObjectTypeSet, shape: {\n    [key: string]: any;\n}, isUpdate?: boolean): {\n    [key: string]: TypeSet | {\n        \"+=\": TypeSet;\n    } | {\n        \"-=\": TypeSet;\n    };\n};\nexport declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root>): $expr_Insert<Root>;\nexport {};\n"},{"path":"json.d.ts","content":"export declare function jsonifyComplexParams(expr: any, _args: any): any;\n"},{"path":"literal.d.ts","content":"import { BaseType, BaseTypeToTsType, ScalarType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nexport declare function literal<T extends BaseType>(type: T, value: BaseTypeToTsType<T>): $expr_Literal<T>;\nexport declare const $nameMapping: Map<string, string>;\nexport declare function $getType(id: string): (val: any) => $expr_Literal<ScalarType>;\nexport declare function $getTypeByName(name: string): (val: any) => $expr_Literal<ScalarType>;\n"},{"path":"params.d.ts","content":"import type { Executor } from \"edgedb\";\nimport { Expression, ExpressionKind, ParamType, Cardinality, setToTsType, TypeSet, BaseTypeToTsType } from \"edgedb/dist/reflection/index\";\nexport declare type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n    __kind__: ExpressionKind.OptionalParam;\n    __type__: Type;\n};\nexport declare function optional<Type extends ParamType>(type: Type): $expr_OptionalParam<Type>;\nexport declare type QueryableWithParamsExpression<Set extends TypeSet = TypeSet, Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}> = Expression<Set, false> & {\n    run(cxn: Executor, args: paramsToParamArgs<Params>): Promise<setToTsType<Set>>;\n    runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\nexport declare type $expr_WithParams<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression> = QueryableWithParamsExpression<{\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n}, Params>;\ndeclare type paramsToParamArgs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params as Params[key] extends ParamType ? key : never]: Params[key] extends ParamType ? Readonly<BaseTypeToTsType<Params[key]>> : never;\n} & {\n    [key in keyof Params as Params[key] extends $expr_OptionalParam ? key : never]?: Params[key] extends $expr_OptionalParam ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null> : never;\n};\nexport declare type $expr_Param<Name extends string | number | symbol = string, Type extends ParamType = ParamType, Optional extends boolean = boolean> = Expression<{\n    __kind__: ExpressionKind.Param;\n    __element__: Type;\n    __cardinality__: Optional extends true ? Cardinality.AtMostOne : Cardinality.One;\n    __name__: Name;\n    __isComplex__: boolean;\n}>;\ndeclare type paramsToParamExprs<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n}> = {\n    [key in keyof Params]: Params[key] extends $expr_OptionalParam ? $expr_Param<key, Params[key][\"__type__\"], true> : Params[key] extends ParamType ? $expr_Param<key, Params[key], false> : never;\n};\nexport declare function params<Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n} = {}, Expr extends Expression = Expression>(paramsDef: Params, expr: (params: paramsToParamExprs<Params>) => Expr): $expr_WithParams<Params, Expr>;\nexport {};\n"},{"path":"path.d.ts","content":"import { ObjectTypeSet, TypeSet, Expression } from \"edgedb/dist/reflection/index\";\nimport type { PathParent, $expr_PathLeaf, $expr_PathNode, $pathify, ExpressionRoot } from \"edgedb/dist/reflection/path\";\ndeclare function PathLeaf<Root extends TypeSet, Parent extends PathParent, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathLeaf<Root, Parent, Exclusive>;\ndeclare function PathNode<Root extends ObjectTypeSet, Parent extends PathParent | null, Exclusive extends boolean = boolean>(root: Root, parent: Parent, exclusive: Exclusive, scopeRoot?: TypeSet | null): $expr_PathNode<Root, Parent, Exclusive>;\ndeclare function _$pathify<Root extends TypeSet, Parent extends PathParent>(_root: Root): $pathify<Root>;\nexport declare function $jsonDestructure(_expr: ExpressionRoot): any;\nexport declare function $expressionify<T extends ExpressionRoot>(_expr: T): Expression<T>;\nexport declare function $getScopedExpr<T extends ExpressionRoot>(expr: T, existingScopes?: Set<Expression>): Expression<T>;\nexport { _$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode };\n"},{"path":"query.d.ts","content":"import type * as edgedb from \"edgedb\";\nexport declare function $queryFunc(this: any, cxn: edgedb.Executor, args: any): Promise<unknown>;\nexport declare function $queryFuncJSON(this: any, cxn: edgedb.Executor, args: any): Promise<string>;\n"},{"path":"range.d.ts","content":"import type { LocalDate, LocalDateTime, Duration } from \"edgedb\";\nimport { Range } from \"edgedb\";\nimport { RangeType, $expr_Literal, getPrimitiveBaseType, TypeSet, $expr_Function, cardinalityUtil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $number, $decimal, $datetime, $duration, $bool } from \"../modules/std\";\nimport type { $local_date, $local_datetime } from \"../modules/cal\";\nimport type { literalToScalarType, mapLiteralToTypeSet, orScalarLiteral } from \"../castMaps\";\ndeclare type $anypoint = $number | $local_date | $decimal | $datetime | $local_datetime | $duration;\ndeclare function range<Element extends $anypoint>(element: Element): RangeType<Element>;\ndeclare function range<T extends number | Date | LocalDate | LocalDateTime | Duration>(val: Range<T>): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\ndeclare function range<NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n}, P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(namedArgs: NamedArgs, lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, mapLiteralToTypeSet<NamedArgs>, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>>, cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>>>>;\ndeclare function range<P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined, P2 extends orScalarLiteral<TypeSet<BaseType extends literalToScalarType<P1> ? $anypoint : getPrimitiveBaseType<literalToScalarType<P1>>>> | undefined>(lower?: P1, upper?: P2): $expr_Function<\"std::range\", mapLiteralToTypeSet<[P1, P2]>, {}, TypeSet<RangeType<literalToScalarType<P1> extends $anypoint ? literalToScalarType<P1> : literalToScalarType<P2> extends $anypoint ? literalToScalarType<P2> : $anypoint>, cardinalityUtil.multiplyCardinalities<cardinalityUtil.optionalParamCardinality<P1>, cardinalityUtil.optionalParamCardinality<P2>>>>;\nexport { range as $range };\n"},{"path":"select.d.ts","content":"import type { $bool, $number } from \"../modules/std\";\nimport { $expr_PolyShapeElement, $scopify, Cardinality, cardinalityUtil, Expression, ExpressionKind, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PrimitiveTypeSet, PropertyDesc, ScalarType, stripSet, TypeSet, typeutil, BaseType } from \"edgedb/dist/reflection/index\";\nimport type { $expr_PathLeaf, $expr_PathNode, $linkPropify, ExpressionRoot, PathParent } from \"edgedb/dist/reflection/path\";\nimport type { anonymizeObject } from \"./casting\";\nimport type { $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport { scalarLiterals, literalToScalarType } from \"../castMaps\";\nexport declare const ASC: \"ASC\";\nexport declare const DESC: \"DESC\";\nexport declare const EMPTY_FIRST: \"EMPTY FIRST\";\nexport declare const EMPTY_LAST: \"EMPTY LAST\";\nexport declare type OrderByDirection = \"ASC\" | \"DESC\";\nexport declare type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\nexport declare type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport declare type OrderByObjExpr = {\n    expression: OrderByExpr;\n    direction?: OrderByDirection;\n    empty?: OrderByEmpty;\n};\nexport declare type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\nexport declare type OffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport declare type LimitOffsetExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type LimitExpression = TypeSet<$number, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;\nexport declare type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\nexport declare type SelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByExpression;\n    offset?: OffsetExpression | number;\n    limit?: LimitExpression | number;\n};\nexport declare type UnknownSelectModifiers = {\n    [k in keyof SelectModifiers]: unknown;\n};\nexport declare type NormalisedSelectModifiers = {\n    filter?: SelectFilterExpression;\n    order_by?: OrderByObjExpr[];\n    offset?: OffsetExpression;\n    limit?: LimitExpression;\n};\nexport declare type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: TypeSet;\n    __kind__: ExpressionKind.Select;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__?: ObjectTypeExpression;\n}>;\nexport interface SelectModifierMethods<Root extends TypeSet> {\n    filter<Filter extends SelectFilterExpression>(filter: Filter | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => Filter)): this;\n    order_by(order_by: OrderByExpression | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OrderByExpression)): this;\n    offset(offset: OffsetExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => OffsetExpression | number)): this;\n    limit(limit: LimitExpression | number | ((scope: Root extends ObjectTypeSet ? $scopify<Root[\"__element__\"]> : stripSet<Root>) => LimitExpression | number)): this;\n}\ndeclare type argCardToResultCard<OpCard extends Cardinality, BaseCase extends Cardinality> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One] ? Cardinality.AtMostOne : [OpCard] extends [Cardinality.Empty] ? Cardinality.Empty : BaseCase;\nexport declare type InferFilterCardinality<Base extends TypeSet, Filter> = Filter extends TypeSet ? Base extends ObjectTypeSet ? Filter extends $expr_Operator<\"=\", any, infer Args, any> ? Args[0] extends $expr_PathLeaf ? Args[0][\"__exclusive__\"] extends true ? typeutil.assertEqual<Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Args[0] extends $expr_PathNode<any, any, any> ? Args[0][\"__exclusive__\"] extends true ? Args[0][\"__parent__\"] extends null ? typeutil.assertEqual<Args[0][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Args[0][\"__parent__\"] extends infer Parent ? Parent extends PathParent ? typeutil.assertEqual<Parent[\"type\"][\"__element__\"][\"__name__\"], Base[\"__element__\"][\"__name__\"]> extends true ? argCardToResultCard<Args[1][\"__cardinality__\"], Base[\"__cardinality__\"]> : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"] : Base[\"__cardinality__\"];\nexport declare type InferOffsetLimitCardinality<Card extends Cardinality, Modifers extends UnknownSelectModifiers> = Modifers[\"limit\"] extends number | LimitExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Modifers[\"offset\"] extends number | OffsetExpression ? cardinalityUtil.overrideLowerBound<Card, \"Zero\"> : Card;\nexport declare type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends UnknownSelectModifiers> = InferOffsetLimitCardinality<InferFilterCardinality<Expr, Modifiers[\"filter\"]>, Modifiers>;\nexport declare function is<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>>(expr: Expr, shape: Shape): {\n    [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<Expr, normaliseElement<Shape[k]>>;\n};\nexport declare function $handleModifiers(modifiers: SelectModifiers, rootExpr: TypeSet): {\n    modifiers: NormalisedSelectModifiers;\n    cardinality: Cardinality;\n};\nexport declare type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n}>;\ndeclare function deleteExpr<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers>(expr: Expr, modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>): $expr_Delete<{\n    __element__: ObjectType<Expr[\"__element__\"][\"__name__\"], Expr[\"__element__\"][\"__pointers__\"], {\n        id: true;\n    }>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport { deleteExpr as delete };\nexport declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr;\nexport declare type linkDescToLinkProps<Desc extends LinkDesc> = {\n    [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<TypeSet<Desc[\"properties\"][k][\"target\"], Desc[\"properties\"][k][\"cardinality\"]>, {\n        type: $scopify<Desc[\"target\"]>;\n        linkName: k;\n    }, Desc[\"properties\"][k][\"exclusive\"]>;\n};\nexport declare type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<string, P, {}>;\ndeclare type linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<L[\"target\"]> & objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> & SelectModifiers;\nexport declare type linkDescToSelectElement<L extends LinkDesc> = boolean | TypeSet<anonymizeObject<L[\"target\"]>, cardinalityUtil.assignable<L[\"cardinality\"]>> | linkDescToShape<L> | ((scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>) => linkDescToShape<L>);\nexport declare type objectTypeToSelectShape<T extends ObjectType = ObjectType> = Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc ? boolean | TypeSet<T[\"__pointers__\"][k][\"target\"], cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>> : T[\"__pointers__\"][k] extends LinkDesc ? linkDescToSelectElement<T[\"__pointers__\"][k]> : any;\n}> & {\n    [k: string]: unknown;\n};\nexport declare type normaliseElement<El> = El extends boolean ? El : El extends TypeSet ? stripSet<El> : El extends (...scope: any[]) => any ? normaliseShape<ReturnType<El>> : El extends object ? normaliseShape<stripSet<El>> : stripSet<El>;\nexport declare type normaliseShape<Shape extends object, Strip = SelectModifierNames> = {\n    [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\nexport declare const $existingScopes: Set<Expression<TypeSet<BaseType, Cardinality>, true>>;\ndeclare function $shape<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers>(expr: Expr, _shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): (scope: unknown) => Readonly<Shape>;\nexport { $shape as shape };\nexport declare function select<Expr extends ObjectTypeExpression>(expr: Expr): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Expr[\"__element__\"][\"__shape__\"]>;\n    __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>>;\nexport declare function select<Expr extends ObjectTypeExpression, Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers, Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]> & $linkPropify<{\n    [k in keyof Expr]: k extends \"__cardinality__\" ? Cardinality.One : Expr[k];\n}>) => Readonly<Shape>): $expr_Select<{\n    __element__: ObjectType<`${Expr[\"__element__\"][\"__name__\"]}`, Expr[\"__element__\"][\"__pointers__\"], Omit<normaliseShape<Shape>, SelectModifierNames>>;\n    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nexport declare function select<Expr extends PrimitiveTypeSet, Modifiers extends SelectModifiers>(expr: Expr, modifiers: (expr: Expr) => Readonly<Modifiers>): $expr_Select<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: InferOffsetLimitCardinality<Expr[\"__cardinality__\"], Modifiers>;\n}>;\nexport declare function select<Shape extends {\n    [key: string]: TypeSet;\n}>(shape: Shape): $expr_Select<{\n    __element__: ObjectType<`std::FreeObject`, {\n        [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType ? LinkDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], {}, false, true, true, false> : PropertyDesc<Shape[k][\"__element__\"], Shape[k][\"__cardinality__\"], false, true, true, false>;\n    }, Shape>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function select<Expr extends scalarLiterals>(expr: Expr): $expr_Select<{\n    __element__: literalToScalarType<Expr>;\n    __cardinality__: Cardinality.One;\n}>;\nexport declare function resolveShapeElement(key: any, value: any, scope: ObjectTypeExpression): any;\n"},{"path":"set.d.ts","content":"import type { ArrayType, BaseTypeTuple, BaseType, NamedTupleType, ObjectTypeSet, TypeSet, TupleType, Expression, ExpressionKind, mergeObjectTypes, ObjectType, Cardinality, getPrimitiveBaseType, SomeType } from \"edgedb/dist/reflection/index\";\nimport * as castMaps from \"../castMaps\";\nexport declare function getSharedParent(a: SomeType, b: SomeType): SomeType;\nexport { set } from \"./setImpl\";\nexport declare type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __exprs__: Expression<Set>[];\n    __kind__: ExpressionKind.Set;\n}>;\ndeclare type mergeTypeTuples<AItems, BItems> = {\n    [k in keyof AItems]: k extends keyof BItems ? getSharedParentPrimitive<AItems[k], BItems[k]> : never;\n};\nexport declare type getSharedParentPrimitive<A, B> = A extends undefined ? B extends undefined ? undefined : B : B extends undefined ? A : A extends ArrayType<infer AEl> ? B extends ArrayType<infer BEl> ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>> : never : A extends NamedTupleType<infer AShape> ? B extends NamedTupleType<infer BShape> ? NamedTupleType<{\n    [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<AShape[k], BShape[k]>;\n}> : never : A extends TupleType<infer AItems> ? B extends TupleType<infer BItems> ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple ? TupleType<mergeTypeTuples<AItems, BItems>> : never : never : castMaps.getSharedParentScalar<A, B>;\ndeclare type _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? _getSharedParentPrimitiveVariadic<[\n    getSharedParentPrimitive<A, B>,\n    ...Rest\n]> : never;\nexport declare type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> = _getSharedParentPrimitiveVariadic<Types>;\nexport declare type LooseTypeSet<T extends any = any, C extends Cardinality = Cardinality> = {\n    __element__: T;\n    __cardinality__: C;\n};\nexport type { mergeObjectTypes };\ndeclare type _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> = Types extends [infer U] ? U : Types extends [infer A, infer B, ...infer Rest] ? A extends ObjectType ? B extends ObjectType ? mergeObjectTypes<A, B> extends BaseType ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]> : never : never : never : never;\nexport declare type mergeObjectTypesVariadic<Types extends [any, ...any[]]> = _mergeObjectTypesVariadic<Types>;\nexport declare type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? getPrimitiveBaseType<El> : never;\n};\nexport declare type getTypesFromObjectExprs<Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\nexport declare type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n    [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.d.ts","content":"import type { TypeSet, setToTsType } from \"edgedb/dist/reflection/index\";\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\nexport declare type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.d.ts","content":"import { $expr_Array, $expr_NamedTuple, $expr_Tuple, $expr_TuplePath } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Literal } from \"edgedb/dist/reflection/literal\";\nimport type { $expr_PathLeaf, $expr_PathNode, $expr_TypeIntersection } from \"edgedb/dist/reflection/path\";\nimport type { $expr_Cast } from \"./cast\";\nimport type { $expr_Detached } from \"./detached\";\nimport type { $expr_For, $expr_ForVar } from \"./for\";\nimport type { $expr_Function, $expr_Operator } from \"edgedb/dist/reflection/funcops\";\nimport type { $expr_Insert, $expr_InsertUnlessConflict } from \"./insert\";\nimport type { $expr_Param, $expr_WithParams } from \"./params\";\nimport type { $expr_Delete, $expr_Select } from \"./select\";\nimport type { $expr_Set } from \"./set\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Alias, $expr_With } from \"./with\";\nimport type { $expr_Group } from \"./group\";\nimport type { $expr_Global } from \"./globals\";\nexport declare type SomeExpression = $expr_PathNode | $expr_PathLeaf | $expr_Literal | $expr_Set | $expr_Array | $expr_Tuple | $expr_NamedTuple | $expr_TuplePath | $expr_Cast | $expr_Select | $expr_Delete | $expr_Update | $expr_Insert | $expr_InsertUnlessConflict | $expr_Function | $expr_Operator | $expr_For | $expr_ForVar | $expr_TypeIntersection | $expr_Alias | $expr_With | $expr_WithParams | $expr_Param | $expr_Detached | $expr_Group | $expr_Global;\nexport declare function $toEdgeQL(this: any): string;\n"},{"path":"update.d.ts","content":"import { Expression, ExpressionKind, ObjectTypePointers, TypeSet, ObjectTypeSet, stripBacklinks, stripNonUpdateables, typeutil, ObjectTypeExpression, $scopify, Cardinality } from \"edgedb/dist/reflection/index\";\nimport type { pointerToAssignmentExpression } from \"./casting\";\nimport { SelectModifiers, NormalisedSelectModifiers, ComputeSelectCardinality } from \"./select\";\nimport { pointerIsOptional } from \"./insert\";\nexport declare type $expr_Update<Set extends TypeSet = TypeSet, Expr extends ObjectTypeSet = ObjectTypeSet, Shape extends UpdateShape<Expr> = any> = Expression<{\n    __kind__: ExpressionKind.Update;\n    __element__: Set[\"__element__\"];\n    __cardinality__: Set[\"__cardinality__\"];\n    __expr__: Expr;\n    __shape__: Shape;\n    __modifiers__: NormalisedSelectModifiers;\n    __scope__: ObjectTypeExpression;\n}>;\nexport declare type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? {\n    [k in keyof Shape]?: (pointerToAssignmentExpression<Shape[k]> | (Shape[k][\"cardinality\"] extends Cardinality.Many | Cardinality.AtLeastOne ? {\n        \"+=\": pointerToAssignmentExpression<Shape[k], true>;\n    } | {\n        \"-=\": pointerToAssignmentExpression<Shape[k], true>;\n    } : never)) | (pointerIsOptional<Shape[k]> extends true ? undefined | null : never);\n} : never : never;\nexport declare function update<Expr extends ObjectTypeExpression, Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n}>(expr: Expr, shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>): $expr_Update<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n}, Expr, Shape[\"set\"]>;\n"},{"path":"with.d.ts","content":"import { Expression, ExpressionKind, TypeSet } from \"edgedb/dist/reflection/index\";\nimport type { $expr_Select } from \"./select\";\nimport type { $expr_For } from \"./for\";\nimport type { $expr_Insert } from \"./insert\";\nimport type { $expr_Update } from \"./update\";\nimport type { $expr_Group } from \"./group\";\nexport declare type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.Alias;\n    __expr__: Expr;\n}>;\nexport declare function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr>;\nexport declare type WithableExpression = $expr_Select | $expr_For | $expr_Insert | $expr_Update | $expr_Group;\nexport declare type $expr_With<Refs extends TypeSet[] = TypeSet[], Expr extends WithableExpression = WithableExpression> = Expression<{\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __kind__: ExpressionKind.With;\n    __expr__: Expr;\n    __refs__: Refs;\n}>;\ndeclare function _with<Refs extends Expression[], Expr extends WithableExpression>(refs: Refs, expr: Expr): $expr_With<Refs, Expr>;\nexport { _with as with };\n"}],"mts":[{"path":"cast.mts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  TypeSet,\n  Cardinality,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\nimport type {orScalarLiteral} from \"../castMaps.mjs\";\nimport {literalToTypeSet} from \"../castMaps.mjs\";\n\nexport function cast<Target extends BaseType>(\n  target: Target,\n  arg: null\n): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\n  target: Target,\n  expr: orScalarLiteral<Expr>\n): $expr_Cast<Target, Expr>;\nexport function cast(target: BaseType, expr: any) {\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\n  return $expressionify({\n    __element__: target,\n    __cardinality__:\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\n    __expr__: cleanedExpr,\n    __kind__: ExpressionKind.Cast,\n  }) as any;\n}\n\nexport type $expr_Cast<\n  Target extends BaseType = BaseType,\n  Expr extends TypeSet = TypeSet\n> = Expression<{\n  __element__: Target;\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Cast;\n  __expr__: Expr | null;\n}>;\n"},{"path":"casting.mts","content":"import type {\n  ArrayType,\n  BaseType,\n  BaseTypeTuple,\n  BaseTypeToTsType,\n  cardinalityUtil,\n  Cardinality,\n  EnumType,\n  LinkDesc,\n  NamedTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  TupleType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {\n  scalarCastableFrom,\n  scalarAssignableBy,\n} from \"../castMaps.mjs\";\n\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\n  string,\n  T[\"__pointers__\"],\n  any\n>;\n\n////////////////\n// ASSIGNABLE\n////////////////\n\ntype assignableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? assignableBy<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type assignableBy<T extends BaseType> = T extends ScalarType\n  ? scalarAssignableBy<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends EnumType\n  ? T\n  : T extends ArrayType\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n    }>\n  : T extends RangeType\n  ? RangeType<\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\n        ? scalarAssignableBy<T[\"__element__\"]>\n        : never\n    >\n  : never;\n\nexport type pointerToAssignmentExpression<\n  Pointer extends PropertyDesc | LinkDesc,\n  IsSetModifier extends boolean = false\n> = setToAssignmentExpression<\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\n  IsSetModifier\n>;\n\nexport type setToAssignmentExpression<\n  Set extends TypeSet,\n  IsSetModifier extends boolean\n> = [Set] extends [PrimitiveTypeSet]\n  ?\n      | TypeSet<\n          assignableBy<Set[\"__element__\"]>,\n          cardinalityUtil.assignable<Set[\"__cardinality__\"]>\n        >\n      | getAssignmentLiteral<Set, IsSetModifier>\n  : [Set] extends [ObjectTypeSet]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Set[\"__element__\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<\n        // Allow expressions with AtMostOne or Many cardinality in\n        // insert/update shape even when link is required since EdgeDB will\n        // assert cardinality at runtime\n        cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\n      >\n    >\n  : never;\n\ntype getAssignmentLiteral<\n  Set extends PrimitiveTypeSet,\n  IsSetModifier extends boolean\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\n  ?\n      | TsType\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\n          ? TsType[]\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\n          ? IsSetModifier extends true\n            ? TsType[]\n            : [TsType, ...TsType[]]\n          : never)\n  : never;\n\n////////////////\n// CASTABLES\n////////////////\n\ntype castableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? castableFrom<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type castableFrom<T extends BaseType> = T extends ScalarType\n  ? scalarCastableFrom<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends ArrayType\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<castableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n    }>\n  : never;\n\nexport type pointerToCastableExpression<\n  Pointer extends PropertyDesc | LinkDesc\n> = [Pointer] extends [PropertyDesc]\n  ? {\n      __element__: castableFrom<Pointer[\"target\"]>;\n      __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n    }\n  : [Pointer] extends [LinkDesc]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Pointer[\"target\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<Pointer[\"cardinality\"]>\n    >\n  : never;\n"},{"path":"collections.mts","content":"import {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  ArrayType,\n  BaseType,\n  Cardinality,\n  cardinalityUtil,\n  ExpressionKind,\n  ExpressionRoot,\n  getPrimitiveBaseType,\n  NamedTupleLiteralShape,\n  NamedTupleShape,\n  NamedTupleType,\n  NonArrayType,\n  TupleType,\n  TypeKind,\n  TypeSet,\n  typeutil,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\nimport type {getCardsFromExprs} from \"./set.mjs\";\nimport {\n  literalToScalarType,\n  literalToTypeSet,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n  scalarLiterals,\n} from \"../castMaps.mjs\";\n\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\n\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n    if (match) {\n      const start = match[1];\n      const end = match[3] ?? match[4];\n      const isIndex = start && !match[2];\n      return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__:\n          target.__element__.__kind__ === TypeKind.array && isIndex\n            ? (target.__element__ as ArrayType).__element__\n            : target.__element__,\n        __cardinality__: target.__cardinality__,\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [\n          proxy,\n          isIndex\n            ? literalToTypeSet(Number(start))\n            : [\n                start && literalToTypeSet(Number(start)),\n                end && literalToTypeSet(Number(end)),\n              ],\n        ],\n      }) as any;\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\n  const indexTypeSet = literalToTypeSet(index);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__:\n      this.__element__.__kind__ === TypeKind.array\n        ? (this.__element__ as ArrayType).__element__\n        : this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      indexTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, indexTypeSet],\n  }) as any;\n}\n\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\n  const startTypeSet = start && literalToTypeSet(start);\n  const endTypeSet = end && literalToTypeSet(end);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.multiplyCardinalities(\n        this.__cardinality__,\n        startTypeSet?.__cardinality__ ?? Cardinality.One\n      ),\n      endTypeSet?.__cardinality__ ?? Cardinality.One\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, [startTypeSet, endTypeSet]],\n  }) as any;\n}\n\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.array ||\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\n      (_expr.__element__.__name__ === \"std::str\" ||\n        _expr.__element__.__name__ === \"std::bytes\"))\n  ) {\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\n\n    expr.index = arrayLikeIndex.bind(expr);\n    expr.slice = arrayLikeSlice.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\n// ARRAY\nexport function array<Element extends NonArrayType>(\n  element: Element\n): ArrayType<Element>;\nexport function array<\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\n  Exprs extends orScalarLiteral<\n    TypeSet<\n      Expr extends TypeSet\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\n    >\n  >[]\n>(\n  arg: [Expr, ...Exprs]\n): $expr_Array<\n  ArrayType<\n    Expr extends TypeSet\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\n  >,\n  cardinalityUtil.multiplyCardinalitiesVariadic<\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\n  >\n>;\nexport function array(arg: any) {\n  if (Array.isArray(arg)) {\n    const items = arg.map(a => literalToTypeSet(a));\n    return $expressionify({\n      __kind__: ExpressionKind.Array,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(item => item.__cardinality__) as any\n      ),\n      __element__: {\n        __kind__: TypeKind.array,\n        __name__: `array<${items[0].__element__.__name__}>`,\n        __element__: items[0].__element__,\n      } as any,\n      __items__: items,\n    });\n  }\n  if (arg.__kind__) {\n    return {\n      __kind__: TypeKind.array,\n      __name__: `array<${arg.__name__}>`,\n      __element__: arg,\n    } as any;\n  }\n\n  throw new Error(\"Invalid array input.\");\n}\n\n// TUPLE\n\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const type = target.__element__;\n    const items =\n      type.__kind__ === TypeKind.tuple\n        ? (type as TupleType).__items__\n        : type.__kind__ === TypeKind.namedtuple\n        ? (type as NamedTupleType).__shape__\n        : null;\n    return items?.hasOwnProperty(prop)\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\n      : (target as any)[prop];\n  },\n};\n\nexport function $tuplePathify(expr: ExpressionRoot) {\n  if (\n    expr.__element__.__kind__ !== TypeKind.tuple &&\n    expr.__element__.__kind__ !== TypeKind.namedtuple\n  ) {\n    return expr;\n  }\n\n  return new Proxy(expr, tupleProxyHandlers);\n}\n\nfunction tuplePath(\n  parent: $expr_Tuple | $expr_TuplePath,\n  itemType: BaseType,\n  index: string\n): $expr_TuplePath {\n  return $expressionify({\n    __kind__: ExpressionKind.TuplePath,\n    __element__: itemType,\n    __cardinality__: parent.__cardinality__,\n    __parent__: parent,\n    __index__: index,\n  }) as any;\n}\n\nfunction makeTupleType(name: string, items: BaseType[]) {\n  return {\n    __kind__: TypeKind.tuple,\n    __name__: name,\n    __items__: items,\n  } as any;\n}\n\nconst typeKinds = new Set(Object.values(TypeKind));\n\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\n  items: Items\n): TupleType<Items>;\nexport function tuple<\n  Item extends TypeSet | scalarLiterals,\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\n>(\n  items: Items\n): $expr_Tuple<\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\n>;\nexport function tuple<Shape extends NamedTupleShape>(\n  shape: Shape\n): NamedTupleType<Shape>;\nexport function tuple<Shape extends {[k: string]: TypeSet | scalarLiterals}>(\n  shape: Shape\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport function tuple(input: any) {\n  if (Array.isArray(input)) {\n    // is tuple\n    if (input.every(item => typeKinds.has(item.__kind__))) {\n      const typeItems = input as BaseType[];\n      const typeName = `tuple<${typeItems\n        .map(item => item.__name__)\n        .join(\", \")}>`;\n      return makeTupleType(typeName, typeItems);\n    }\n\n    const items = input.map(item => literalToTypeSet(item));\n    const name = `tuple<${items\n      .map(item => item.__element__.__name__)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.Tuple,\n      __element__: makeTupleType(\n        name,\n        items.map(item => item.__element__)\n      ),\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(i => i.__cardinality__) as any\n      ),\n      __items__: items,\n    }) as any;\n  } else {\n    // is named tuple\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\n      const typeName = `tuple<${Object.entries(input)\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n        .join(\", \")}>`;\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: typeName,\n        __shape__: input,\n      } as any;\n    }\n\n    const exprShape: NamedTupleLiteralShape = {};\n    const typeShape: NamedTupleShape = {};\n    for (const [key, val] of Object.entries(input)) {\n      exprShape[key] = literalToTypeSet(val);\n      typeShape[key] = exprShape[key].__element__;\n    }\n    const name = `tuple<${Object.entries(exprShape)\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.NamedTuple,\n      __element__: {\n        __kind__: TypeKind.namedtuple,\n        __name__: name,\n        __shape__: typeShape,\n      } as any,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        Object.values(exprShape).map(val => val.__cardinality__) as any\n      ),\n      __shape__: exprShape,\n    }) as any;\n  }\n}\n\nexport type {\n  ArrayType as $Array,\n  NamedTupleType as $NamedTuple,\n  TupleType as $Tuple,\n} from \"edgedb/dist/reflection/index.js\";\n"},{"path":"detached.mts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\n\nexport function detached<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Detached<Expr> {\n  return $expressionify({\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n    __kind__: ExpressionKind.Detached,\n  }) as any;\n}\n\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Detached;\n  __expr__: Expr;\n}>;\n"},{"path":"external.mts","content":"import type {TypeSet, setToTsType} from \"edgedb/dist/reflection/index.js\";\n\nexport {literal} from \"./literal.mjs\";\nexport {} from \"./path.mjs\";\nexport {set} from \"./set.mjs\";\nexport {cast} from \"./cast.mjs\";\nexport {\n  ASC,\n  DESC,\n  EMPTY_FIRST,\n  EMPTY_LAST,\n  is,\n  delete,\n  select,\n} from \"./select.mjs\";\nexport {update} from \"./update.mjs\";\nexport {insert} from \"./insert.mjs\";\nexport {array, tuple} from \"./collections.mjs\";\nexport {} from \"./funcops.mjs\";\nexport {for} from \"./for.mjs\";\nexport {alias, with} from \"./with.mjs\";\nexport {optional, params} from \"./params.mjs\";\nexport {detached} from \"./detached.mjs\";\nexport {} from \"./toEdgeQL.mjs\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.mts","content":"import {\n  Expression,\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  ExpressionKind,\n  cardinalityUtil,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\n\nexport type $expr_For<\n  IterSet extends BaseTypeSet = BaseTypeSet,\n  Expr extends Expression = Expression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: cardinalityUtil.multiplyCardinalities<\n    IterSet[\"__cardinality__\"],\n    Expr[\"__cardinality__\"]\n  >;\n  __kind__: ExpressionKind.For;\n  __iterSet__: IterSet;\n  __forVar__: $expr_ForVar;\n  __expr__: Expr;\n}>;\n\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n  __element__: Type;\n  __cardinality__: Cardinality.One;\n  __kind__: ExpressionKind.ForVar;\n}>;\n\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(\n  set: IteratorSet,\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\n): $expr_For<IteratorSet, Expr> {\n  const forVar = $expressionify({\n    __kind__: ExpressionKind.ForVar,\n    __element__: set.__element__,\n    __cardinality__: Cardinality.One,\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\n\n  const returnExpr = expr(forVar);\n\n  return $expressionify({\n    __kind__: ExpressionKind.For,\n    __element__: returnExpr.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      set.__cardinality__,\n      returnExpr.__cardinality__\n    ),\n    __iterSet__: set,\n    __expr__: returnExpr,\n    __forVar__: forVar,\n  }) as any;\n}\n\nexport {_for as for};\n"},{"path":"funcops.mts","content":"import {\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  introspect,\n  makeType,\n  TypeKind,\n  ArrayType,\n  cardinalityUtil,\n  ObjectType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/dist/reflection/index.js\";\nimport {cast} from \"./cast.mjs\";\nimport {isImplicitlyCastableTo, literalToTypeSet} from \"../castMaps.mjs\";\nimport {literal} from \"./literal.mjs\";\n\ninterface OverloadFuncArgDef {\n  typeId: string;\n  optional?: boolean;\n  setoftype?: boolean;\n  variadic?: boolean;\n}\n\ninterface OverloadFuncDef {\n  kind?: string;\n  args: OverloadFuncArgDef[];\n  namedArgs?: {[key: string]: OverloadFuncArgDef};\n  returnTypeId: string;\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\n  preservesOptionality?: boolean;\n}\n\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\nfunction mapLiteralToTypeSet(literals: {[key: string]: any}): {\n  [key: string]: TypeSet;\n};\nfunction mapLiteralToTypeSet(literals: any[] | {[key: string]: any}) {\n  if (Array.isArray(literals)) {\n    return literals.map(lit => (lit != null ? literalToTypeSet(lit) : lit));\n  }\n  const obj: {[key: string]: TypeSet} = {};\n  for (const key of Object.keys(literals)) {\n    obj[key] =\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\n  }\n  return obj;\n}\n\nexport function $resolveOverload(\n  funcName: string,\n  args: any[],\n  typeSpec: introspect.Types,\n  funcDefs: OverloadFuncDef[]\n) {\n  const positionalArgs: (TypeSet | undefined)[] = [];\n  let namedArgs: {[key: string]: TypeSet} | undefined;\n  if (args.length) {\n    if (args[0] !== undefined) {\n      try {\n        positionalArgs.push(literalToTypeSet(args[0]));\n      } catch {\n        // first arg is not a expr or literal type, so assume named args object\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\n      }\n    } else {\n      positionalArgs.push(undefined);\n    }\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n  }\n\n  for (const def of funcDefs) {\n    const resolvedOverload = _tryOverload(\n      funcName,\n      positionalArgs,\n      namedArgs,\n      typeSpec,\n      def\n    );\n    if (resolvedOverload !== null) {\n      return resolvedOverload;\n    }\n  }\n\n  throw new Error(\n    `No function overload found for ${\n      funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\")[1]}()'`\n        : `operator '${funcName}'`\n    } with args: ${args.map(arg => `${arg}`).join(\", \")}`\n  );\n}\n\nconst ANYTYPE_ARG = Symbol();\n\nfunction _tryOverload(\n  funcName: string,\n  args: (BaseTypeSet | undefined)[],\n  namedArgs: {[key: string]: BaseTypeSet} | undefined,\n  typeSpec: introspect.Types,\n  funcDef: OverloadFuncDef\n): {\n  kind?: string;\n  returnType: BaseType;\n  cardinality: Cardinality;\n  args: BaseTypeSet[];\n  namedArgs: {[key: string]: BaseTypeSet};\n} | null {\n  if (\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n    (namedArgs === undefined &&\n      funcDef.namedArgs &&\n      Object.values(funcDef.namedArgs).some(arg => !arg.optional))\n  ) {\n    return null;\n  }\n\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\n    return null;\n  }\n\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [\n    Cardinality.One,\n  ];\n\n  if (namedArgs) {\n    for (const [key, value] of Object.entries(namedArgs)) {\n      const argDef = funcDef.namedArgs?.[key];\n      if (\n        !argDef ||\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\n      ) {\n        return null;\n      }\n\n      paramCardinalities.push(\n        argDef.setoftype\n          ? funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(value.__cardinality__, \"One\")\n            : Cardinality.One\n          : argDef.optional\n          ? cardinalityUtil.overrideLowerBound(value.__cardinality__, \"One\")\n          : value.__cardinality__\n      );\n    }\n  }\n\n  let positionalArgs: BaseTypeSet[] = [];\n\n  let returnAnytype: BaseType | undefined;\n  let needsAnytypeReplacement = false;\n\n  for (let i = 0; i < funcDef.args.length; i++) {\n    const argDef = funcDef.args[i];\n    const arg = args[i];\n\n    if (arg === undefined) {\n      if (!argDef.optional) {\n        return null;\n      }\n\n      if (i < args.length) {\n        // arg is explicitly undefined, inject empty set\n        const argTypeName = typeSpec.get(argDef.typeId).name;\n        if (\n          argTypeName.includes(\"anytype\") ||\n          argTypeName.includes(\"std::anypoint\")\n        ) {\n          if (!returnAnytype) {\n            positionalArgs.push(ANYTYPE_ARG as any);\n            needsAnytypeReplacement = true;\n          } else {\n            positionalArgs.push(cast(returnAnytype, null));\n          }\n        } else {\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\n          positionalArgs.push(cast(argType, null));\n        }\n      }\n    } else {\n      const {match, anytype} = compareType(\n        typeSpec,\n        argDef.typeId,\n        arg.__element__\n      );\n\n      if (!match) {\n        return null;\n      }\n      if (!returnAnytype && anytype) {\n        returnAnytype = anytype;\n      }\n\n      positionalArgs.push(\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\n      );\n      if (argDef.setoftype) {\n        paramCardinalities.push(\n          funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(arg.__cardinality__, \"One\")\n            : Cardinality.One\n        );\n      } else {\n        const card = argDef.variadic\n          ? cardinalityUtil.multiplyCardinalitiesVariadic(\n              (args.slice(i) as BaseTypeSet[]).map(\n                el => el.__cardinality__\n              ) as [Cardinality, ...Cardinality[]]\n            )\n          : arg.__cardinality__;\n\n        paramCardinalities.push(\n          argDef.optional\n            ? cardinalityUtil.overrideLowerBound(card, \"One\")\n            : card\n        );\n      }\n    }\n  }\n\n  let cardinality: Cardinality;\n  if (funcName === \"if_else\") {\n    cardinality = cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.orCardinalities(\n        positionalArgs[0].__cardinality__,\n        positionalArgs[2].__cardinality__\n      ),\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"std::assert_exists\") {\n    cardinality = cardinalityUtil.overrideLowerBound(\n      positionalArgs[0].__cardinality__,\n      \"One\"\n    );\n  } else if (funcName === \"union\") {\n    cardinality = cardinalityUtil.mergeCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"??\") {\n    cardinality = cardinalityUtil.orCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"distinct\") {\n    cardinality = positionalArgs[0].__cardinality__;\n  } else {\n    cardinality =\n      funcDef.returnTypemod === \"SetOfType\"\n        ? Cardinality.Many\n        : cardinalityUtil.multiplyCardinalitiesVariadic(paramCardinalities);\n\n    if (\n      funcDef.returnTypemod === \"OptionalType\" &&\n      !funcDef.preservesOptionality\n    ) {\n      cardinality = cardinalityUtil.overrideLowerBound(cardinality, \"Zero\");\n    }\n  }\n\n  if (needsAnytypeReplacement) {\n    if (!returnAnytype) {\n      throw new Error(`could not resolve anytype for ${funcName}`);\n    }\n    positionalArgs = positionalArgs.map(arg =>\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\n    );\n  }\n\n  return {\n    kind: funcDef.kind,\n    returnType: makeType(\n      typeSpec,\n      funcDef.returnTypeId,\n      literal,\n      returnAnytype\n    ),\n    cardinality,\n    args: positionalArgs,\n    namedArgs: namedArgs ?? {},\n  };\n}\n\nconst nameRemapping: {[key: string]: string} = {\n  \"std::int16\": \"std::number\",\n  \"std::int32\": \"std::number\",\n  \"std::int64\": \"std::number\",\n  \"std::float32\": \"std::number\",\n  \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map<string, string[]>();\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\n  if (descendantCache.has(typeId)) {\n    return descendantCache.get(typeId)!;\n  }\n  const descendants: string[] = [\n    ...new Set(\n      [...typeSpec.values()]\n        .filter(\n          type =>\n            type.kind === \"scalar\" && type.bases.some(({id}) => id === typeId)\n        )\n        .flatMap(type =>\n          type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name]\n        )\n    ),\n  ];\n  descendantCache.set(typeId, descendants);\n  return descendants;\n}\n\nfunction compareType(\n  typeSpec: introspect.Types,\n  typeId: string,\n  arg: BaseType\n): {match: boolean; anytype?: BaseType} {\n  const type = typeSpec.get(typeId);\n\n  if (type.name === \"anytype\") {\n    return {match: true, anytype: arg};\n  }\n\n  if (type.name === \"std::anypoint\") {\n    const descendants = getDescendantNames(typeSpec, typeId);\n    if (descendants.includes(arg.__name__)) {\n      return {match: true, anytype: arg};\n    }\n  }\n\n  if (type.name === \"std::anyenum\") {\n    return {match: arg.__kind__ === TypeKind.enum};\n  }\n\n  if (type.kind === \"scalar\") {\n    arg = (arg as any).__casttype__ ?? arg;\n    return {\n      match:\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\n        (arg.__name__ === type.name ||\n          isImplicitlyCastableTo(arg.__name__, type.name)),\n    };\n  }\n  if (type.kind === \"array\") {\n    if (arg.__kind__ === TypeKind.array) {\n      return compareType(\n        typeSpec,\n        type.array_element_id,\n        (arg as any as ArrayType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"range\") {\n    if (arg.__kind__ === TypeKind.range) {\n      return compareType(\n        typeSpec,\n        type.range_element_id,\n        (arg as any as RangeType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"object\") {\n    if (arg.__kind__ !== TypeKind.object) return {match: false};\n\n    const objectArg = arg as ObjectType;\n    let match = true;\n\n    // shape comparison\n    for (const ptr of type.pointers) {\n      if (objectArg.__pointers__[ptr.name]) {\n        const argPtr = objectArg.__pointers__[ptr.name];\n        const ptrTarget = typeSpec.get(ptr.target_id);\n        if (\n          ptrTarget.name !== argPtr.target.__name__ ||\n          ptr.real_cardinality !== argPtr.cardinality\n        ) {\n          match = false;\n        }\n      }\n    }\n\n    return {\n      match,\n    };\n  }\n  if (type.kind === \"tuple\") {\n    const items =\n      arg.__kind__ === TypeKind.tuple\n        ? (arg as any).__items__\n        : arg.__kind__ === TypeKind.namedtuple\n        ? (arg as any).__shape__\n        : null;\n    if (items) {\n      const keys = Object.keys(items);\n\n      if (keys.length === type.tuple_elements.length) {\n        let anytype: BaseType | undefined;\n        for (let i = 0; i < keys.length; i++) {\n          if (keys[i] !== type.tuple_elements[i].name) {\n            return {match: false};\n          }\n          const {match: m, anytype: a} = compareType(\n            typeSpec,\n            type.tuple_elements[i].target_id,\n            (items as any)[keys[i]]\n          );\n          if (!m) {\n            return {match: false};\n          }\n          if (a) anytype = a;\n        }\n        return {match: true, anytype};\n      }\n    }\n  }\n\n  return {match: false};\n}\n"},{"path":"globals.mts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  Cardinality,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\n\nexport function makeGlobal<\n  Name extends string,\n  Type extends BaseType,\n  Card extends Cardinality\n>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card> {\n  return $expressionify({\n    __name__: name,\n    __element__: type,\n    __cardinality__: card,\n    __kind__: ExpressionKind.Global,\n  });\n}\n\nexport type $expr_Global<\n  Name extends string = string,\n  Type extends BaseType = BaseType,\n  Card extends Cardinality = Cardinality\n> = Expression<{\n  __name__: Name;\n  __element__: Type;\n  __cardinality__: Card;\n  __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.mts","content":"import type {\n  Expression,\n  ObjectType,\n  ObjectTypeSet,\n  TypeSet,\n  BaseType,\n  $scopify,\n  PropertyDesc,\n  LinkDesc,\n  // stripSet,\n  // LinkDesc,\n} from \"edgedb/dist/reflection/index.js\";\nimport {\n  Cardinality,\n  ExpressionKind,\n  TypeKind,\n  makeType,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify, $getScopedExpr} from \"./path.mjs\";\n// @ts-ignore\nimport type {$FreeObjectλShape, $str} from \"../modules/std.mjs\";\nimport {spec} from \"../__spec__.mjs\";\nimport {literal} from \"./literal.mjs\";\nimport {resolveShapeElement} from \"./select.mjs\";\nimport type {\n  normaliseShape,\n  // normaliseElement,\n  objectTypeToSelectShape,\n} from \"./select.mjs\";\n\ntype SingletonSet = Expression<\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\n>;\ntype SimpleGroupElements = {[k: string]: SingletonSet};\ntype GroupModifiers = {by: SimpleGroupElements};\ntype NestedGroupElements = {\n  [k: string]: SingletonSet | GroupingSet;\n};\n\nexport type GroupingSet = {\n  __kind__: \"groupingset\";\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n  __elements__: NestedGroupElements;\n  __exprs__: [string, SingletonSet][];\n};\nexport function isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// result is partial to prevent \"X is specified more than once\" errors\n// the return type is a lie, this function returns a grouping set\n// but it pretends to return a SimpleGroupElements\n// to make the static computatation of `key` easier\nconst makeGroupingSet =\n  (prefix: string) =>\n  <T extends SimpleGroupElements>(grps: T): {[k in keyof T]?: T[k]} => {\n    const seenKeys = new Map<string, SingletonSet>();\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\n      ([k, grp]) =>\n        isGroupingSet(grp)\n          ? grp.__exprs__\n          : ([[k, grp]] as [string, SingletonSet][])\n    );\n    const filtered = unfiltered.filter(([k, expr]) => {\n      if (!seenKeys.has(k)) {\n        seenKeys.set(k, expr);\n        return true;\n      }\n\n      if (expr !== seenKeys.get(k)) {\n        throw new Error(\n          `Cannot override pre-existing expression with key \"${k}\"`\n        );\n      }\n\n      return false;\n    });\n\n    return {\n      [`${Math.round(1000000 * Math.random())}___`]: {\n        __kind__: \"groupingset\",\n        __settype__: prefix,\n        __elements__: grps,\n        __exprs__: filtered,\n      } as GroupingSet,\n    } as any;\n  };\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\n\nconst setFuncs = {set, tuple, rollup, cube};\n\nexport type $expr_Group<\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Mods extends GroupModifiers = GroupModifiers,\n  Shape extends object = {id: true}\n> = Expression<{\n  __element__: ObjectType<\n    \"std::FreeObject\",\n    $FreeObjectλShape & {\n      // adding free shape elements into __pointers__\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\n      // and setToTsType can't handle that currently\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n      key: LinkDesc<\n        ObjectType<\n          \"std::FreeObject\",\n          {\n            // tslint:disable-next-line\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\n              ? never\n              : PropertyDesc<\n                  Mods[\"by\"][k][\"__element__\"],\n                  Cardinality.AtMostOne\n                >;\n          }\n        >,\n        Cardinality.One,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n      elements: LinkDesc<\n        Expr[\"__element__\"],\n        Cardinality.Many,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n    },\n    {\n      // grouping: true;\n      // key: {[k in keyof Mods['by']]: true};\n      // elements: {id: true};\n      grouping: TypeSet<$str, Cardinality.Many>;\n      key: Expression<{\n        __element__: ObjectType<\n          \"std::FreeObject\",\n          $FreeObjectλShape,\n          {\n            [k in keyof Mods[\"by\"]]: Expression<{\n              __element__: Mods[\"by\"][k][\"__element__\"];\n              __cardinality__: Cardinality.AtMostOne;\n            }>;\n          }\n        >;\n        __cardinality__: Cardinality.One;\n      }>;\n      elements: Expression<{\n        __element__: ObjectType<\n          Expr[\"__element__\"][\"__name__\"],\n          Expr[\"__element__\"][\"__pointers__\"],\n          // Omit<normaliseShape<Shape>, \"by\">\n          normaliseShape<Shape, \"by\">\n        >;\n        __cardinality__: Cardinality.Many;\n      }>;\n    }\n  >;\n  __cardinality__: Cardinality.Many;\n  // bit of a lie, this is a GroupingSet at runtime\n  __modifiers__: Mods;\n  __kind__: ExpressionKind.Group;\n  __expr__: Expr;\n  __scope__: ObjectTypeSet;\n}>;\n\n// type modifierKeys = \"by\";\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <\n  Expr extends ObjectTypeSet,\n  // Shape extends GroupModifiers\n  // Grps extends SimpleGroupElements,\n  Shape extends {by?: SimpleGroupElements} & objectTypeToSelectShape<\n    Expr[\"__element__\"]\n  >\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\n>(\n  expr: Expr,\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n) => $expr_Group<\n  Expr,\n  {by: noUndefined<Shape[\"by\"]>},\n  normaliseShape<Shape, \"by\">\n>;\n\nconst groupFunc: groupFunc = (expr, getter) => {\n  const {shape, scope, modifiers} = resolveShape(getter, expr);\n  // const scope = $getScopedExpr(expr as any);\n  // const rawGroupings = getter(scope);\n  const groupSet = tuple(modifiers.by);\n\n  // only one key in object returned from makeGroupingSet\n  const key = Object.keys(groupSet)[0];\n  const grouping = groupSet[key] as any as GroupingSet;\n  const keyShape: any = {};\n  const keyPointers: any = {};\n  const keyShapeElement: any = {};\n\n  for (const [k, e] of grouping.__exprs__) {\n    keyShape[k] = $expressionify({\n      __element__: e.__element__,\n      __cardinality__: Cardinality.AtMostOne,\n    } as any);\n    keyPointers[k] = {\n      __kind__: \"property\",\n      target: e.__element__,\n      cardinality: Cardinality.AtMostOne,\n      exclusive: false,\n      computed: false,\n      readonly: false,\n      hasDefault: false,\n    } as PropertyDesc;\n    keyShapeElement[k] = true;\n  }\n\n  const $FreeObject = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n    literal\n  );\n\n  const str = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::str\")!.id,\n    literal\n  );\n\n  return $expressionify({\n    __element__: {\n      ...$FreeObject,\n      __name__: \"std::FreeObject\",\n      __pointers__: {\n        ...($FreeObject as any).__pointers__,\n        __name__: \"std::FreeObject\",\n        grouping: {\n          __kind__: \"property\",\n          target: str,\n          cardinality: Cardinality.Many,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as PropertyDesc,\n        key: {\n          __kind__: \"link\",\n          target: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n              ...($FreeObject as any).__pointers__,\n              ...keyPointers,\n            },\n            __shape__: keyShape,\n          },\n          properties: {},\n          cardinality: Cardinality.One,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n\n        elements: {\n          __kind__: \"link\",\n          target: expr.__element__,\n          cardinality: Cardinality.Many,\n          properties: {},\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n      },\n      __shape__: {\n        grouping: $expressionify({\n          __element__: str,\n          __cardinality__: Cardinality.Many,\n        } as any),\n        key: $expressionify({\n          __element__: {\n            ...$FreeObject,\n            __shape__: keyShape,\n          },\n          __cardinality__: Cardinality.One,\n        } as any),\n        elements: $expressionify({\n          __element__: {...expr.__element__, __shape__: shape} as any,\n          __cardinality__: Cardinality.Many,\n        } as any),\n      },\n    },\n\n    __cardinality__: Cardinality.Many,\n    __expr__: expr,\n    __modifiers__: {by: grouping},\n    __kind__: ExpressionKind.Group,\n    __scope__: scope,\n  }) as any;\n};\nObject.assign(groupFunc, setFuncs);\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: {by: SimpleGroupElements}; shape: any; scope: TypeSet} {\n  const modifiers: {by: SimpleGroupElements} = {} as any;\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (key === \"by\") {\n      modifiers[key] = value as any;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  if (Object.keys(shape).length === 0) {\n    shape.id = true;\n  }\n  if (!modifiers.by) {\n    throw new Error(\"Must provide a `by` key in `e.group`\");\n  }\n  return {shape, modifiers, scope};\n}\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\n"},{"path":"insert.mts","content":"import {\n  Cardinality,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  ObjectTypeSet,\n  ObjectTypePointers,\n  PropertyDesc,\n  stripBacklinks,\n  stripNonInsertables,\n  typeutil,\n  $scopify,\n  stripSet,\n  TypeSet,\n  TypeKind,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {pointerToAssignmentExpression} from \"./casting.mjs\";\nimport {$expressionify, $getScopedExpr} from \"./path.mjs\";\nimport {cast} from \"./cast.mjs\";\nimport {set} from \"./set.mjs\";\nimport {literal} from \"./literal.mjs\";\nimport {$getTypeByName} from \"./literal.mjs\";\nimport type {$expr_PathNode} from \"edgedb/dist/reflection/path.js\";\nimport type {$Object} from \"../modules/std.mjs\";\nimport type {scalarLiterals} from \"../castMaps.mjs\";\n\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\n  T[\"cardinality\"] extends\n    | Cardinality.Many\n    | Cardinality.Empty\n    | Cardinality.AtMostOne\n    ? true\n    : false;\n\nexport type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<\n  RawInsertShape<Root>\n>;\n\nexport type RawInsertShape<Root extends ObjectTypeSet> =\n  // short-circuit infinitely deep\n  $expr_PathNode extends Root\n    ? never\n    : typeutil.stripNever<\n        stripNonInsertables<\n          stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>\n        >\n      > extends infer Shape\n    ? Shape extends ObjectTypePointers\n      ? typeutil.addQuestionMarks<{\n          [k in keyof Shape]:\n            | pointerToAssignmentExpression<Shape[k]>\n            | (pointerIsOptional<Shape[k]> extends true\n                ? undefined | null\n                : never)\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n        }> & {[k in `@${string}`]: TypeSet | scalarLiterals}\n      : never\n    : never;\n\ninterface UnlessConflict {\n  on: TypeSet | null;\n  else?: TypeSet;\n}\n\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: stripSet<Root>;\n  __shape__: any;\n};\nexport type $expr_Insert<\n  Root extends $expr_PathNode = $expr_PathNode\n  // Conflict = UnlessConflict | null\n  // Shape extends InsertShape<Root> = any\n> = Expression<{\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: Root;\n  __shape__: InsertShape<Root>;\n\n  unlessConflict(): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    {on: null}\n  >;\n  unlessConflict<Conflict extends UnlessConflict>(\n    conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict\n  ): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    Conflict\n  >;\n}>;\n\nexport type $expr_InsertUnlessConflict<\n  Root extends InsertBaseExpression = InsertBaseExpression,\n  Conflict extends UnlessConflict = UnlessConflict\n> = Expression<{\n  __kind__: ExpressionKind.InsertUnlessConflict;\n  __element__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"]\n      ? Root[\"__element__\"]\n      : $Object\n    : Root[\"__element__\"];\n  __cardinality__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__cardinality__\"]\n    : Cardinality.AtMostOne;\n  __expr__: Root;\n  __conflict__: Conflict;\n}>;\n\nfunction unlessConflict(\n  this: $expr_Insert,\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\n) {\n  const expr: any = {\n    __kind__: ExpressionKind.InsertUnlessConflict,\n    __element__: this.__element__,\n    __cardinality__: Cardinality.AtMostOne,\n    __expr__: this,\n    // __conflict__: Conflict;\n  };\n\n  if (!conflictGetter) {\n    expr.__conflict__ = {on: null};\n    return $expressionify(expr);\n  } else {\n    const scopedExpr = $getScopedExpr(this.__expr__);\n    const conflict = conflictGetter(scopedExpr);\n    expr.__conflict__ = conflict;\n    if (conflict.else) {\n      expr.__cardinality__ = conflict.else.__cardinality__;\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n        expr.__element__ = $getTypeByName(\"std::Object\");\n      }\n    }\n    return $expressionify(expr);\n  }\n}\n\nexport function $insertify(\n  expr: Omit<$expr_Insert, \"unlessConflict\">\n): $expr_Insert {\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\n  return expr as any;\n}\n\nexport function $normaliseInsertShape(\n  root: ObjectTypeSet,\n  shape: {[key: string]: any},\n  isUpdate: boolean = false\n): {[key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet}} {\n  const newShape: {\n    [key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet};\n  } = {};\n  for (const [key, _val] of Object.entries(shape)) {\n    let val = _val;\n    let setModify: string | null = null;\n    if (isUpdate && _val != null && typeof _val === \"object\") {\n      const valKeys = Object.keys(_val);\n      if (\n        valKeys.length === 1 &&\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\n      ) {\n        val = _val[valKeys[0]];\n        setModify = valKeys[0];\n      }\n    }\n\n    const pointer = root.__element__.__pointers__[key];\n\n    // no pointer, not a link property\n    const isLinkProp = key[0] === \"@\";\n    if (!pointer && !isLinkProp) {\n      throw new Error(\n        `Could not find property pointer for ${\n          isUpdate ? \"update\" : \"insert\"\n        } shape key: '${key}'`\n      );\n    }\n\n    // skip undefined vals\n    if (val === undefined) continue;\n\n    // is val is expression, assign to newShape\n    if (val?.__kind__) {\n      // ranges can contain null values, so if the type is 'std::number'\n      // we need to set the type to the exact number type of the pointer\n      // so null casts are correct\n      if (\n        val.__kind__ === ExpressionKind.Literal &&\n        val.__element__.__kind__ === TypeKind.range &&\n        val.__element__.__element__.__name__ === \"std::number\"\n      ) {\n        newShape[key] = (literal as any)(pointer.target, val.__value__);\n      } else {\n        newShape[key] = _val;\n      }\n      continue;\n    }\n\n    // handle link props\n    // after this guard, pointer definitely is defined\n    if (isLinkProp) {\n      throw new Error(\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\n      );\n    }\n\n    // trying to assign plain data to a link\n    if (pointer.__kind__ !== \"property\" && val !== null) {\n      throw new Error(\n        `Must provide subquery when assigning to link '${key}' in ${\n          isUpdate ? \"update\" : \"insert\"\n        } query.`\n      );\n    }\n\n    // val is plain data\n    // key corresponds to pointer or starts with \"@\"\n    const isMulti =\n      pointer.cardinality === Cardinality.AtLeastOne ||\n      pointer.cardinality === Cardinality.Many;\n    if (pointer.__kind__ === \"property\") {\n      if (pointer.target.__name__ === \"std::json\") {\n      }\n    }\n\n    const wrappedVal =\n      val === null\n        ? cast(pointer.target, null)\n        : isMulti && Array.isArray(val)\n        ? val.length === 0\n          ? cast(pointer.target, null)\n          : set(...val.map(v => (literal as any)(pointer.target, v)))\n        : (literal as any)(pointer.target, val);\n    newShape[key] = setModify\n      ? ({[setModify]: wrappedVal} as any)\n      : wrappedVal;\n  }\n  return newShape;\n}\n\nexport function insert<Root extends $expr_PathNode>(\n  root: Root,\n  shape: InsertShape<Root>\n): $expr_Insert<Root> {\n  if (typeof shape !== \"object\") {\n    throw new Error(\n      `invalid insert shape.${\n        typeof shape === \"function\"\n          ? \" Hint: Insert shape is expected to be an object, \" +\n            \"not a function returning a shape object.\"\n          : \"\"\n      }`\n    );\n  }\n  const expr: any = {\n    __kind__: ExpressionKind.Insert,\n    __element__: root.__element__,\n    __cardinality__: Cardinality.One,\n    __expr__: root,\n    __shape__: $normaliseInsertShape(root, shape),\n  };\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\n  return $expressionify($insertify(expr)) as any;\n}\n"},{"path":"json.mts","content":"import {ExpressionKind, ParamType, TypeKind} from \"edgedb/dist/reflection/index.js\";\nimport type {$expr_WithParams} from \"./params.mjs\";\n\nfunction jsonStringify(type: ParamType, val: any): string {\n  if (type.__kind__ === TypeKind.array) {\n    if (Array.isArray(val)) {\n      return `[${val\n        .map(item => jsonStringify(type.__element__, item))\n        .join()}]`;\n    }\n    throw new Error(`Param with array type is not an array`);\n  }\n  if (type.__kind__ === TypeKind.tuple) {\n    if (!Array.isArray(val)) {\n      throw new Error(`Param with tuple type is not an array`);\n    }\n    if (val.length !== type.__items__.length) {\n      throw new Error(\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\n      );\n    }\n    return `[${val\n      .map((item, i) => jsonStringify(type.__items__[i], item))\n      .join()}]`;\n  }\n  if (type.__kind__ === TypeKind.namedtuple) {\n    if (typeof val !== \"object\") {\n      throw new Error(`Param with named tuple type is not an object`);\n    }\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n      throw new Error(\n        `Param with named tuple type has incorrect number of items. Got ${\n          Object.keys(val).length\n        } expected ${Object.keys(type.__shape__).length}`\n      );\n    }\n    return `{${Object.entries(val)\n      .map(([key, item]) => {\n        if (!type.__shape__[key]) {\n          throw new Error(\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\n              type.__shape__\n            ).join()}`\n          );\n        }\n        return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n      })\n      .join()}}`;\n  }\n  if (\n    type.__kind__ === TypeKind.scalar\n    // || type.__kind__ === TypeKind.castonlyscalar\n  ) {\n    switch (type.__name__) {\n      case \"std::bigint\":\n        return val.toString();\n      case \"std::json\":\n        return JSON.stringify(val);\n      case \"std::bytes\":\n        return `\"${val.toString(\"base64\")}\"`;\n      case \"cfg::memory\":\n        return `\"${val.toString()}\"`;\n      default:\n        return JSON.stringify(val);\n    }\n  }\n  if (type.__kind__ === TypeKind.enum) {\n    return JSON.stringify(val);\n  }\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\n}\n\nexport function jsonifyComplexParams(expr: any, _args: any) {\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\n    const args = {..._args};\n    for (const param of (expr as $expr_WithParams).__params__) {\n      if (param.__isComplex__) {\n        args[param.__name__] = jsonStringify(\n          param.__element__ as any,\n          args[param.__name__]\n        );\n      }\n    }\n\n    return args;\n  }\n  return _args;\n}\n"},{"path":"literal.mts","content":"import {\n  Cardinality,\n  ExpressionKind,\n  BaseType,\n  BaseTypeToTsType,\n  makeType,\n  ScalarType,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {$expr_Literal} from \"edgedb/dist/reflection/literal.js\";\nimport {$expressionify} from \"./path.mjs\";\nimport {spec} from \"../__spec__.mjs\";\n\nexport function literal<T extends BaseType>(\n  type: T,\n  value: BaseTypeToTsType<T>\n): $expr_Literal<T> {\n  return $expressionify({\n    __element__: type,\n    __cardinality__: Cardinality.One,\n    __kind__: ExpressionKind.Literal,\n    __value__: value,\n  }) as any;\n}\n\nexport const $nameMapping = new Map<string, string>([\n  ...([...spec.values()].map(type => [type.name, type.id]) as any),\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\n\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, id, literal) as any;\n}\n\nexport function $getTypeByName(\n  name: string\n): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\n}\n"},{"path":"params.mts","content":"import type {Executor} from \"edgedb\";\nimport {\n  Expression,\n  ExpressionKind,\n  ParamType,\n  Cardinality,\n  setToTsType,\n  TypeSet,\n  TypeKind,\n  BaseTypeToTsType,\n} from \"edgedb/dist/reflection/index.js\";\nimport {$expressionify} from \"./path.mjs\";\n\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n  __kind__: ExpressionKind.OptionalParam;\n  __type__: Type;\n};\n\nexport function optional<Type extends ParamType>(\n  type: Type\n): $expr_OptionalParam<Type> {\n  return {\n    __kind__: ExpressionKind.OptionalParam,\n    __type__: type,\n  };\n}\n\nexport type QueryableWithParamsExpression<\n  Set extends TypeSet = TypeSet,\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {}\n> = Expression<Set, false> & {\n  run(\n    cxn: Executor,\n    args: paramsToParamArgs<Params>\n  ): Promise<setToTsType<Set>>;\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\n\nexport type $expr_WithParams<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n> = QueryableWithParamsExpression<\n  {\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n  },\n  Params\n>;\n\ntype paramsToParamArgs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params as Params[key] extends ParamType\n    ? key\n    : never]: Params[key] extends ParamType\n    ? Readonly<BaseTypeToTsType<Params[key]>>\n    : never;\n} & {\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\n    ? key\n    : never]?: Params[key] extends $expr_OptionalParam\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null>\n    : never;\n};\n\nexport type $expr_Param<\n  Name extends string | number | symbol = string,\n  Type extends ParamType = ParamType,\n  Optional extends boolean = boolean\n> = Expression<{\n  __kind__: ExpressionKind.Param;\n  __element__: Type;\n  __cardinality__: Optional extends true\n    ? Cardinality.AtMostOne\n    : Cardinality.One;\n  __name__: Name;\n  __isComplex__: boolean;\n}>;\n\ntype paramsToParamExprs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\n    : Params[key] extends ParamType\n    ? $expr_Param<key, Params[key], false>\n    : never;\n};\n\nconst complexParamKinds = new Set([TypeKind.tuple, TypeKind.namedtuple]);\n\nexport function params<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n>(\n  paramsDef: Params,\n  expr: (params: paramsToParamExprs<Params>) => Expr\n): $expr_WithParams<Params, Expr> {\n  const paramExprs: {[key: string]: $expr_Param} = {};\n  for (const [key, param] of Object.entries(paramsDef)) {\n    const paramType =\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\n    const isComplex =\n      complexParamKinds.has(paramType.__kind__) ||\n      (paramType.__kind__ === TypeKind.array &&\n        complexParamKinds.has(paramType.__element__.__kind__));\n    paramExprs[key] = $expressionify({\n      __kind__: ExpressionKind.Param,\n      __element__: paramType,\n      __cardinality__:\n        param.__kind__ === ExpressionKind.OptionalParam\n          ? Cardinality.AtMostOne\n          : Cardinality.One,\n      __name__: key,\n      __isComplex__: isComplex,\n    }) as any;\n  }\n\n  const returnExpr = expr(paramExprs as any);\n\n  return $expressionify({\n    __kind__: ExpressionKind.WithParams,\n    __element__: returnExpr.__element__,\n    __cardinality__: returnExpr.__cardinality__,\n    __expr__: returnExpr,\n    __params__: Object.values(paramExprs),\n  }) as any;\n}\n"},{"path":"path.mts","content":"import {\n  cardinalityUtil,\n  ObjectTypeSet,\n  TypeSet,\n  Expression,\n  ExpressionKind,\n  TypeKind,\n  LinkDesc,\n  PropertyDesc,\n  Cardinality,\n  BaseType,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {\n  PathParent,\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $pathify,\n  ExpressionRoot,\n} from \"edgedb/dist/reflection/path.js\";\nimport {literalToTypeSet} from \"../castMaps.mjs\";\nimport {$arrayLikeIndexify, $tuplePathify} from \"./collections.mjs\";\nimport {$toEdgeQL} from \"./toEdgeQL.mjs\";\nimport {$queryFunc, $queryFuncJSON} from \"./query.mjs\";\n\nfunction PathLeaf<\n  Root extends TypeSet,\n  Parent extends PathParent,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathLeaf<Root, Parent, Exclusive> {\n  return $expressionify({\n    __kind__: ExpressionKind.PathLeaf,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  }) as any;\n}\n\nfunction PathNode<\n  Root extends ObjectTypeSet,\n  Parent extends PathParent | null,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathNode<Root, Parent, Exclusive> {\n  const obj = {\n    __kind__: ExpressionKind.PathNode,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  };\n\n  const shape: any = {};\n  Object.entries(obj.__element__.__pointers__).map(([key, ptr]) => {\n    if (ptr.__kind__ === \"property\") {\n      shape[key] = true;\n    }\n  });\n  Object.defineProperty(obj, \"*\", {\n    writable: false,\n    value: shape,\n  });\n  return $expressionify(obj) as any;\n}\n\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\n\nconst pathifyProxyHandlers: ProxyHandler<any> = {\n  get(target: any, prop: string | symbol, proxy: any) {\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\n    if (ptr) {\n      return (\n        target[_pathCache][prop] ??\n        (target[_pathCache][prop] = (\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\n        )(\n          {\n            __element__: ptr.target,\n            __cardinality__: cardinalityUtil.multiplyCardinalities(\n              target.__cardinality__,\n              ptr.cardinality\n            ),\n          },\n          {\n            linkName: prop,\n            type: proxy,\n          },\n          ptr.exclusive ?? false,\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\n        ))\n      );\n    }\n    return target[prop];\n  },\n};\n\nfunction _$pathify<Root extends TypeSet, Parent extends PathParent>(\n  _root: Root\n): $pathify<Root> {\n  if (_root.__element__.__kind__ !== TypeKind.object) {\n    return _root as any;\n  }\n\n  const root: $expr_PathNode<ObjectTypeSet, Parent> = _root as any;\n\n  let pointers = {\n    ...root.__element__.__pointers__,\n  };\n\n  if (root.__parent__) {\n    const {type, linkName} = root.__parent__;\n    const parentPointer = type.__element__.__pointers__[linkName];\n    if (parentPointer?.__kind__ === \"link\") {\n      pointers = {...pointers, ...parentPointer.properties};\n    }\n  }\n\n  for (const [key, val] of Object.entries(\n    root.__element__.__shape__ || {id: true}\n  )) {\n    if (pointers[key]) continue;\n    const valType: BaseType = (val as any)?.__element__;\n    if (!valType) continue;\n\n    pointers[key] = {\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\n      properties: {},\n      target: (val as any).__element__,\n      cardinality: (val as any).__cardinality__,\n      exclusive: false,\n      computed: true,\n      readonly: true,\n      hasDefault: false,\n    };\n  }\n\n  (root as any)[_pointers] = pointers;\n  (root as any)[_pathCache] = {};\n\n  return new Proxy(root, pathifyProxyHandlers);\n}\n\nfunction isFunc(this: any, expr: ObjectTypeSet) {\n  return $expressionify({\n    __kind__: ExpressionKind.TypeIntersection,\n    __cardinality__: this.__cardinality__,\n    __element__: {\n      ...expr.__element__,\n      __shape__: {id: true},\n    } as any,\n    __expr__: this,\n  });\n}\n\nfunction assert_single(expr: Expression) {\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: expr.__element__,\n    __cardinality__: cardinalityUtil.overrideUpperBound(\n      expr.__cardinality__,\n      \"One\"\n    ),\n    __name__: \"std::assert_single\",\n    __args__: [expr],\n    __namedargs__: {},\n  }) as any;\n}\n\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    if (typeof prop === \"string\" && !(prop in target)) {\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n      return jsonDestructure.call(proxy, parsedProp);\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\n  const pathTypeSet = literalToTypeSet(path);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      pathTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, pathTypeSet],\n  }) as any;\n}\n\nexport function $jsonDestructure(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.scalar &&\n    _expr.__element__.__name__ === \"std::json\"\n  ) {\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\n\n    expr.destructure = jsonDestructure.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\nexport function $expressionify<T extends ExpressionRoot>(\n  _expr: T\n): Expression<T> {\n  const expr: Expression = _$pathify(\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\n  ) as any;\n\n  expr.run = $queryFunc.bind(expr) as any;\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\n  expr.is = isFunc.bind(expr) as any;\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\n  expr.assert_single = () => assert_single(expr) as any;\n\n  return Object.freeze(expr) as any;\n}\n\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\nconst scopeRoots = new WeakSet<Expression>();\n\nexport function $getScopedExpr<T extends ExpressionRoot>(\n  expr: T,\n  existingScopes?: Set<Expression>\n): Expression<T> {\n  let scopedExpr = scopedExprCache.get(expr);\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\n    // free objects should not be scopified\n    const isFreeObject =\n      expr.__cardinality__ === Cardinality.One &&\n      expr.__element__.__name__ === \"std::FreeObject\";\n\n    const isInsert = expr.__kind__ === ExpressionKind.Insert;\n    scopedExpr =\n      isFreeObject || isInsert\n        ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\n        : $expressionify({\n            ...expr,\n            __cardinality__: Cardinality.One,\n            __scopedFrom__: expr,\n            \"*\": (expr as any)[\"*\"],\n          });\n    scopeRoots.add(scopedExpr);\n    const uncached = !scopedExpr;\n    if (uncached) {\n      scopedExprCache.set(expr, scopedExpr);\n    }\n  }\n  existingScopes?.add(scopedExpr);\n  return scopedExpr as any;\n}\n\nexport {_$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode};\n"},{"path":"query.mts","content":"import type * as edgedb from \"edgedb\";\nimport {Cardinality, ExpressionKind} from \"edgedb/dist/reflection/index.js\";\nimport {jsonifyComplexParams} from \"./json.mjs\";\nimport {select} from \"./select.mjs\";\n\nconst runnableExpressionKinds = new Set([\n  ExpressionKind.Select,\n  ExpressionKind.Update,\n  ExpressionKind.Insert,\n  ExpressionKind.InsertUnlessConflict,\n  ExpressionKind.Delete,\n  ExpressionKind.Group,\n  ExpressionKind.For,\n  ExpressionKind.With,\n  ExpressionKind.WithParams,\n]);\n\nconst wrappedExprCache = new WeakMap();\n\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n\n  const _args = jsonifyComplexParams(expr, args);\n\n  const query = expr.toEdgeQL();\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne ||\n    expr.__cardinality__ === Cardinality.Empty\n  ) {\n    return cxn.querySingle(query, _args);\n  } else {\n    return cxn.query(query, _args);\n  }\n}\n\nexport async function $queryFuncJSON(\n  this: any,\n  cxn: edgedb.Executor,\n  args: any\n) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n  const _args = jsonifyComplexParams(expr, args);\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne\n  ) {\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n  } else {\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\n  }\n}\n"},{"path":"range.mts","content":"import type {LocalDate, LocalDateTime, Duration} from \"edgedb\";\nimport {Range} from \"edgedb\";\nimport {\n  RangeType,\n  $expr_Literal,\n  TypeKind,\n  getPrimitiveBaseType,\n  TypeSet,\n  $expr_Function,\n  cardinalityUtil,\n  BaseType,\n  ExpressionKind,\n} from \"edgedb/dist/reflection/index.js\";\n\nimport type {\n  $number,\n  $decimal,\n  $datetime,\n  $duration,\n  $bool,\n} from \"../modules/std.mjs\";\nimport type {$local_date, $local_datetime} from \"../modules/cal.mjs\";\nimport type {\n  literalToScalarType,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n} from \"../castMaps.mjs\";\nimport {literalToTypeSet} from \"../castMaps.mjs\";\nimport {spec} from \"../__spec__.mjs\";\nimport {literal, $nameMapping} from \"./literal.mjs\";\nimport {$resolveOverload} from \"./funcops.mjs\";\nimport {$expressionify} from \"./path.mjs\";\n\ntype $anypoint =\n  | $number\n  | $local_date\n  | $decimal\n  | $datetime\n  | $local_datetime\n  | $duration;\n\nfunction range<Element extends $anypoint>(\n  element: Element\n): RangeType<Element>;\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\n  val: Range<T>\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\nfunction range<\n  NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n  },\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  namedArgs: NamedArgs,\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  mapLiteralToTypeSet<NamedArgs>,\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.multiplyCardinalities<\n        cardinalityUtil.multiplyCardinalities<\n          cardinalityUtil.multiplyCardinalities<\n            cardinalityUtil.optionalParamCardinality<P1>,\n            cardinalityUtil.optionalParamCardinality<P2>\n          >,\n          cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\n        >,\n        cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\n      >,\n      cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>\n    >\n  >\n>;\nfunction range<\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  {},\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.optionalParamCardinality<P1>,\n      cardinalityUtil.optionalParamCardinality<P2>\n    >\n  >\n>;\nfunction range(...args: any[]): any {\n  if (args.length === 1) {\n    const arg = args[0];\n    if (arg instanceof Range) {\n      if (arg.lower === null && arg.upper === null) {\n        throw new Error(\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\n        );\n      }\n      if (arg.isEmpty) {\n        throw new Error(`Can't create literal expression from empty range.`);\n      }\n      return literal(\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\n        arg\n      );\n    }\n    if (arg.__kind__ && !arg.__element__) {\n      return {\n        __kind__: TypeKind.range,\n        __name__: `range<${arg.__name__}>`,\n        __element__: arg,\n      } as any;\n    }\n  }\n  const {\n    returnType,\n    cardinality,\n    args: positionalArgs,\n    namedArgs,\n  } = $resolveOverload(\"std::range\", args, spec, [\n    {\n      args: [\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      ],\n      namedArgs: {\n        inc_lower: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        inc_upper: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        empty: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      },\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\n    },\n  ]);\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: returnType,\n    __cardinality__: cardinality,\n    __name__: \"std::range\",\n    __args__: positionalArgs,\n    __namedargs__: namedArgs,\n  }) as any;\n}\n\nexport {range as $range};\n"},{"path":"select.mts","content":"import {\n  LocalDateTime,\n  LocalDate,\n  LocalTime,\n  Duration,\n  RelativeDuration,\n  ConfigMemory,\n  DateDuration,\n} from \"edgedb\";\nimport type {$bool, $number} from \"../modules/std.mjs\";\nimport {\n  $expr_PolyShapeElement,\n  $scopify,\n  Cardinality,\n  cardinalityUtil,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  makeType,\n  ObjectType,\n  ObjectTypeExpression,\n  ObjectTypePointers,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  stripSet,\n  TypeKind,\n  TypeSet,\n  typeutil,\n  BaseType,\n} from \"edgedb/dist/reflection/index.js\";\n\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $linkPropify,\n  ExpressionRoot,\n  PathParent,\n} from \"edgedb/dist/reflection/path.js\";\nimport type {anonymizeObject} from \"./casting.mjs\";\nimport type {$expr_Operator} from \"edgedb/dist/reflection/funcops.js\";\nimport {$expressionify, $getScopedExpr} from \"./path.mjs\";\nimport {$getTypeByName, literal} from \"./literal.mjs\";\nimport {spec} from \"../__spec__.mjs\";\nimport {\n  scalarLiterals,\n  literalToScalarType,\n  literalToTypeSet,\n} from \"../castMaps.mjs\";\n\nexport const ASC: \"ASC\" = \"ASC\";\nexport const DESC: \"DESC\" = \"DESC\";\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\n\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n  expression: OrderByExpr;\n  direction?: OrderByDirection;\n  empty?: OrderByEmpty;\n};\n\nexport type OrderByExpression =\n  | OrderByExpr\n  | OrderByObjExpr\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\n\nexport type OffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\nexport type LimitExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\n\nexport type SelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByExpression;\n  offset?: OffsetExpression | number;\n  limit?: LimitExpression | number;\n};\n\nexport type UnknownSelectModifiers = {[k in keyof SelectModifiers]: unknown};\n\nexport type NormalisedSelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByObjExpr[];\n  offset?: OffsetExpression;\n  limit?: LimitExpression;\n};\n\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\n//   Mods extends OrderByExpr\n//     ? [{expression: Mods}]\n//     : Mods extends OrderByObjExpr\n//     ? [Mods]\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\n//     ? {\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\n//           ? {expression: Mods[K]}\n//           : Mods[K];\n//       }\n//     : [];\n\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\n//   filter: Mods[\"filter\"];\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\n//     : [];\n//   offset: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n//   limit: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n// };\n\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: TypeSet;\n  __kind__: ExpressionKind.Select;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__?: ObjectTypeExpression;\n}>;\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n// & SelectModifierMethods<stripSet<Set>>;\n\nexport interface SelectModifierMethods<Root extends TypeSet> {\n  filter<Filter extends SelectFilterExpression>(\n    filter:\n      | Filter\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => Filter)\n  ): this;\n  order_by(\n    order_by:\n      | OrderByExpression\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OrderByExpression)\n  ): this;\n  offset(\n    offset:\n      | OffsetExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OffsetExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n  limit(\n    limit:\n      | LimitExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => LimitExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n}\n// Base is ObjectTypeSet &\n// Filter is equality &\n// Filter.args[0] is PathLeaf\n//   Filter.args[0] is __exclusive__ &\n//   Filter.args[0].parent.__element__ === Base.__element__\n//   Filter.args[1].__cardinality__ is AtMostOne or One\n// if Filter.args[0] is PathNode:\n//   Filter.args[0] is __exclusive__ &\n//   if Filter.args[0].parent === null\n//     Filter.args[0].parent.__element__ === Base.__element__\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n//   else\n//     Filter.args[0].type.__element__ === Base.__element__ &\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n\ntype argCardToResultCard<\n  OpCard extends Cardinality,\n  BaseCase extends Cardinality\n> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\n  ? Cardinality.AtMostOne\n  : [OpCard] extends [Cardinality.Empty]\n  ? Cardinality.Empty\n  : BaseCase;\n\nexport type InferFilterCardinality<\n  Base extends TypeSet,\n  Filter\n> = Filter extends TypeSet\n  ? // Base is ObjectTypeExpression &\n    Base extends ObjectTypeSet // $expr_PathNode\n    ? // Filter is equality\n      Filter extends $expr_Operator<\"=\", any, infer Args, any>\n      ? // Filter.args[0] is PathLeaf\n        Args[0] extends $expr_PathLeaf\n        ? // Filter.args[0] is unique\n          Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            typeutil.assertEqual<\n              Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\n              Base[\"__element__\"][\"__name__\"]\n            > extends true\n            ? // Filter.args[1].__cardinality__ is AtMostOne or One\n              argCardToResultCard<\n                Args[1][\"__cardinality__\"],\n                Base[\"__cardinality__\"]\n              >\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Args[0] extends $expr_PathNode<any, any, any>\n        ? Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            Args[0][\"__parent__\"] extends null\n            ? typeutil.assertEqual<\n                Args[0][\"__element__\"][\"__name__\"],\n                Base[\"__element__\"][\"__name__\"]\n              > extends true\n              ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                argCardToResultCard<\n                  Args[1][\"__cardinality__\"],\n                  Base[\"__cardinality__\"]\n                >\n              : Base[\"__cardinality__\"]\n            : Args[0][\"__parent__\"] extends infer Parent\n            ? Parent extends PathParent\n              ? typeutil.assertEqual<\n                  Parent[\"type\"][\"__element__\"][\"__name__\"],\n                  Base[\"__element__\"][\"__name__\"]\n                > extends true\n                ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                  argCardToResultCard<\n                    Args[1][\"__cardinality__\"],\n                    Base[\"__cardinality__\"]\n                  >\n                : Base[\"__cardinality__\"]\n              : Base[\"__cardinality__\"]\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Base[\"__cardinality__\"]\n      : Base[\"__cardinality__\"]\n    : Base[\"__cardinality__\"]\n  : Base[\"__cardinality__\"];\n\nexport type InferOffsetLimitCardinality<\n  Card extends Cardinality,\n  Modifers extends UnknownSelectModifiers\n> = Modifers[\"limit\"] extends number | LimitExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Modifers[\"offset\"] extends number | OffsetExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Card;\n\nexport type ComputeSelectCardinality<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends UnknownSelectModifiers\n> = InferOffsetLimitCardinality<\n  InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\n  Modifiers\n>;\n\nexport function is<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\n>(\n  expr: Expr,\n  shape: Shape\n): {\n  [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<\n    Expr,\n    normaliseElement<Shape[k]>\n  >;\n} {\n  const mappedShape: any = {};\n  for (const [key, value] of Object.entries(shape)) {\n    mappedShape[key] = {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: expr,\n      __shapeElement__: value,\n    };\n  }\n  return mappedShape;\n}\n\nfunction computeFilterCardinality(\n  expr: SelectFilterExpression,\n  cardinality: Cardinality,\n  base: TypeSet\n) {\n  let card = cardinality;\n\n  const filter: any = expr;\n  // Base is ObjectExpression\n  const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\n  const filterExprIsEq =\n    filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\n  const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\n  const arg1: TypeSet = filter?.__args__?.[1];\n  const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\n  const arg0IsUnique = arg0?.__exclusive__ === true;\n\n  if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\n    const newCard =\n      arg1.__cardinality__ === Cardinality.One ||\n      arg1.__cardinality__ === Cardinality.AtMostOne\n        ? Cardinality.AtMostOne\n        : arg1.__cardinality__ === Cardinality.Empty\n        ? Cardinality.Empty\n        : cardinality;\n\n    if (arg0.__kind__ === ExpressionKind.PathLeaf) {\n      const arg0ParentMatchesBase =\n        arg0.__parent__.type.__element__.__name__ ===\n        base.__element__.__name__;\n      if (arg0ParentMatchesBase) {\n        card = newCard;\n      }\n    } else if (arg0.__kind__ === ExpressionKind.PathNode) {\n      // if Filter.args[0] is PathNode:\n      //   Filter.args[0] is __exclusive__ &\n      //   if Filter.args[0].parent === null\n      //     Filter.args[0].__element__ === Base.__element__\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      //   else\n      //     Filter.args[0].type.__element__ === Base.__element__ &\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      const parent = arg0.__parent__;\n      if (parent === null) {\n        const arg0MatchesBase =\n          arg0.__element__.__name__ === base.__element__.__name__;\n        if (arg0MatchesBase) {\n          card = newCard;\n        }\n      } else {\n        const arg0ParentMatchesBase =\n          parent?.type.__element__.__name__ === base.__element__.__name__;\n        if (arg0ParentMatchesBase) {\n          card = newCard;\n        }\n      }\n    }\n  }\n\n  return card;\n}\n\nexport function $handleModifiers(\n  modifiers: SelectModifiers,\n  rootExpr: TypeSet\n): {modifiers: NormalisedSelectModifiers; cardinality: Cardinality} {\n  const mods = {...modifiers};\n  let card = rootExpr.__cardinality__;\n\n  if (mods.filter && rootExpr.__element__.__kind__ === TypeKind.object) {\n    card = computeFilterCardinality(mods.filter, card, rootExpr);\n  }\n  if (mods.order_by) {\n    const orderExprs = Array.isArray(mods.order_by)\n      ? mods.order_by\n      : [mods.order_by];\n    mods.order_by = orderExprs.map(expr =>\n      typeof (expr as any).__element__ === \"undefined\"\n        ? expr\n        : {expression: expr}\n    ) as any;\n  }\n  if (mods.offset) {\n    mods.offset =\n      typeof mods.offset === \"number\"\n        ? ($getTypeByName(\"std::number\")(mods.offset) as any)\n        : mods.offset;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n  if (mods.limit) {\n    let expr = mods.limit;\n    if (typeof expr === \"number\") {\n      expr = $getTypeByName(\"std::number\")(expr) as any;\n    } else if ((expr as any).__kind__ === ExpressionKind.Set) {\n      expr = (expr as any).__exprs__[0];\n    }\n    mods.limit = expr;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n\n  return {modifiers: mods as NormalisedSelectModifiers, cardinality: card};\n}\n\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\n  Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n  }>;\n\nfunction deleteExpr<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\n): $expr_Delete<{\n  __element__: ObjectType<\n    Expr[\"__element__\"][\"__name__\"],\n    Expr[\"__element__\"][\"__pointers__\"],\n    {id: true}\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nfunction deleteExpr(expr: any, modifiersGetter: any) {\n  const selectExpr = select(expr, modifiersGetter);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Delete,\n    __element__: selectExpr.__element__,\n    __cardinality__: selectExpr.__cardinality__,\n    __expr__: selectExpr,\n  }) as any;\n}\n\nexport {deleteExpr as delete};\n\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n\n// function resolveModifierGetter(parent: any, modGetter: any) {\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\n//       const shape = parent.__element__.__shape__;\n//       const _scope =\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\n//           $existingScopes);\n//       const scope = new Proxy(_scope, {\n//         get(target: any, prop: string) {\n//           if (shape[prop] && shape[prop] !== true) {\n//             return shape[prop];\n//           }\n//           return target[prop];\n//         },\n//       });\n//       return {\n//         scope: _scope,\n//         modExpr: modGetter(scope),\n//       };\n//     } else {\n//       return {\n//         scope: undefined,\n//         modExpr: modGetter(parent.__expr__),\n//       };\n//     }\n//   } else {\n//     return {scope: parent.__scope__, modExpr: modGetter};\n//   }\n// }\n\n// function updateModifier(\n//   parent: any,\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\n//   modGetter: any\n// ) {\n//   const modifiers = {\n//     ...parent.__modifiers__,\n//   };\n//   const cardinality = parent.__cardinality__;\n\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\n\n//   switch (modName) {\n//     case \"filter\":\n//       modifiers.filter = modifiers.filter\n//         ? op(modifiers.filter, \"and\", modExpr)\n//         : modExpr;\n\n//       // methods no longer change cardinality\n//       // cardinality = computeFilterCardinality(\n//       //   modExpr,\n//       //   cardinality,\n//       //   parent.__expr__\n//       // );\n//       break;\n//     case \"order_by\":\n//       const ordering =\n//         typeof (modExpr as any).__element__ === \"undefined\"\n//           ? modExpr\n//           : {expression: modExpr};\n//       modifiers.order_by = modifiers.order_by\n//         ? [...modifiers.order_by, ordering]\n//         : [ordering];\n//       break;\n//     case \"offset\":\n//       modifiers.offset =\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//     case \"limit\":\n//       modifiers.limit =\n//         typeof modExpr === \"number\"\n//           ? _std.number(modExpr)\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\n//           ? (modExpr as any).__exprs__[0]\n//           : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//   }\n\n//   return $expressionify(\n//     $selectify({\n//       __kind__: ExpressionKind.Select,\n//       __element__: parent.__element__,\n//       __cardinality__: cardinality,\n//       __expr__: parent.__expr__,\n//       __modifiers__: modifiers,\n//       __scope__: scope,\n//     })\n//   );\n// }\n\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\n  // Object.assign(expr, {\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\n  // });\n  return expr;\n}\n\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\n    TypeSet<\n      Desc[\"properties\"][k][\"target\"],\n      Desc[\"properties\"][k][\"cardinality\"]\n    >,\n    {\n      type: $scopify<Desc[\"target\"]>;\n      linkName: k;\n    },\n    Desc[\"properties\"][k][\"exclusive\"]\n  >;\n};\n\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\n  string,\n  P,\n  {}\n>;\n\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\n  L[\"target\"]\n> &\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\n  SelectModifiers;\nexport type linkDescToSelectElement<L extends LinkDesc> =\n  | boolean\n  // | pointerToCastableExpression<Shape[k]>\n  | TypeSet<\n      anonymizeObject<L[\"target\"]>,\n      cardinalityUtil.assignable<L[\"cardinality\"]>\n    >\n  | linkDescToShape<L>\n  | ((\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\n    ) => linkDescToShape<L>);\n\n// object types -> pointers\n// pointers -> links\n// links -> target object type\n// links -> link properties\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType> =\n  // ObjectType extends T\n  //   ? {[k: string]: unknown}\n  //   :\n  Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc\n      ?\n          | boolean\n          | TypeSet<\n              T[\"__pointers__\"][k][\"target\"],\n              cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>\n            >\n      : T[\"__pointers__\"][k] extends LinkDesc\n      ? linkDescToSelectElement<T[\"__pointers__\"][k]>\n      : any;\n  }> & {[k: string]: unknown};\n\n// incorporate __shape__ (computeds) on selection shapes\n// this works but a major rewrite of setToTsType is required\n// to incorporate __shape__-based selection shapes into\n// result type inference\n// & [k in keyof T[\"__shape__\"]]:\n//    string | number | symbol extends k //   Partial<{ // &\n//       ? unknown\n//       : T[\"__shape__\"][k] extends infer U\n//       ? U extends ObjectTypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 anonymizeObject<U[\"__element__\"]>,\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//             | objectTypeToSelectShape<U[\"__element__\"]>\n//             | ((\n//                 scope: $scopify<U[\"__element__\"]>\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\n//                 SelectModifiers)\n//         : U extends TypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 U[\"__element__\"],\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//         : unknown\n//       : unknown;\n//   }>\n\nexport type normaliseElement<El> = El extends boolean\n  ? El\n  : El extends TypeSet\n  ? stripSet<El>\n  : El extends (...scope: any[]) => any\n  ? normaliseShape<ReturnType<El>>\n  : El extends object\n  ? normaliseShape<stripSet<El>>\n  : stripSet<El>;\n\nexport type normaliseShape<\n  Shape extends object,\n  Strip = SelectModifierNames\n> = {\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\n\nconst $FreeObject = makeType(\n  spec,\n  [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n  literal\n);\nconst FreeObject: $expr_PathNode = {\n  __kind__: ExpressionKind.PathNode,\n  __element__: $FreeObject as any,\n  __cardinality__: Cardinality.One,\n  __parent__: null,\n  __exclusive__: true,\n  __scopeRoot__: null,\n} as any;\n\nexport const $existingScopes = new Set<\n  Expression<TypeSet<BaseType, Cardinality>>\n>();\n\nfunction $shape<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers\n>(\n  expr: Expr,\n  _shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): (scope: unknown) => Readonly<Shape>;\nfunction $shape(_a: unknown, b: (...args: any) => any) {\n  return b;\n}\nexport {$shape as shape};\n\nexport function select<Expr extends ObjectTypeExpression>(\n  expr: Expr\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Expr[\"__element__\"][\"__shape__\"] // {id: true}\n  >;\n  __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport function select<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Select<stripSet<Expr>>;\nexport function select<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers,\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\n>(\n  expr: Expr,\n  shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Omit<normaliseShape<Shape>, SelectModifierNames>\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\n/*\n\nFor the moment is isn't possible to implement both closure-based and plain\nobject overloads without breaking autocomplete on one or the other.\nThis is due to a limitation in TS:\n\nhttps://github.com/microsoft/TypeScript/issues/26892\nhttps://github.com/microsoft/TypeScript/issues/47081\n\n*/\nexport function select<\n  Expr extends PrimitiveTypeSet,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers: (expr: Expr) => Readonly<Modifiers>\n): $expr_Select<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: InferOffsetLimitCardinality<\n    Expr[\"__cardinality__\"],\n    Modifiers\n  >;\n}>;\nexport function select<Shape extends {[key: string]: TypeSet}>(\n  shape: Shape\n): $expr_Select<{\n  __element__: ObjectType<\n    `std::FreeObject`,\n    {\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\n        ? LinkDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            {},\n            false,\n            true,\n            true,\n            false\n          >\n        : PropertyDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            false,\n            true,\n            true,\n            false\n          >;\n    },\n    Shape\n  >; // _shape\n  __cardinality__: Cardinality.One;\n}>;\nexport function select<Expr extends scalarLiterals>(\n  expr: Expr\n): $expr_Select<{\n  __element__: literalToScalarType<Expr>;\n  __cardinality__: Cardinality.One;\n}>;\nexport function select(...args: any[]) {\n  const firstArg = args[0];\n\n  if (\n    typeof firstArg !== \"object\" ||\n    firstArg instanceof Buffer ||\n    firstArg instanceof Date ||\n    firstArg instanceof Duration ||\n    firstArg instanceof LocalDateTime ||\n    firstArg instanceof LocalDate ||\n    firstArg instanceof LocalTime ||\n    firstArg instanceof RelativeDuration ||\n    firstArg instanceof DateDuration ||\n    firstArg instanceof ConfigMemory\n  ) {\n    const literalExpr = literalToTypeSet(firstArg);\n    return $expressionify(\n      $selectify({\n        __kind__: ExpressionKind.Select,\n        __element__: literalExpr.__element__,\n        __cardinality__: literalExpr.__cardinality__,\n        __expr__: literalExpr,\n        __modifiers__: {},\n      })\n    ) as any;\n  }\n\n  const exprPair: [TypeSet, (scope: any) => any] =\n    typeof args[0].__element__ !== \"undefined\"\n      ? (args as any)\n      : [FreeObject, () => args[0]];\n\n  let expr = exprPair[0];\n  const shapeGetter = exprPair[1];\n  if (expr === FreeObject) {\n    const freeObjectPtrs: ObjectTypePointers = {};\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\n      freeObjectPtrs[k] = {\n        __kind__:\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\n        target: v.__element__,\n\n        cardinality: v.__cardinality__,\n        exclusive: false,\n        computed: true,\n        readonly: true,\n        hasDefault: false,\n        properties: {},\n      };\n    }\n    expr = {\n      ...FreeObject,\n      __element__: {\n        ...FreeObject.__element__,\n        __pointers__: {\n          ...FreeObject.__element__.__pointers__,\n          ...freeObjectPtrs,\n        },\n      } as any,\n    };\n  }\n  if (!shapeGetter) {\n    if (expr.__element__.__kind__ === TypeKind.object) {\n      const objectExpr: ObjectTypeSet = expr as any;\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: {\n            __kind__: TypeKind.object,\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\n            __pointers__: objectExpr.__element__.__pointers__,\n            __shape__: objectExpr.__element__.__shape__,\n          } as any,\n          __cardinality__: objectExpr.__cardinality__,\n          __expr__: objectExpr,\n          __modifiers__: {},\n        })\n      ) as any;\n    } else {\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: expr.__element__,\n          __cardinality__: expr.__cardinality__,\n          __expr__: expr,\n          __modifiers__: {},\n        })\n      ) as any;\n    }\n  }\n\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const {modifiers: mods, shape, scope} = resolveShape(shapeGetter, expr);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n  return $expressionify(\n    $selectify({\n      __kind__: ExpressionKind.Select,\n      __element__:\n        expr.__element__.__kind__ === TypeKind.object\n          ? {\n              __kind__: TypeKind.object,\n              __name__: `${expr.__element__.__name__}`, // _shape\n              __pointers__: (expr.__element__ as ObjectType).__pointers__,\n              __shape__: shape,\n            }\n          : expr.__element__,\n      __cardinality__: cardinality,\n      __expr__: expr,\n      __modifiers__: modifiers,\n      __scope__:\n        expr !== scope // && expr.__element__.__name__ !== \"std::FreeObject\"\n          ? scope\n          : undefined,\n    })\n  ) as any;\n}\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: any; shape: any; scope: TypeSet} {\n  const modifiers: any = {};\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope =\n    expr.__element__.__kind__ === TypeKind.object\n      ? $getScopedExpr(expr as any, $existingScopes)\n      : expr;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (\n      key === \"filter\" ||\n      key === \"order_by\" ||\n      key === \"offset\" ||\n      key === \"limit\"\n    ) {\n      modifiers[key] = value;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  return {shape, modifiers, scope};\n}\n\nexport function resolveShapeElement(\n  key: any,\n  value: any,\n  scope: ObjectTypeExpression\n): any {\n  // if value is a nested closure\n  // or a nested shape object\n  const isSubshape =\n    typeof value === \"object\" &&\n    typeof (value as any).__kind__ === \"undefined\";\n  const isClosure =\n    typeof value === \"function\" &&\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\n  // if (isSubshape) {\n  //   // return value;\n  //   const childExpr = (scope as any)[key];\n  //   const {\n  //     shape: childShape,\n  //     // scope: childScope,\n  //     // modifiers: mods,\n  //   } = resolveShape(value as any, childExpr);\n  //   return childShape;\n  // }\n  if (isSubshape || isClosure) {\n    // get child node expression\n    // this relies on Proxy-based getters\n    const childExpr = (scope as any)[key];\n    if (!childExpr) {\n      throw new Error(\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\n      );\n    }\n    const {\n      shape: childShape,\n      scope: childScope,\n      modifiers: mods,\n    } = resolveShape(value as any, childExpr);\n\n    // extracts normalized modifiers\n    const {modifiers} = $handleModifiers(mods, childExpr);\n\n    return {\n      __kind__: ExpressionKind.Select,\n      __element__: {\n        __kind__: TypeKind.object,\n        __name__: `${childExpr.__element__.__name__}`,\n        __pointers__: childExpr.__element__.__pointers__,\n        __shape__: childShape,\n      },\n      __cardinality__:\n        scope.__element__.__pointers__?.[key]?.cardinality ||\n        scope.__element__.__shape__?.[key]?.__cardinality__,\n      __expr__: childExpr,\n      __modifiers__: modifiers,\n      __scope__: childExpr !== childScope ? childScope : undefined,\n    };\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\n    const polyElement = value as $expr_PolyShapeElement;\n\n    const polyScope = (scope as any).is(polyElement.__polyType__);\n    return {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: polyScope,\n      __shapeElement__: resolveShapeElement(\n        key,\n        polyElement.__shapeElement__,\n        polyScope\n      ),\n    };\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n    const linkProp = (scope as any)[key];\n    if (!linkProp) {\n      throw new Error(\n        (scope as any).__parent__\n          ? `link property '${key}' does not exist on link ${\n              (scope as any).__parent__.linkName\n            }`\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\n      );\n    }\n    return value ? linkProp : false;\n  } else {\n    return value;\n  }\n}\n"},{"path":"set.mts","content":"import type {\n  ArrayType,\n  BaseTypeTuple,\n  BaseType,\n  NamedTupleType,\n  ObjectTypeSet,\n  TypeSet,\n  TupleType,\n  Expression,\n  ExpressionKind,\n  mergeObjectTypes,\n  ObjectType,\n  Cardinality,\n  getPrimitiveBaseType,\n  SomeType,\n} from \"edgedb/dist/reflection/index.js\";\nimport {TypeKind, $mergeObjectTypes} from \"edgedb/dist/reflection/index.js\";\n\n// \"../\" path gets replaced during generation step\n// @ts-ignore\nimport * as castMaps from \"../castMaps.mjs\";\n\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\n  if (a.__kind__ !== b.__kind__) {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\n    return castMaps.getSharedParentScalar(a, b);\n  } else if (\n    a.__kind__ === TypeKind.object &&\n    b.__kind__ === TypeKind.object\n  ) {\n    return $mergeObjectTypes(a, b);\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\n    if (a.__items__.length !== b.__items__.length) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items = a.__items__.map((_, i) => {\n        if (!a.__items__[i] || !b.__items__[i]) {\n          throw new Error();\n        }\n        return getSharedParent(\n          a.__items__[i] as SomeType,\n          b.__items__[i] as SomeType\n        );\n      });\n\n      return {\n        __kind__: TypeKind.tuple,\n        __name__: `tuple<${items.map(item => item.__name__).join(\", \")}>`,\n        __items__: items as BaseTypeTuple,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (\n    a.__kind__ === TypeKind.namedtuple &&\n    b.__kind__ === TypeKind.namedtuple\n  ) {\n    const aKeys = Object.keys(a);\n    const bKeys = new Set(Object.keys(b));\n    const sameKeys =\n      aKeys.length === bKeys.size && aKeys.every(k => bKeys.has(k));\n    if (!sameKeys) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items: {[k: string]: BaseType} = {};\n      for (const [i] of Object.entries(a.__shape__)) {\n        if (!a.__shape__[i] || !b.__shape__[i]) {\n          throw new Error();\n        }\n        items[i] = getSharedParent(\n          a.__shape__[i] as SomeType,\n          b.__shape__[i] as SomeType\n        );\n      }\n\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: `tuple<${Object.entries(items)\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n          .join(\", \")}>`,\n        __shape__: items,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\n    try {\n      const mergedEl: any = getSharedParent(\n        a.__element__ as any,\n        b.__element__ as any\n      );\n      return {\n        __kind__: TypeKind.array,\n        __name__: a.__name__,\n        __element__: mergedEl,\n      } as ArrayType;\n    } catch (err) {\n      throw new Error(\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\n    if (a.__name__ === b.__name__) return a;\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  } else {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n}\n\n// @ts-ignore\nexport {set} from \"./setImpl.mjs\";\n\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __exprs__: Expression<Set>[];\n  __kind__: ExpressionKind.Set;\n}>;\n\ntype mergeTypeTuples<AItems, BItems> = {\n  [k in keyof AItems]: k extends keyof BItems\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\n    : never;\n};\n\n// find shared parent of two primitives\nexport type getSharedParentPrimitive<A, B> = A extends undefined\n  ? B extends undefined\n    ? undefined\n    : B\n  : B extends undefined\n  ? A\n  : A extends ArrayType<infer AEl>\n  ? B extends ArrayType<infer BEl>\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\n    : never\n  : A extends NamedTupleType<infer AShape>\n  ? B extends NamedTupleType<infer BShape>\n    ? NamedTupleType<{\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\n          AShape[k],\n          BShape[k]\n        >;\n      }>\n    : never\n  : A extends TupleType<infer AItems>\n  ? B extends TupleType<infer BItems>\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\n      : never\n    : never\n  : castMaps.getSharedParentScalar<A, B>;\n\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? _getSharedParentPrimitiveVariadic<\n        [getSharedParentPrimitive<A, B>, ...Rest]\n      >\n    : never;\n\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  _getSharedParentPrimitiveVariadic<Types>;\n\nexport type LooseTypeSet<\n  T extends any = any,\n  C extends Cardinality = Cardinality\n> = {\n  __element__: T;\n  __cardinality__: C;\n};\n\nexport type {mergeObjectTypes};\n\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? A extends ObjectType\n      ? B extends ObjectType\n        ? mergeObjectTypes<A, B> extends BaseType\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\n          : never\n        : never\n      : never\n    : never;\n\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\n  _mergeObjectTypesVariadic<Types>;\n\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\n    ? getPrimitiveBaseType<El>\n    : never;\n};\n\nexport type getTypesFromObjectExprs<\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\n> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\n\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.mts","content":"import type {TypeSet, setToTsType} from \"edgedb/dist/reflection/index.js\";\n\nexport * from \"./literal.mjs\";\nexport * from \"./path.mjs\";\nexport * from \"./set.mjs\";\nexport * from \"./cast.mjs\";\nexport * from \"./select.mjs\";\nexport * from \"./update.mjs\";\nexport * from \"./insert.mjs\";\nexport * from \"./group.mjs\";\nexport * from \"./collections.mjs\";\nexport * from \"./funcops.mjs\";\nexport * from \"./for.mjs\";\nexport * from \"./with.mjs\";\nexport * from \"./params.mjs\";\nexport * from \"./globals.mjs\";\nexport * from \"./detached.mjs\";\nexport * from \"./toEdgeQL.mjs\";\nexport * from \"./range.mjs\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.mts","content":"import {\n  Duration,\n  LocalDate,\n  LocalDateTime,\n  LocalTime,\n  RelativeDuration,\n  DateDuration,\n  Range,\n} from \"edgedb\";\nimport {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  BaseType,\n  Cardinality,\n  EnumType,\n  ExpressionKind,\n  isArrayType,\n  isNamedTupleType,\n  isObjectType,\n  isTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  OperatorKind,\n  RangeType,\n  TypeKind,\n  TypeSet,\n  util,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {$expr_Literal} from \"edgedb/dist/reflection/literal.js\";\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $expr_TypeIntersection,\n} from \"edgedb/dist/reflection/path.js\";\nimport {reservedKeywords} from \"edgedb/dist/reflection/reservedKeywords.js\";\nimport type {$expr_Cast} from \"./cast.mjs\";\nimport type {$expr_Detached} from \"./detached.mjs\";\nimport type {$expr_For, $expr_ForVar} from \"./for.mjs\";\nimport type {$expr_Function, $expr_Operator} from \"edgedb/dist/reflection/funcops.js\";\nimport type {$expr_Insert, $expr_InsertUnlessConflict} from \"./insert.mjs\";\nimport type {$expr_Param, $expr_WithParams} from \"./params.mjs\";\nimport type {\n  $expr_Delete,\n  $expr_Select,\n  LimitExpression,\n  OffsetExpression,\n} from \"./select.mjs\";\nimport type {$expr_Set} from \"./set.mjs\";\nimport type {$expr_Update} from \"./update.mjs\";\nimport type {$expr_Alias, $expr_With} from \"./with.mjs\";\nimport type {$expr_Group, GroupingSet} from \"./group.mjs\";\nimport type {$expr_Global} from \"./globals.mjs\";\n\nexport type SomeExpression =\n  | $expr_PathNode\n  | $expr_PathLeaf\n  | $expr_Literal\n  | $expr_Set\n  | $expr_Array\n  | $expr_Tuple\n  | $expr_NamedTuple\n  | $expr_TuplePath\n  | $expr_Cast\n  | $expr_Select\n  | $expr_Delete\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_Function\n  | $expr_Operator\n  | $expr_For\n  | $expr_ForVar\n  | $expr_TypeIntersection\n  | $expr_Alias\n  | $expr_With\n  | $expr_WithParams\n  | $expr_Param\n  | $expr_Detached\n  | $expr_Group\n  | $expr_Global;\n\ntype WithScopeExpr =\n  | $expr_Select\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_For\n  | $expr_Group;\n\ninterface RenderCtx {\n  // mapping withable expr to list of with vars\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\n  // metadata about each with var\n  withVars: Map<\n    SomeExpression,\n    {\n      name: string;\n      scope: WithScopeExpr;\n      childExprs: Set<SomeExpression>;\n      scopedExpr?: SomeExpression; // scope vars only\n    }\n  >;\n  renderWithVar?: SomeExpression;\n  forVars: Map<$expr_ForVar, string>;\n  linkProps: Map<SomeExpression, string[]>;\n}\n\nconst toEdgeQLCache = new WeakMap<any, string>();\n\nexport function $toEdgeQL(this: any) {\n  if (toEdgeQLCache.has(this)) {\n    return toEdgeQLCache.get(this)!;\n  }\n\n  const walkExprCtx: WalkExprTreeCtx = {\n    seen: new Map(),\n    rootScope: null,\n  };\n\n  walkExprTree(this, null, walkExprCtx);\n\n  // get variables by block\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\n  // get per-variable metadata\n  const withVars: RenderCtx[\"withVars\"] = new Map();\n  const seen = new Map(walkExprCtx.seen);\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\n\n  // iterate over all expressions\n  for (const [expr, refData] of seen) {\n    // delete from seen after visitinng\n    seen.delete(expr);\n\n    // convert referenced link props to simple string array\n    if (refData.linkProps.length) {\n      linkProps.set(\n        expr,\n        refData.linkProps.map(linkProp =>\n          linkProp.__parent__.linkName.slice(1)\n        )\n      );\n    }\n\n    // already extracted\n    if (withVars.has(expr)) {\n      continue;\n    }\n\n    // ignore unbound leaves, nodes, and intersections\n    // these should be rendered as is\n    if (\n      !refData.boundScope &&\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\n        expr.__kind__ === ExpressionKind.PathNode ||\n        expr.__kind__ === ExpressionKind.TypeIntersection)\n    ) {\n      continue;\n    }\n\n    // forvars and params should not be hoisted\n    if (\n      expr.__kind__ === ExpressionKind.ForVar ||\n      expr.__kind__ === ExpressionKind.Param\n    ) {\n      continue;\n    }\n\n    // pull out scope variables\n    // from select, update, and group expressions.\n    // these are always rendered in with blocks\n    if (\n      (expr.__kind__ === ExpressionKind.Select ||\n        expr.__kind__ === ExpressionKind.Update ||\n        expr.__kind__ === ExpressionKind.Group) &&\n      expr.__scope__ &&\n      // with var not previously registered\n      !withVars.has(expr.__scope__ as any)\n    ) {\n      const withBlock = expr;\n      const scopeVar = expr.__scope__ as SomeExpression;\n      const scopeVarName = `__scope_${withVars.size}_${\n        scopeVar.__element__.__name__.split(\"::\")[1]\n      }`;\n\n      withVars.set(scopeVar, {\n        name: scopeVarName,\n        scope: withBlock,\n        childExprs: new Set(),\n        scopedExpr:\n          expr.__element__.__kind__ === TypeKind.object\n            ? (expr.__expr__ as any)\n            : undefined,\n      });\n    }\n\n    // expression should be extracted to with block if\n    // - bound with e.with\n    // - refcount > 1\n    // - aliased with e.alias\n    if (\n      refData.refCount > 1 ||\n      refData.boundScope ||\n      refData.aliases.length > 0\n    ) {\n      // first, check if expr is bound to scope\n      let withBlock = refData.boundScope;\n\n      // filter nulls\n      const parentScopes = [...refData.parentScopes].filter(\n        scope => scope !== null\n      ) as WithScopeExpr[];\n\n      // if expression is unbound\n      if (!withBlock) {\n        // if parent scopes haven't all been resolved,\n        // re-add current expr to `seen` to be resolved later\n        if (parentScopes.some(parentScope => seen.has(parentScope))) {\n          seen.set(expr, refData);\n          continue;\n        }\n\n        // set withBlock to top-level parent scope\n        const resolvedParentScopes = parentScopes.map(\n          parentScope => withVars.get(parentScope)?.scope ?? parentScope\n        );\n        withBlock =\n          resolvedParentScopes.find(parentScope => {\n            // loop over parent scopes\n            // get list of children exprs for each parent\n            const childExprs = new Set(\n              walkExprCtx.seen.get(parentScope)!.childExprs\n            );\n            // return true for scope that contains all other scopes\n            return resolvedParentScopes.every(\n              scope => childExprs.has(scope) || scope === parentScope\n            );\n          }) ?? walkExprCtx.rootScope;\n      }\n\n      if (!withBlock) {\n        throw new Error(\n          `Cannot extract repeated expression into 'WITH' block, ` +\n            `query has no 'WITH'able expressions`\n        );\n      }\n\n      if (!withBlocks.has(withBlock)) {\n        withBlocks.set(withBlock, new Set());\n      }\n\n      // check all references and aliases are within this block\n      const validScopes = new Set([\n        withBlock,\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\n      ]);\n      for (const scope of [\n        ...refData.parentScopes,\n        ...util.flatMap(refData.aliases, alias => [\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\n        ]),\n      ]) {\n        if (scope === null || !validScopes.has(scope)) {\n          throw new Error(\n            refData.boundScope\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                `expression or its aliases appear outside root scope`\n          );\n        }\n      }\n\n      for (const withVar of [expr, ...refData.aliases]) {\n        // withVar is an alias already explicitly bound\n        // to an inner WITH block\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n          continue;\n        }\n\n        const withVarName = `__withVar_${withVars.size}`;\n\n        withBlocks.get(withBlock)!.add(withVar);\n        withVars.set(withVar, {\n          name: withVarName,\n          scope: withBlock,\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\n        });\n      }\n    }\n  }\n\n  let edgeQL = renderEdgeQL(this, {\n    withBlocks,\n    withVars,\n    forVars: new Map(),\n    linkProps,\n  });\n  if (\n    edgeQL.startsWith(\"(\") &&\n    edgeQL.endsWith(\")\") &&\n    !(\n      this.__kind__ === ExpressionKind.Tuple ||\n      this.__kind__ === ExpressionKind.NamedTuple ||\n      this.__kind__ === ExpressionKind.Literal\n    )\n  ) {\n    edgeQL = edgeQL.slice(1, -1);\n  }\n  toEdgeQLCache.set(this, edgeQL);\n\n  return edgeQL;\n}\n\ninterface WalkExprTreeCtx {\n  seen: Map<\n    SomeExpression,\n    {\n      refCount: number;\n      // tracks all withable ancestors\n      parentScopes: Set<WithScopeExpr | null>;\n      // tracks all child exprs\n      childExprs: SomeExpression[];\n      // tracks bound scope from e.with\n      boundScope: WithScopeExpr | null;\n      // tracks aliases from e.alias\n      aliases: SomeExpression[];\n      linkProps: $expr_PathLeaf[];\n    }\n  >;\n  rootScope: WithScopeExpr | null;\n}\n\n// walks entire expression tree\n// populates\nfunction walkExprTree(\n  _expr: TypeSet,\n  parentScope: WithScopeExpr | null,\n  ctx: WalkExprTreeCtx\n): SomeExpression[] {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\n      `Expected a valid querybuilder expression, ` +\n        `instead received ${typeof _expr}${\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\n        }.` +\n        getErrorHint(_expr)\n    );\n  }\n\n  const expr = _expr as SomeExpression;\n\n  function walkShape(shape: object) {\n    for (let param of Object.values(shape)) {\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\n        param = param.__shapeElement__;\n      }\n      if (typeof param === \"object\") {\n        if (!!(param as any).__kind__) {\n          // param is expression\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\n        } else {\n          walkShape(param);\n        }\n      }\n    }\n  }\n\n  // set root scope\n  if (!ctx.rootScope && parentScope) {\n    ctx.rootScope = parentScope;\n  }\n\n  // return without walking if expression has been seen\n  const seenExpr = ctx.seen.get(expr);\n  if (seenExpr) {\n    seenExpr.refCount += 1;\n    // if (seenExpr.refCount > 1) {\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\n    // console.log(expr.__kind__);\n    // console.log(expr.__element__.__name__);\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\n    // if (arg) console.log(arg);\n    // }\n    seenExpr.parentScopes.add(parentScope);\n    return [expr, ...seenExpr.childExprs];\n  }\n\n  const childExprs: SomeExpression[] = [];\n  ctx.seen.set(expr, {\n    refCount: 1,\n    parentScopes: new Set([parentScope]),\n    childExprs,\n    boundScope: null,\n    aliases: [],\n    linkProps: [],\n  });\n\n  switch (expr.__kind__) {\n    case ExpressionKind.Alias:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\n      break;\n    case ExpressionKind.With:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      for (const refExpr of expr.__refs__) {\n        walkExprTree(refExpr, expr.__expr__, ctx);\n        const seenRef = ctx.seen.get(refExpr as any)!;\n        if (seenRef.boundScope) {\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\n        }\n        seenRef.boundScope = expr.__expr__;\n      }\n      break;\n    case ExpressionKind.Literal:\n    case ExpressionKind.ForVar:\n    case ExpressionKind.Param:\n      break;\n    case ExpressionKind.PathLeaf:\n    case ExpressionKind.PathNode:\n      if (expr.__parent__) {\n        if ((expr.__parent__.type as any).__scopedFrom__) {\n          // if parent is scoped expr then don't walk expr\n          // since it will already be walked by enclosing select/update\n\n          childExprs.push(expr.__parent__.type as any);\n        } else {\n          childExprs.push(\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\n          );\n        }\n\n        if (\n          // is link prop\n          expr.__kind__ === ExpressionKind.PathLeaf &&\n          expr.__parent__.linkName.startsWith(\"@\")\n        ) {\n          // don't hoist a linkprop that isn't scoped from parentScope\n          const parentScopeVar = (parentScope as any).__scope__;\n          if (parentScopeVar === expr.__parent__.type) {\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\n          }\n        }\n      }\n      break;\n    case ExpressionKind.Cast:\n      if (expr.__expr__ === null) break;\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Set:\n      for (const subExpr of expr.__exprs__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Array:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Tuple:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.NamedTuple:\n      for (const subExpr of Object.values(expr.__shape__)) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.TuplePath:\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n      break;\n    case ExpressionKind.Select:\n    case ExpressionKind.Update: {\n      const modifiers = expr.__modifiers__;\n      if (modifiers.filter) {\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n      }\n      if (modifiers.order_by) {\n        for (const orderExpr of modifiers.order_by) {\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n        }\n      }\n      if (modifiers.offset) {\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\n      }\n      if (modifiers.limit) {\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\n      }\n\n      if (expr.__kind__ === ExpressionKind.Select) {\n        if (\n          isObjectType(expr.__element__) &&\n          // don't walk shape twice if select expr justs wrap another object\n          // type expr with the same shape\n          expr.__element__.__shape__ !==\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n        ) {\n          walkShape(expr.__element__.__shape__ ?? {});\n        }\n      } else {\n        // Update\n        const shape: any = expr.__shape__ ?? {};\n\n        for (const _element of Object.values(shape)) {\n          let element: any = _element;\n          if (!element.__element__) {\n            if (element[\"+=\"]) element = element[\"+=\"];\n            else if (element[\"-=\"]) element = element[\"-=\"];\n          }\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\n        }\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.Delete: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Insert: {\n      const shape: any = expr.__shape__ ?? {};\n\n      for (const element of Object.values(shape)) {\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.InsertUnlessConflict: {\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\n      // child expressions is the wrapped Insert expr\n      if (expr.__conflict__.on) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.on,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n      if (expr.__conflict__.else) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.else,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Group: {\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\n        // this prevents recurring grouping elements from being walked twice\n        // this way, these won't get pulled into with blocks,\n        // which is good because they need to be rendered in `using`\n        const seen: Set<any> = new Set();\n        if (!seen.has(expr)) {\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n          seen.add(expr);\n        }\n      }\n\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n        throw new Error(\"Missing shape in GROUP statement\");\n      }\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.TypeIntersection:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Operator:\n    case ExpressionKind.Function:\n      for (const subExpr of expr.__args__) {\n        if (Array.isArray(subExpr)) {\n          for (const arg of subExpr) {\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\n          }\n        } else {\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\n        }\n      }\n      if (expr.__kind__ === ExpressionKind.Function) {\n        for (const subExpr of Object.values(expr.__namedargs__)) {\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n        }\n      }\n      break;\n    case ExpressionKind.For: {\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.WithParams: {\n      if (parentScope !== null) {\n        throw new Error(\n          `'withParams' does not support being used as a nested expression`\n        );\n      }\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Detached: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Global:\n      break;\n    default:\n      util.assertNever(\n        expr,\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n      );\n  }\n\n  return [expr, ...childExprs];\n}\n\nfunction renderEdgeQL(\n  _expr: TypeSet,\n  ctx: RenderCtx,\n  renderShape: boolean = true,\n  noImplicitDetached: boolean = false\n): string {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\"Invalid expression.\");\n  }\n  const expr = _expr as SomeExpression;\n\n  // if expression is in a with block\n  // render its name\n  const withVar = ctx.withVars.get(expr);\n\n  if (withVar && ctx.renderWithVar !== expr) {\n    return renderShape &&\n      expr.__kind__ === ExpressionKind.Select &&\n      isObjectType(expr.__element__)\n      ? `(${withVar.name} ${shapeToEdgeQL(\n          (expr.__element__.__shape__ || {}) as object,\n          ctx,\n          null,\n          true // render shape only\n        )})`\n      : withVar.name;\n  }\n\n  // render with block expression\n  function renderWithBlockExpr(\n    varExpr: SomeExpression,\n    _noImplicitDetached?: boolean\n  ) {\n    const withBlockElement = ctx.withVars.get(varExpr)!;\n    let renderedExpr = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      _noImplicitDetached\n    );\n    const renderedExprNoDetached = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      true\n    );\n\n    if (ctx.linkProps.has(expr)) {\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n        .get(expr)!\n        .map(\n          linkPropName =>\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\n        )\n        .join(\",\\n\")}\\n})`;\n    }\n    return `  ${withBlockElement.name} := ${\n      renderedExpr.includes(\"\\n\")\n        ? `(\\n${indent(\n            renderedExpr[0] === \"(\" &&\n              renderedExpr[renderedExpr.length - 1] === \")\"\n              ? renderedExpr.slice(1, -1)\n              : renderedExpr,\n            4\n          )}\\n  )`\n        : renderedExpr\n    }`;\n  }\n\n  // extract scope expression from select/update if exists\n  const scopeExpr =\n    (expr.__kind__ === ExpressionKind.Select ||\n      expr.__kind__ === ExpressionKind.Update ||\n      expr.__kind__ === ExpressionKind.Group) &&\n    ctx.withVars.has(expr.__scope__ as any)\n      ? (expr.__scope__ as SomeExpression)\n      : undefined;\n\n  const scopeExprVar: string[] = [];\n  const unscopedWithBlock: string[] = [];\n  const scopedWithBlock: string[] = [];\n\n  // generate with block if needed\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\n    // sort associated vars\n    const sortedBlockVars = topoSortWithVars(\n      ctx.withBlocks.get(expr as any) ?? new Set(),\n      ctx\n    );\n\n    if (!scopeExpr) {\n      // if no scope expression exists, all variables are unscoped\n      unscopedWithBlock.push(\n        ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n      );\n    }\n    // else if (expr.__kind__ === ExpressionKind.Group) {\n    //   // add all vars into scoped with block\n    //   // this is rendered inside the `using` clause later\n    //   // no need for the with/for trick\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n    //   scopedWithBlock.push(\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n    //   );\n    // }\n    else {\n      // get scope variable\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\n\n      // get list of with vars that reference scope\n      const scopedVars = sortedBlockVars.filter(blockVarExpr =>\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\n      );\n      // filter blockvars to only include vars that don't reference scope\n      unscopedWithBlock.push(\n        ...sortedBlockVars\n          .filter(blockVar => !scopedVars.includes(blockVar))\n          .map(blockVar => renderWithBlockExpr(blockVar))\n      );\n\n      // when rendering `with` variables that reference current scope\n      // they are extracted into computed properties defining in a for loop\n      if (!scopedVars.length) {\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n      } else {\n        const scopeName = scopeVar.name;\n\n        // render a reference to scoped path (e.g. \".nemesis\")\n        scopeVar.name = scopeName + \"_expr\";\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n        // scopedWithBlock.push(\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\n        // );\n\n        // render a for loop containing all scoped block vars\n        // as computed properties\n        scopeVar.name = scopeName + \"_inner\";\n        scopeExprVar.push(\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\n            scopeName + \"_expr\"\n          }} UNION (\\n    WITH\\n${indent(\n            scopedVars\n              .map(blockVar => renderWithBlockExpr(blockVar))\n              .join(\",\\n\"),\n            4\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n            .map(blockVar => {\n              const name = ctx.withVars.get(blockVar)!.name;\n              return `      ${name} := ${name}`;\n            })\n            .join(\",\\n\")}\\n    }\\n  ))`\n        );\n\n        // change var name back to original value\n        scopeVar.name = scopeName;\n\n        // reassign name for all scoped block vars\n        for (const blockVarExpr of scopedVars) {\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\n          blockVar.name = `${scopeName}.${blockVar.name}`;\n        }\n      }\n    }\n  }\n\n  const withBlockElements = [\n    ...unscopedWithBlock,\n    ...scopeExprVar,\n    ...scopedWithBlock,\n  ];\n  const withBlock = withBlockElements.length\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n    : \"\";\n\n  if (expr.__kind__ === ExpressionKind.With) {\n    return renderEdgeQL(expr.__expr__, ctx);\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\n    return `(WITH\\n${expr.__params__\n      .map(param => {\n        const optional =\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n        return `  __param__${param.__name__} := ${\n          param.__isComplex__\n            ? `<${param.__element__.__name__}>to_json(<${optional}str>$${param.__name__})`\n            : `<${optional}${param.__element__.__name__}>$${param.__name__}`\n        }`;\n      })\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\n    if (!aliasedExprVar) {\n      throw new Error(\n        `Expression referenced by alias does not exist in 'WITH' block`\n      );\n    }\n    return aliasedExprVar.name;\n  } else if (\n    expr.__kind__ === ExpressionKind.PathNode ||\n    expr.__kind__ === ExpressionKind.PathLeaf\n  ) {\n    if (!expr.__parent__) {\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\n        expr.__element__.__name__\n      }`;\n    } else {\n      const isScopedLinkProp =\n        expr.__parent__.linkName.startsWith(\"@\") &&\n        ctx.withVars.has(expr.__parent__.type as any);\n      const linkName = isScopedLinkProp\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n        : expr.__parent__.linkName;\n      const parent = renderEdgeQL(\n        expr.__parent__.type,\n        ctx,\n        false,\n        noImplicitDetached\n      );\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n    }\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\n    return literalToEdgeQL(expr.__element__, expr.__value__);\n  } else if (expr.__kind__ === ExpressionKind.Set) {\n    const exprs = expr.__exprs__;\n\n    if (\n      exprs.every(ex => ex.__element__.__kind__ === TypeKind.object) ||\n      exprs.every(ex => ex.__element__.__kind__ !== TypeKind.object)\n    ) {\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\n      return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n    } else {\n      throw new Error(\n        `Invalid arguments to set constructor: ${exprs\n          .map(ex => ex.__element__.__name__)\n          .join(\", \")}`\n      );\n    }\n  } else if (expr.__kind__ === ExpressionKind.Array) {\n    return `[${expr.__items__\n      .map(item => renderEdgeQL(item, ctx))\n      .join(\", \")}]`;\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\n    return `(\\n${expr.__items__\n      .map(\n        item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\n      )\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\n    return `(\\n${Object.keys(expr.__shape__)\n      .map(\n        key =>\n          `  ${key} := ${renderEdgeQL(\n            expr.__shape__[key],\n            ctx,\n            renderShape,\n            noImplicitDetached\n          )}`\n      )\n      .join(\",\\n\")}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\n    const typeName =\n      expr.__element__.__name__ === \"std::number\"\n        ? \"std::float64\"\n        : expr.__element__.__name__;\n    if (expr.__expr__ === null) {\n      return `<${typeName}>{}`;\n    }\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Select) {\n    const lines: string[] = [];\n    if (isObjectType(expr.__element__)) {\n      const selectionTarget = renderEdgeQL(\n        expr.__scope__ ?? expr.__expr__,\n        ctx,\n        false\n      );\n\n      lines.push(\n        `SELECT${\n          selectionTarget === \"DETACHED std::FreeObject\"\n            ? \"\"\n            : ` ${selectionTarget}`\n        }`\n      );\n\n      if (\n        expr.__element__.__shape__ !==\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n      ) {\n        lines.push(\n          shapeToEdgeQL(\n            (expr.__element__.__shape__ || {}) as object,\n            ctx,\n            expr.__element__\n          )\n        );\n      }\n    } else {\n      // non-object/non-shape select expression\n      const needsScalarVar =\n        (expr.__modifiers__.filter ||\n          expr.__modifiers__.order_by ||\n          expr.__modifiers__.offset ||\n          expr.__modifiers__.limit) &&\n        !ctx.withVars.has(expr.__expr__ as any);\n\n      lines.push(\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\n          expr.__expr__,\n          ctx\n        )}`\n      );\n\n      if (needsScalarVar) {\n        ctx = {...ctx, withVars: new Map(ctx.withVars)};\n        ctx.withVars.set(expr.__expr__ as any, {\n          name: \"_\",\n          childExprs: new Set(),\n          scope: expr,\n        });\n      }\n    }\n\n    const modifiers: string[] = [];\n\n    if (expr.__modifiers__.filter) {\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n    }\n    if (expr.__modifiers__.order_by) {\n      modifiers.push(\n        ...expr.__modifiers__.order_by.map(\n          ({expression, direction, empty}, i) => {\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\n              expression,\n              ctx\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n          }\n        )\n      );\n    }\n    if (expr.__modifiers__.offset) {\n      modifiers.push(\n        `OFFSET ${renderEdgeQL(\n          expr.__modifiers__.offset as OffsetExpression,\n          ctx\n        )}`\n      );\n    }\n    if (expr.__modifiers__.limit) {\n      modifiers.push(\n        `LIMIT ${renderEdgeQL(\n          expr.__modifiers__.limit as LimitExpression,\n          ctx\n        )}`\n      );\n    }\n\n    return (\n      \"(\" +\n      withBlock +\n      lines.join(\" \") +\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n      \")\"\n    );\n  } else if (expr.__kind__ === ExpressionKind.Update) {\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\n      expr.__modifiers__.filter\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n        : \" \"\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\n    return `(${withBlock}DELETE ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      undefined,\n      noImplicitDetached\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\n    return `(${withBlock}INSERT ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      false,\n      true\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\n    const $on = expr.__conflict__.on;\n    const $else = expr.__conflict__.else;\n    const clause: string[] = [];\n    if (!$on) {\n      clause.push(\"\\nUNLESS CONFLICT\");\n    }\n    if ($on) {\n      clause.push(\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\n      );\n    }\n    if ($else) {\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n    }\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\n      1,\n      -1\n    )} ${clause.join(\"\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Group) {\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n    const elementsShape =\n      expr.__element__.__shape__.elements.__element__.__shape__;\n\n    const selectStatement: string[] = [];\n    const groupStatement: string[] = [];\n\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx);\n    groupStatement.push(`GROUP ${groupTarget}`);\n\n    // render scoped withvars in using\n    const combinedBlock = [\n      // ...scopedWithBlock,\n      // this is deduplicated in e.group\n      ...groupingSet.__exprs__.map(\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\n      ),\n    ];\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n\n    let by = renderGroupingSet(groupingSet).trim();\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n      by = by.slice(1, by.length - 1);\n    }\n    groupStatement.push(`BY ` + by);\n\n    // clause.push(withBlock.trim());\n\n    // render scope var and any unscoped withVars in with block\n    const selectTarget = `${groupTarget}_groups`;\n    selectStatement.push(\n      `WITH\\n${[\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        // ...scopedWithBlock,\n      ].join(\",\\n\")},\n  ${selectTarget} := (\n${indent(groupStatement.join(\"\\n\"), 4)}\n)`\n    );\n\n    // rename scope var to fix all scope references that\n    // occur in the `elements` subshape\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\n\n    // replace references to __scope__ with\n    // .elements reference\n    const elementsShapeQuery = indent(\n      shapeToEdgeQL(elementsShape as object, {...ctx}, expr.__element__),\n      2\n    )\n      .trim()\n      .split(scopeVar!.name + \".\")\n      .join(`${selectTarget}.elements.`);\n\n    selectStatement.push(`SELECT ${selectTarget} {\n  key: {${groupingSet.__exprs__.map(e => e[0]).join(\", \")}},\n  grouping,\n  elements: ${elementsShapeQuery}\n}`);\n    return `(${selectStatement.join(\"\\n\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Function) {\n    const args = expr.__args__.map(arg => `${renderEdgeQL(arg!, ctx, false)}`);\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n    }\n    return `${expr.__name__}(${args.join(\", \")})`;\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\n    const operator = expr.__name__;\n    const args = expr.__args__;\n    switch (expr.__opkind__) {\n      case OperatorKind.Infix:\n        if (operator === \"[]\") {\n          let index = \"\";\n          if (Array.isArray(args[1])) {\n            const [start, end] = args[1];\n            if (start) {\n              index += renderEdgeQL(start, ctx);\n            }\n            index += \":\";\n            if (end) {\n              index += renderEdgeQL(end, ctx);\n            }\n          } else {\n            index = renderEdgeQL(args[1], ctx);\n          }\n\n          return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n        }\n        return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(\n          args[1],\n          ctx\n        )})`;\n      case OperatorKind.Postfix:\n        return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n      case OperatorKind.Prefix:\n        return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n      case OperatorKind.Ternary:\n        if (operator === \"if_else\") {\n          return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(\n            args[1],\n            ctx\n          )} ELSE ${renderEdgeQL(args[2], ctx)})`;\n        } else {\n          throw new Error(`Unknown operator: ${operator}`);\n        }\n      default:\n        util.assertNever(\n          expr.__opkind__,\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\n        );\n    }\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\n      expr.__element__.__name__\n    }]`;\n  } else if (expr.__kind__ === ExpressionKind.For) {\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n    return `(${withBlock}FOR ${ctx.forVars.get(\n      expr.__forVar__\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\n    const forVar = ctx.forVars.get(expr);\n    if (!forVar) {\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n    }\n    return forVar;\n  } else if (expr.__kind__ === ExpressionKind.Param) {\n    return `__param__${expr.__name__}`;\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\n    return `(DETACHED ${renderEdgeQL(\n      expr.__expr__,\n      {\n        ...ctx,\n        renderWithVar: expr.__expr__ as any,\n      },\n      undefined,\n      true\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Global) {\n    return `(GLOBAL ${expr.__name__})`;\n  } else {\n    util.assertNever(\n      expr,\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n    );\n  }\n}\n\nfunction isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// recursive renderer\nfunction renderGroupingSet(set: GroupingSet): string {\n  const contents = Object.entries(set.__elements__)\n    .map(([k, v]) => {\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n    .join(\", \");\n  if (set.__settype__ === \"tuple\") {\n    return `(${contents})`;\n  } else if (set.__settype__ === \"set\") {\n    return `{${contents}}`;\n  } else if (set.__settype__ === \"cube\") {\n    return `cube(${contents})`;\n  } else if (set.__settype__ === \"rollup\") {\n    return `rollup(${contents})`;\n  } else {\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n  }\n}\n\nfunction shapeToEdgeQL(\n  shape: object | null,\n  ctx: RenderCtx,\n  type: ObjectType | null = null,\n  keysOnly: boolean = false,\n  injectImplicitId: boolean = true\n) {\n  const pointers = type?.__pointers__ || null;\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\n  if (shape === null) {\n    return ``;\n  }\n\n  const lines: string[] = [];\n  const addLine = (line: string) =>\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n\n  const seen = new Set();\n\n  for (const key in shape) {\n    if (!shape.hasOwnProperty(key)) continue;\n    if (seen.has(key)) {\n      // tslint:disable-next-line\n      console.warn(`Invalid: duplicate key \"${key}\"`);\n      continue;\n    }\n    seen.add(key);\n    let val = (shape as any)[key];\n    let operator = \":=\";\n    let polyType: SomeExpression | null = null;\n\n    if (typeof val === \"object\" && !val.__element__) {\n      if (!!val[\"+=\"]) {\n        operator = \"+=\";\n        val = val[\"+=\"];\n      } else if (!!val[\"-=\"]) {\n        operator = \"-=\";\n        val = val[\"-=\"];\n      }\n    }\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\n      polyType = val.__polyType__;\n      val = val.__shapeElement__;\n    }\n    const polyIntersection = polyType\n      ? `[IS ${polyType.__element__.__name__}].`\n      : \"\";\n\n    // For computed properties in select shapes, inject the expected\n    // cardinality inferred by the query builder. This ensures the actual\n    // type returned by the server matches the inferred return type, or an\n    // explicit error is thrown, instead of a silent mismatch between\n    // actual and inferred type.\n    // Add annotations on FreeObjects, despite the existence of a pointer.\n    const ptr = pointers?.[key];\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n\n    const expectedCardinality =\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n        ? val.__cardinality__ === Cardinality.Many ||\n          val.__cardinality__ === Cardinality.AtLeastOne\n          ? \"multi \"\n          : \"single \"\n        : \"\";\n\n    // if selecting a required multi link, wrap expr in 'assert_exists'\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\n\n    if (typeof val === \"boolean\") {\n      if (\n        !pointers?.[key] &&\n        key[0] !== \"@\" &&\n        type &&\n        type?.__name__ !== \"std::FreeObject\" &&\n        !polyIntersection\n      ) {\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\n      }\n      if (val) {\n        addLine(`${polyIntersection}${q(key)}`);\n      }\n      continue;\n    }\n\n    if (typeof val !== \"object\") {\n      throw new Error(`Invalid shape element at \"${key}\".`);\n    }\n\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\n\n    // is subshape\n    if (!valIsExpression) {\n      addLine(\n        `${polyIntersection}${q(key, false)}: ${indent(\n          shapeToEdgeQL(val, ctx, ptr?.target),\n          2\n        ).trim()}`\n      );\n      continue;\n    }\n\n    // val is expression\n\n    // is computed\n    if (keysOnly) {\n      addLine(\n        q(key, false) +\n          (isObjectType(val.__element__)\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n            : \"\")\n      );\n      continue;\n    }\n    const renderedExpr = renderEdgeQL(val, ctx);\n\n    addLine(\n      `${expectedCardinality}${q(key, false)} ${operator} ${\n        wrapAssertExists ? \"assert_exists(\" : \"\"\n      }${\n        renderedExpr.includes(\"\\n\")\n          ? `(\\n${indent(\n              renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr,\n              4\n            )}\\n  )`\n          : renderedExpr\n      }${wrapAssertExists ? \")\" : \"\"}`\n    );\n  }\n\n  if (lines.length === 0 && injectImplicitId) {\n    addLine(\"id\");\n  }\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\n\nfunction topoSortWithVars(\n  vars: Set<SomeExpression>,\n  ctx: RenderCtx\n): SomeExpression[] {\n  if (!vars.size) {\n    return [];\n  }\n\n  const sorted: SomeExpression[] = [];\n\n  const unvisited = new Set(vars);\n  const visiting = new Set<SomeExpression>();\n\n  for (const withVar of unvisited) {\n    visit(withVar);\n  }\n\n  function visit(withVar: SomeExpression): void {\n    if (!unvisited.has(withVar)) {\n      return;\n    }\n    if (visiting.has(withVar)) {\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\n    }\n\n    visiting.add(withVar);\n\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\n      if (vars.has(child)) {\n        visit(child);\n      }\n    }\n\n    visiting.delete(withVar);\n    unvisited.delete(withVar);\n\n    sorted.push(withVar);\n  }\n  return sorted;\n}\n\nconst numericalTypes: Record<string, boolean> = {\n  \"std::number\": true,\n  \"std::int16\": true,\n  \"std::int32\": true,\n  \"std::int64\": true,\n  \"std::float32\": true,\n  \"std::float64\": true,\n};\n\nfunction literalToEdgeQL(type: BaseType, val: any): string {\n  let skipCast = false;\n  let stringRep;\n  if (type.__name__ === \"std::json\") {\n    skipCast = true;\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n  } else if (typeof val === \"string\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n      stringRep = val;\n    } else if (type.__kind__ === TypeKind.enum) {\n      skipCast = true;\n      const vals = (type as EnumType).__values__;\n      if (vals.includes(val)) {\n        skipCast = true;\n        if (val.includes(\" \")) {\n          stringRep = `<${type.__name__}>\"${val}\"`;\n        } else {\n          stringRep = `${type.__name__}.${val}`;\n        }\n      } else {\n        throw new Error(\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n        );\n      }\n    } else {\n      if (type.__name__ === \"std::str\") {\n        skipCast = true;\n      }\n      stringRep = JSON.stringify(val);\n    }\n  } else if (typeof val === \"number\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n    } else {\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\n    }\n    stringRep = `${val.toString()}`;\n  } else if (typeof val === \"boolean\") {\n    stringRep = `${val.toString()}`;\n    skipCast = true;\n  } else if (typeof val === \"bigint\") {\n    stringRep = `${val.toString()}n`;\n  } else if (Array.isArray(val)) {\n    skipCast = val.length !== 0;\n    if (isArrayType(type)) {\n      stringRep = `[${val\n        .map(el => literalToEdgeQL(type.__element__ as any, el))\n        .join(\", \")}]`;\n    } else if (isTupleType(type)) {\n      stringRep = `( ${val\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else if (val instanceof Date) {\n    stringRep = `'${val.toISOString()}'`;\n  } else if (\n    val instanceof LocalDate ||\n    val instanceof LocalDateTime ||\n    val instanceof LocalTime ||\n    val instanceof Duration ||\n    val instanceof RelativeDuration ||\n    val instanceof DateDuration\n  ) {\n    stringRep = `'${val.toString()}'`;\n  } else if (val instanceof Buffer) {\n    stringRep = bufferToStringRep(val);\n    skipCast = true;\n  } else if (val instanceof Range) {\n    const elType = (type as RangeType).__element__;\n\n    // actual type will be inferred from\n    // defined value\n    const elTypeName =\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n\n    return `std::range(${\n      val.lower === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.lower)\n    }, ${\n      val.upper === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.upper)\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n  } else if (typeof val === \"object\") {\n    if (isNamedTupleType(type)) {\n      stringRep = `( ${Object.entries(val).map(\n        ([key, value]) =>\n          `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`\n      )} )`;\n      skipCast = true;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else {\n    throw new Error(\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n    );\n  }\n  if (skipCast) {\n    return stringRep;\n  }\n  return `<${type.__name__}>${stringRep}`;\n}\n\nfunction indent(str: string, depth: number) {\n  return str\n    .split(\"\\n\")\n    .map(line => \" \".repeat(depth) + line)\n    .join(\"\\n\");\n}\n\n// backtick quote identifiers if needed\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\nfunction q(ident: string, allowBacklinks: boolean = true): string {\n  if (\n    !ident ||\n    ident.startsWith(\"@\") ||\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\n  ) {\n    return ident;\n  }\n\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n  if (isAlphaNum) {\n    const lident = ident.toLowerCase();\n    const isReserved =\n      lident !== \"__type__\" &&\n      lident !== \"__std__\" &&\n      reservedKeywords.includes(lident);\n\n    if (!isReserved) {\n      return ident;\n    }\n  }\n\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\n\nfunction bufferToStringRep(buf: Buffer): string {\n  let stringRep = \"\";\n  for (const byte of buf) {\n    if (byte < 32 || byte > 126) {\n      // non printable ascii\n      switch (byte) {\n        case 8:\n          stringRep += \"\\\\b\";\n          break;\n        case 9:\n          stringRep += \"\\\\t\";\n          break;\n        case 10:\n          stringRep += \"\\\\n\";\n          break;\n        case 12:\n          stringRep += \"\\\\f\";\n          break;\n        case 13:\n          stringRep += \"\\\\r\";\n          break;\n        default:\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n      }\n    } else {\n      stringRep +=\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n    }\n  }\n  return `b'${stringRep}'`;\n}\n\nfunction getErrorHint(expr: any): string {\n  let literalConstructor: string | null = null;\n  switch (typeof expr) {\n    case \"string\":\n      literalConstructor = \"e.str()\";\n      break;\n    case \"number\":\n      literalConstructor = Number.isInteger(expr)\n        ? \"e.int64()\"\n        : \"e.float64()\";\n      break;\n    case \"bigint\":\n      literalConstructor = \"e.bigint()\";\n      break;\n    case \"boolean\":\n      literalConstructor = \"e.bool()\";\n      break;\n  }\n  switch (true) {\n    case expr instanceof Date:\n      literalConstructor = \"e.datetime()\";\n      break;\n    case expr instanceof Duration:\n      literalConstructor = \"e.duration()\";\n      break;\n    case expr instanceof LocalDate:\n      literalConstructor = \"e.cal.local_date()\";\n      break;\n    case expr instanceof LocalDateTime:\n      literalConstructor = \"e.cal.local_datetime()\";\n      break;\n    case expr instanceof LocalTime:\n      literalConstructor = \"e.cal.local_time()\";\n      break;\n    case expr instanceof RelativeDuration:\n      literalConstructor = \"e.cal.relative_duration()\";\n      break;\n    case expr instanceof DateDuration:\n      literalConstructor = \"e.cal.date_duration()\";\n      break;\n  }\n\n  return literalConstructor\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\n        `a '${literalConstructor}' expression?`\n    : \"\";\n}\n"},{"path":"update.mts","content":"import {\n  Expression,\n  ExpressionKind,\n  ObjectTypePointers,\n  TypeSet,\n  ObjectTypeSet,\n  stripBacklinks,\n  stripNonUpdateables,\n  typeutil,\n  ObjectTypeExpression,\n  $scopify,\n  Cardinality,\n} from \"edgedb/dist/reflection/index.js\";\nimport type {pointerToAssignmentExpression} from \"./casting.mjs\";\nimport {$expressionify, $getScopedExpr} from \"./path.mjs\";\nimport {\n  SelectModifiers,\n  NormalisedSelectModifiers,\n  ComputeSelectCardinality,\n  $existingScopes,\n  $handleModifiers,\n} from \"./select.mjs\";\nimport {$normaliseInsertShape, pointerIsOptional} from \"./insert.mjs\";\n\n/////////////////\n/// UPDATE\n/////////////////\n\nexport type $expr_Update<\n  Set extends TypeSet = TypeSet,\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Shape extends UpdateShape<Expr> = any\n> = Expression<{\n  __kind__: ExpressionKind.Update;\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: Expr;\n  __shape__: Shape;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__: ObjectTypeExpression;\n}>;\n\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\n> extends infer Shape\n  ? Shape extends ObjectTypePointers\n    ? {\n        [k in keyof Shape]?:\n          | (\n              | pointerToAssignmentExpression<Shape[k]>\n              | (Shape[k][\"cardinality\"] extends\n                  | Cardinality.Many\n                  | Cardinality.AtLeastOne\n                  ?\n                      | {\"+=\": pointerToAssignmentExpression<Shape[k], true>}\n                      | {\"-=\": pointerToAssignmentExpression<Shape[k], true>}\n                  : never)\n            )\n          | (pointerIsOptional<Shape[k]> extends true\n              ? undefined | null\n              : never);\n      }\n    : never\n  : never;\n\nexport function update<\n  Expr extends ObjectTypeExpression,\n  Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n  }\n  // SetShape extends UpdateShape<Expr>,\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\n>(\n  expr: Expr,\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n): $expr_Update<\n  {\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n  },\n  Expr,\n  Shape[\"set\"]\n> {\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const scope = $getScopedExpr(expr as any, $existingScopes);\n\n  const resolvedShape = shape(scope);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const mods: any = {};\n  let updateShape: any | null;\n  for (const [key, val] of Object.entries(resolvedShape)) {\n    if (key === \"filter\") {\n      mods[key] = val;\n    } else if (key === \"set\") {\n      updateShape = val;\n    } else {\n      throw new Error(\n        `Invalid update shape key '${key}', only 'filter', ` +\n          `and 'set' are allowed`\n      );\n    }\n  }\n\n  if (!updateShape) {\n    throw new Error(`Update shape must contain 'set' shape`);\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Update,\n    __element__: expr.__element__,\n    __cardinality__: cardinality,\n    __expr__: expr,\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\n    __modifiers__: modifiers,\n    __scope__: scope,\n  }) as any;\n}\n"},{"path":"with.mts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/dist/reflection/index.js\";\nimport type {$expr_Select} from \"./select.mjs\";\nimport type {$expr_For} from \"./for.mjs\";\nimport type {$expr_Insert} from \"./insert.mjs\";\nimport type {$expr_Update} from \"./update.mjs\";\nimport type {$expr_Group} from \"./group.mjs\";\nimport {$expressionify} from \"./path.mjs\";\n\nexport type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Alias;\n  __expr__: Expr;\n}>;\n\nexport function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.Alias,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n  }) as any;\n}\n\nexport type WithableExpression =\n  | $expr_Select\n  | $expr_For\n  | $expr_Insert\n  | $expr_Update\n  | $expr_Group;\n\nexport type $expr_With<\n  Refs extends TypeSet[] = TypeSet[],\n  Expr extends WithableExpression = WithableExpression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.With;\n  __expr__: Expr;\n  __refs__: Refs;\n}>;\n\nfunction _with<Refs extends Expression[], Expr extends WithableExpression>(\n  refs: Refs,\n  expr: Expr\n): $expr_With<Refs, Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.With,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __refs__: refs,\n    __expr__: expr as any,\n  }) as any;\n}\n\nexport {_with as with};\n"}],"ts":[{"path":"cast.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  TypeSet,\n  Cardinality,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\nimport type {orScalarLiteral} from \"../castMaps\";\nimport {literalToTypeSet} from \"../castMaps\";\n\nexport function cast<Target extends BaseType>(\n  target: Target,\n  arg: null\n): $expr_Cast<Target, TypeSet<Target, Cardinality.Empty>>;\nexport function cast<Target extends BaseType, Expr extends TypeSet>(\n  target: Target,\n  expr: orScalarLiteral<Expr>\n): $expr_Cast<Target, Expr>;\nexport function cast(target: BaseType, expr: any) {\n  const cleanedExpr = expr === null ? null : literalToTypeSet(expr);\n  return $expressionify({\n    __element__: target,\n    __cardinality__:\n      cleanedExpr === null ? Cardinality.Empty : cleanedExpr.__cardinality__,\n    __expr__: cleanedExpr,\n    __kind__: ExpressionKind.Cast,\n  }) as any;\n}\n\nexport type $expr_Cast<\n  Target extends BaseType = BaseType,\n  Expr extends TypeSet = TypeSet\n> = Expression<{\n  __element__: Target;\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Cast;\n  __expr__: Expr | null;\n}>;\n"},{"path":"casting.ts","content":"import type {\n  ArrayType,\n  BaseType,\n  BaseTypeTuple,\n  BaseTypeToTsType,\n  cardinalityUtil,\n  Cardinality,\n  EnumType,\n  LinkDesc,\n  NamedTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  TupleType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/dist/reflection/index\";\nimport type {\n  scalarCastableFrom,\n  scalarAssignableBy,\n} from \"../castMaps\";\n\nexport type anonymizeObject<T extends ObjectType> = ObjectType<\n  string,\n  T[\"__pointers__\"],\n  any\n>;\n\n////////////////\n// ASSIGNABLE\n////////////////\n\ntype assignableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? assignableBy<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type assignableBy<T extends BaseType> = T extends ScalarType\n  ? scalarAssignableBy<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends EnumType\n  ? T\n  : T extends ArrayType\n  ? ArrayType<assignableBy<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<assignableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: assignableBy<T[\"__shape__\"][k]>;\n    }>\n  : T extends RangeType\n  ? RangeType<\n      scalarAssignableBy<T[\"__element__\"]> extends ScalarType\n        ? scalarAssignableBy<T[\"__element__\"]>\n        : never\n    >\n  : never;\n\nexport type pointerToAssignmentExpression<\n  Pointer extends PropertyDesc | LinkDesc,\n  IsSetModifier extends boolean = false\n> = setToAssignmentExpression<\n  TypeSet<Pointer[\"target\"], Pointer[\"cardinality\"]>,\n  IsSetModifier\n>;\n\nexport type setToAssignmentExpression<\n  Set extends TypeSet,\n  IsSetModifier extends boolean\n> = [Set] extends [PrimitiveTypeSet]\n  ?\n      | TypeSet<\n          assignableBy<Set[\"__element__\"]>,\n          cardinalityUtil.assignable<Set[\"__cardinality__\"]>\n        >\n      | getAssignmentLiteral<Set, IsSetModifier>\n  : [Set] extends [ObjectTypeSet]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Set[\"__element__\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<\n        // Allow expressions with AtMostOne or Many cardinality in\n        // insert/update shape even when link is required since EdgeDB will\n        // assert cardinality at runtime\n        cardinalityUtil.overrideLowerBound<Set[\"__cardinality__\"], \"Zero\">\n      >\n    >\n  : never;\n\ntype getAssignmentLiteral<\n  Set extends PrimitiveTypeSet,\n  IsSetModifier extends boolean\n> = BaseTypeToTsType<Set[\"__element__\"]> extends infer TsType\n  ?\n      | TsType\n      | (Set[\"__cardinality__\"] extends Cardinality.Many\n          ? TsType[]\n          : Set[\"__cardinality__\"] extends Cardinality.AtLeastOne\n          ? IsSetModifier extends true\n            ? TsType[]\n            : [TsType, ...TsType[]]\n          : never)\n  : never;\n\n////////////////\n// CASTABLES\n////////////////\n\ntype castableTuple<Items extends BaseTypeTuple> = {\n  [k in keyof Items]: Items[k] extends BaseType\n    ? castableFrom<Items[k]>\n    : never;\n} extends infer NewItems\n  ? NewItems extends BaseTypeTuple\n    ? NewItems\n    : never\n  : never;\n\nexport type castableFrom<T extends BaseType> = T extends ScalarType\n  ? scalarCastableFrom<T>\n  : T extends ObjectType\n  ? anonymizeObject<T>\n  : T extends ArrayType\n  ? ArrayType<castableFrom<T[\"__element__\"]>>\n  : T extends TupleType\n  ? TupleType<castableTuple<T[\"__items__\"]>>\n  : T extends NamedTupleType\n  ? NamedTupleType<{\n      [k in keyof T[\"__shape__\"]]: castableFrom<T[\"__shape__\"][k]>;\n    }>\n  : never;\n\nexport type pointerToCastableExpression<\n  Pointer extends PropertyDesc | LinkDesc\n> = [Pointer] extends [PropertyDesc]\n  ? {\n      __element__: castableFrom<Pointer[\"target\"]>;\n      __cardinality__: cardinalityUtil.assignable<Pointer[\"cardinality\"]>;\n    }\n  : [Pointer] extends [LinkDesc]\n  ? TypeSet<\n      ObjectType<\n        // anonymize the object type\n        string,\n        Pointer[\"target\"][\"__pointers__\"]\n      >,\n      cardinalityUtil.assignable<Pointer[\"cardinality\"]>\n    >\n  : never;\n"},{"path":"collections.ts","content":"import {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  ArrayType,\n  BaseType,\n  Cardinality,\n  cardinalityUtil,\n  ExpressionKind,\n  ExpressionRoot,\n  getPrimitiveBaseType,\n  NamedTupleLiteralShape,\n  NamedTupleShape,\n  NamedTupleType,\n  NonArrayType,\n  TupleType,\n  TypeKind,\n  TypeSet,\n  typeutil,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\nimport type {getCardsFromExprs} from \"./set\";\nimport {\n  literalToScalarType,\n  literalToTypeSet,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n  scalarLiterals,\n} from \"../castMaps\";\n\nconst indexSliceRegx = /^(-?\\d+)(?:(:)(-?\\d+)?)?|:(-?\\d+)$/;\n\nconst arrayLikeProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const match = typeof prop === \"string\" ? prop.match(indexSliceRegx) : null;\n    if (match) {\n      const start = match[1];\n      const end = match[3] ?? match[4];\n      const isIndex = start && !match[2];\n      return $expressionify({\n        __kind__: ExpressionKind.Operator,\n        __element__:\n          target.__element__.__kind__ === TypeKind.array && isIndex\n            ? (target.__element__ as ArrayType).__element__\n            : target.__element__,\n        __cardinality__: target.__cardinality__,\n        __name__: \"[]\",\n        __opkind__: \"Infix\",\n        __args__: [\n          proxy,\n          isIndex\n            ? literalToTypeSet(Number(start))\n            : [\n                start && literalToTypeSet(Number(start)),\n                end && literalToTypeSet(Number(end)),\n              ],\n        ],\n      }) as any;\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction arrayLikeIndex(this: ExpressionRoot, index: any) {\n  const indexTypeSet = literalToTypeSet(index);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__:\n      this.__element__.__kind__ === TypeKind.array\n        ? (this.__element__ as ArrayType).__element__\n        : this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      indexTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, indexTypeSet],\n  }) as any;\n}\n\nfunction arrayLikeSlice(this: ExpressionRoot, start: any, end: any) {\n  const startTypeSet = start && literalToTypeSet(start);\n  const endTypeSet = end && literalToTypeSet(end);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.multiplyCardinalities(\n        this.__cardinality__,\n        startTypeSet?.__cardinality__ ?? Cardinality.One\n      ),\n      endTypeSet?.__cardinality__ ?? Cardinality.One\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, [startTypeSet, endTypeSet]],\n  }) as any;\n}\n\nexport function $arrayLikeIndexify(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.array ||\n    (_expr.__element__.__kind__ === TypeKind.scalar &&\n      (_expr.__element__.__name__ === \"std::str\" ||\n        _expr.__element__.__name__ === \"std::bytes\"))\n  ) {\n    const expr = new Proxy(_expr, arrayLikeProxyHandlers) as any;\n\n    expr.index = arrayLikeIndex.bind(expr);\n    expr.slice = arrayLikeSlice.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\n// ARRAY\nexport function array<Element extends NonArrayType>(\n  element: Element\n): ArrayType<Element>;\nexport function array<\n  Expr extends TypeSet<NonArrayType> | scalarLiterals,\n  Exprs extends orScalarLiteral<\n    TypeSet<\n      Expr extends TypeSet\n        ? getPrimitiveBaseType<Expr[\"__element__\"]>\n        : getPrimitiveBaseType<literalToScalarType<Expr>>\n    >\n  >[]\n>(\n  arg: [Expr, ...Exprs]\n): $expr_Array<\n  ArrayType<\n    Expr extends TypeSet\n      ? getPrimitiveBaseType<Expr[\"__element__\"]>\n      : getPrimitiveBaseType<literalToScalarType<Expr>>\n  >,\n  cardinalityUtil.multiplyCardinalitiesVariadic<\n    getCardsFromExprs<mapLiteralToTypeSet<[Expr, ...Exprs]>>\n  >\n>;\nexport function array(arg: any) {\n  if (Array.isArray(arg)) {\n    const items = arg.map(a => literalToTypeSet(a));\n    return $expressionify({\n      __kind__: ExpressionKind.Array,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(item => item.__cardinality__) as any\n      ),\n      __element__: {\n        __kind__: TypeKind.array,\n        __name__: `array<${items[0].__element__.__name__}>`,\n        __element__: items[0].__element__,\n      } as any,\n      __items__: items,\n    });\n  }\n  if (arg.__kind__) {\n    return {\n      __kind__: TypeKind.array,\n      __name__: `array<${arg.__name__}>`,\n      __element__: arg,\n    } as any;\n  }\n\n  throw new Error(\"Invalid array input.\");\n}\n\n// TUPLE\n\nconst tupleProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    const type = target.__element__;\n    const items =\n      type.__kind__ === TypeKind.tuple\n        ? (type as TupleType).__items__\n        : type.__kind__ === TypeKind.namedtuple\n        ? (type as NamedTupleType).__shape__\n        : null;\n    return items?.hasOwnProperty(prop)\n      ? tuplePath(proxy, (items as any)[prop], prop as any)\n      : (target as any)[prop];\n  },\n};\n\nexport function $tuplePathify(expr: ExpressionRoot) {\n  if (\n    expr.__element__.__kind__ !== TypeKind.tuple &&\n    expr.__element__.__kind__ !== TypeKind.namedtuple\n  ) {\n    return expr;\n  }\n\n  return new Proxy(expr, tupleProxyHandlers);\n}\n\nfunction tuplePath(\n  parent: $expr_Tuple | $expr_TuplePath,\n  itemType: BaseType,\n  index: string\n): $expr_TuplePath {\n  return $expressionify({\n    __kind__: ExpressionKind.TuplePath,\n    __element__: itemType,\n    __cardinality__: parent.__cardinality__,\n    __parent__: parent,\n    __index__: index,\n  }) as any;\n}\n\nfunction makeTupleType(name: string, items: BaseType[]) {\n  return {\n    __kind__: TypeKind.tuple,\n    __name__: name,\n    __items__: items,\n  } as any;\n}\n\nconst typeKinds = new Set(Object.values(TypeKind));\n\nexport function tuple<Items extends typeutil.tupleOf<BaseType>>(\n  items: Items\n): TupleType<Items>;\nexport function tuple<\n  Item extends TypeSet | scalarLiterals,\n  Items extends typeutil.tupleOf<TypeSet | scalarLiterals>\n>(\n  items: Items\n): $expr_Tuple<\n  Items extends typeutil.tupleOf<any> ? mapLiteralToTypeSet<Items> : never\n>;\nexport function tuple<Shape extends NamedTupleShape>(\n  shape: Shape\n): NamedTupleType<Shape>;\nexport function tuple<Shape extends {[k: string]: TypeSet | scalarLiterals}>(\n  shape: Shape\n): $expr_NamedTuple<mapLiteralToTypeSet<Shape>>;\nexport function tuple(input: any) {\n  if (Array.isArray(input)) {\n    // is tuple\n    if (input.every(item => typeKinds.has(item.__kind__))) {\n      const typeItems = input as BaseType[];\n      const typeName = `tuple<${typeItems\n        .map(item => item.__name__)\n        .join(\", \")}>`;\n      return makeTupleType(typeName, typeItems);\n    }\n\n    const items = input.map(item => literalToTypeSet(item));\n    const name = `tuple<${items\n      .map(item => item.__element__.__name__)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.Tuple,\n      __element__: makeTupleType(\n        name,\n        items.map(item => item.__element__)\n      ),\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        items.map(i => i.__cardinality__) as any\n      ),\n      __items__: items,\n    }) as any;\n  } else {\n    // is named tuple\n    if (Object.values(input).every((el: any) => typeKinds.has(el.__kind__))) {\n      const typeName = `tuple<${Object.entries(input)\n        .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n        .join(\", \")}>`;\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: typeName,\n        __shape__: input,\n      } as any;\n    }\n\n    const exprShape: NamedTupleLiteralShape = {};\n    const typeShape: NamedTupleShape = {};\n    for (const [key, val] of Object.entries(input)) {\n      exprShape[key] = literalToTypeSet(val);\n      typeShape[key] = exprShape[key].__element__;\n    }\n    const name = `tuple<${Object.entries(exprShape)\n      .map(([key, val]) => `${key}: ${val.__element__.__name__}`)\n      .join(\", \")}>`;\n    return $expressionify({\n      __kind__: ExpressionKind.NamedTuple,\n      __element__: {\n        __kind__: TypeKind.namedtuple,\n        __name__: name,\n        __shape__: typeShape,\n      } as any,\n      __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(\n        Object.values(exprShape).map(val => val.__cardinality__) as any\n      ),\n      __shape__: exprShape,\n    }) as any;\n  }\n}\n\nexport type {\n  ArrayType as $Array,\n  NamedTupleType as $NamedTuple,\n  TupleType as $Tuple,\n} from \"edgedb/dist/reflection/index\";\n"},{"path":"detached.ts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\n\nexport function detached<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Detached<Expr> {\n  return $expressionify({\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n    __kind__: ExpressionKind.Detached,\n  }) as any;\n}\n\nexport type $expr_Detached<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Detached;\n  __expr__: Expr;\n}>;\n"},{"path":"external.ts","content":"import type {TypeSet, setToTsType} from \"edgedb/dist/reflection/index\";\n\nexport {literal} from \"./literal\";\nexport {} from \"./path\";\nexport {set} from \"./set\";\nexport {cast} from \"./cast\";\nexport {\n  ASC,\n  DESC,\n  EMPTY_FIRST,\n  EMPTY_LAST,\n  is,\n  delete,\n  select,\n} from \"./select\";\nexport {update} from \"./update\";\nexport {insert} from \"./insert\";\nexport {array, tuple} from \"./collections\";\nexport {} from \"./funcops\";\nexport {for} from \"./for\";\nexport {alias, with} from \"./with\";\nexport {optional, params} from \"./params\";\nexport {detached} from \"./detached\";\nexport {} from \"./toEdgeQL\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"for.ts","content":"import {\n  Expression,\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  ExpressionKind,\n  cardinalityUtil,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\n\nexport type $expr_For<\n  IterSet extends BaseTypeSet = BaseTypeSet,\n  Expr extends Expression = Expression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: cardinalityUtil.multiplyCardinalities<\n    IterSet[\"__cardinality__\"],\n    Expr[\"__cardinality__\"]\n  >;\n  __kind__: ExpressionKind.For;\n  __iterSet__: IterSet;\n  __forVar__: $expr_ForVar;\n  __expr__: Expr;\n}>;\n\nexport type $expr_ForVar<Type extends BaseType = BaseType> = Expression<{\n  __element__: Type;\n  __cardinality__: Cardinality.One;\n  __kind__: ExpressionKind.ForVar;\n}>;\n\nfunction _for<IteratorSet extends BaseTypeSet, Expr extends Expression>(\n  set: IteratorSet,\n  expr: (variable: $expr_ForVar<IteratorSet[\"__element__\"]>) => Expr\n): $expr_For<IteratorSet, Expr> {\n  const forVar = $expressionify({\n    __kind__: ExpressionKind.ForVar,\n    __element__: set.__element__,\n    __cardinality__: Cardinality.One,\n  }) as $expr_ForVar<IteratorSet[\"__element__\"]>;\n\n  const returnExpr = expr(forVar);\n\n  return $expressionify({\n    __kind__: ExpressionKind.For,\n    __element__: returnExpr.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      set.__cardinality__,\n      returnExpr.__cardinality__\n    ),\n    __iterSet__: set,\n    __expr__: returnExpr,\n    __forVar__: forVar,\n  }) as any;\n}\n\nexport {_for as for};\n"},{"path":"funcops.ts","content":"import {\n  BaseType,\n  BaseTypeSet,\n  Cardinality,\n  introspect,\n  makeType,\n  TypeKind,\n  ArrayType,\n  cardinalityUtil,\n  ObjectType,\n  TypeSet,\n  RangeType,\n} from \"edgedb/dist/reflection/index\";\nimport {cast} from \"./cast\";\nimport {isImplicitlyCastableTo, literalToTypeSet} from \"../castMaps\";\nimport {literal} from \"./literal\";\n\ninterface OverloadFuncArgDef {\n  typeId: string;\n  optional?: boolean;\n  setoftype?: boolean;\n  variadic?: boolean;\n}\n\ninterface OverloadFuncDef {\n  kind?: string;\n  args: OverloadFuncArgDef[];\n  namedArgs?: {[key: string]: OverloadFuncArgDef};\n  returnTypeId: string;\n  returnTypemod?: \"SetOfType\" | \"OptionalType\";\n  preservesOptionality?: boolean;\n}\n\nfunction mapLiteralToTypeSet(literals: any[]): TypeSet[];\nfunction mapLiteralToTypeSet(literals: {[key: string]: any}): {\n  [key: string]: TypeSet;\n};\nfunction mapLiteralToTypeSet(literals: any[] | {[key: string]: any}) {\n  if (Array.isArray(literals)) {\n    return literals.map(lit => (lit != null ? literalToTypeSet(lit) : lit));\n  }\n  const obj: {[key: string]: TypeSet} = {};\n  for (const key of Object.keys(literals)) {\n    obj[key] =\n      literals[key] != null ? literalToTypeSet(literals[key]) : literals[key];\n  }\n  return obj;\n}\n\nexport function $resolveOverload(\n  funcName: string,\n  args: any[],\n  typeSpec: introspect.Types,\n  funcDefs: OverloadFuncDef[]\n) {\n  const positionalArgs: (TypeSet | undefined)[] = [];\n  let namedArgs: {[key: string]: TypeSet} | undefined;\n  if (args.length) {\n    if (args[0] !== undefined) {\n      try {\n        positionalArgs.push(literalToTypeSet(args[0]));\n      } catch {\n        // first arg is not a expr or literal type, so assume named args object\n        namedArgs = mapLiteralToTypeSet(args[0] as object);\n      }\n    } else {\n      positionalArgs.push(undefined);\n    }\n    positionalArgs.push(...mapLiteralToTypeSet(args.slice(1)));\n  }\n\n  for (const def of funcDefs) {\n    const resolvedOverload = _tryOverload(\n      funcName,\n      positionalArgs,\n      namedArgs,\n      typeSpec,\n      def\n    );\n    if (resolvedOverload !== null) {\n      return resolvedOverload;\n    }\n  }\n\n  throw new Error(\n    `No function overload found for ${\n      funcName.includes(\"::\")\n        ? `'e.${funcName.split(\"::\")[1]}()'`\n        : `operator '${funcName}'`\n    } with args: ${args.map(arg => `${arg}`).join(\", \")}`\n  );\n}\n\nconst ANYTYPE_ARG = Symbol();\n\nfunction _tryOverload(\n  funcName: string,\n  args: (BaseTypeSet | undefined)[],\n  namedArgs: {[key: string]: BaseTypeSet} | undefined,\n  typeSpec: introspect.Types,\n  funcDef: OverloadFuncDef\n): {\n  kind?: string;\n  returnType: BaseType;\n  cardinality: Cardinality;\n  args: BaseTypeSet[];\n  namedArgs: {[key: string]: BaseTypeSet};\n} | null {\n  if (\n    (funcDef.namedArgs === undefined && namedArgs !== undefined) ||\n    (namedArgs === undefined &&\n      funcDef.namedArgs &&\n      Object.values(funcDef.namedArgs).some(arg => !arg.optional))\n  ) {\n    return null;\n  }\n\n  const lastParamVariadic = funcDef.args[funcDef.args.length - 1]?.variadic;\n  if (!lastParamVariadic && args.length > funcDef.args.length) {\n    return null;\n  }\n\n  const paramCardinalities: [Cardinality, ...Cardinality[]] = [\n    Cardinality.One,\n  ];\n\n  if (namedArgs) {\n    for (const [key, value] of Object.entries(namedArgs)) {\n      const argDef = funcDef.namedArgs?.[key];\n      if (\n        !argDef ||\n        !compareType(typeSpec, argDef.typeId, value.__element__).match\n      ) {\n        return null;\n      }\n\n      paramCardinalities.push(\n        argDef.setoftype\n          ? funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(value.__cardinality__, \"One\")\n            : Cardinality.One\n          : argDef.optional\n          ? cardinalityUtil.overrideLowerBound(value.__cardinality__, \"One\")\n          : value.__cardinality__\n      );\n    }\n  }\n\n  let positionalArgs: BaseTypeSet[] = [];\n\n  let returnAnytype: BaseType | undefined;\n  let needsAnytypeReplacement = false;\n\n  for (let i = 0; i < funcDef.args.length; i++) {\n    const argDef = funcDef.args[i];\n    const arg = args[i];\n\n    if (arg === undefined) {\n      if (!argDef.optional) {\n        return null;\n      }\n\n      if (i < args.length) {\n        // arg is explicitly undefined, inject empty set\n        const argTypeName = typeSpec.get(argDef.typeId).name;\n        if (\n          argTypeName.includes(\"anytype\") ||\n          argTypeName.includes(\"std::anypoint\")\n        ) {\n          if (!returnAnytype) {\n            positionalArgs.push(ANYTYPE_ARG as any);\n            needsAnytypeReplacement = true;\n          } else {\n            positionalArgs.push(cast(returnAnytype, null));\n          }\n        } else {\n          const argType = makeType<any>(typeSpec, argDef.typeId, literal);\n          positionalArgs.push(cast(argType, null));\n        }\n      }\n    } else {\n      const {match, anytype} = compareType(\n        typeSpec,\n        argDef.typeId,\n        arg.__element__\n      );\n\n      if (!match) {\n        return null;\n      }\n      if (!returnAnytype && anytype) {\n        returnAnytype = anytype;\n      }\n\n      positionalArgs.push(\n        ...(argDef.variadic ? (args.slice(i) as BaseTypeSet[]) : [arg])\n      );\n      if (argDef.setoftype) {\n        paramCardinalities.push(\n          funcDef.preservesOptionality\n            ? cardinalityUtil.overrideUpperBound(arg.__cardinality__, \"One\")\n            : Cardinality.One\n        );\n      } else {\n        const card = argDef.variadic\n          ? cardinalityUtil.multiplyCardinalitiesVariadic(\n              (args.slice(i) as BaseTypeSet[]).map(\n                el => el.__cardinality__\n              ) as [Cardinality, ...Cardinality[]]\n            )\n          : arg.__cardinality__;\n\n        paramCardinalities.push(\n          argDef.optional\n            ? cardinalityUtil.overrideLowerBound(card, \"One\")\n            : card\n        );\n      }\n    }\n  }\n\n  let cardinality: Cardinality;\n  if (funcName === \"if_else\") {\n    cardinality = cardinalityUtil.multiplyCardinalities(\n      cardinalityUtil.orCardinalities(\n        positionalArgs[0].__cardinality__,\n        positionalArgs[2].__cardinality__\n      ),\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"std::assert_exists\") {\n    cardinality = cardinalityUtil.overrideLowerBound(\n      positionalArgs[0].__cardinality__,\n      \"One\"\n    );\n  } else if (funcName === \"union\") {\n    cardinality = cardinalityUtil.mergeCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"??\") {\n    cardinality = cardinalityUtil.orCardinalities(\n      positionalArgs[0].__cardinality__,\n      positionalArgs[1].__cardinality__\n    );\n  } else if (funcName === \"distinct\") {\n    cardinality = positionalArgs[0].__cardinality__;\n  } else {\n    cardinality =\n      funcDef.returnTypemod === \"SetOfType\"\n        ? Cardinality.Many\n        : cardinalityUtil.multiplyCardinalitiesVariadic(paramCardinalities);\n\n    if (\n      funcDef.returnTypemod === \"OptionalType\" &&\n      !funcDef.preservesOptionality\n    ) {\n      cardinality = cardinalityUtil.overrideLowerBound(cardinality, \"Zero\");\n    }\n  }\n\n  if (needsAnytypeReplacement) {\n    if (!returnAnytype) {\n      throw new Error(`could not resolve anytype for ${funcName}`);\n    }\n    positionalArgs = positionalArgs.map(arg =>\n      (arg as any) === ANYTYPE_ARG ? cast(returnAnytype!, null) : arg\n    );\n  }\n\n  return {\n    kind: funcDef.kind,\n    returnType: makeType(\n      typeSpec,\n      funcDef.returnTypeId,\n      literal,\n      returnAnytype\n    ),\n    cardinality,\n    args: positionalArgs,\n    namedArgs: namedArgs ?? {},\n  };\n}\n\nconst nameRemapping: {[key: string]: string} = {\n  \"std::int16\": \"std::number\",\n  \"std::int32\": \"std::number\",\n  \"std::int64\": \"std::number\",\n  \"std::float32\": \"std::number\",\n  \"std::float64\": \"std::number\",\n};\nconst descendantCache = new Map<string, string[]>();\nfunction getDescendantNames(typeSpec: introspect.Types, typeId: string) {\n  if (descendantCache.has(typeId)) {\n    return descendantCache.get(typeId)!;\n  }\n  const descendants: string[] = [\n    ...new Set(\n      [...typeSpec.values()]\n        .filter(\n          type =>\n            type.kind === \"scalar\" && type.bases.some(({id}) => id === typeId)\n        )\n        .flatMap(type =>\n          type.is_abstract\n            ? getDescendantNames(typeSpec, type.id)\n            : [nameRemapping[type.name], type.name]\n        )\n    ),\n  ];\n  descendantCache.set(typeId, descendants);\n  return descendants;\n}\n\nfunction compareType(\n  typeSpec: introspect.Types,\n  typeId: string,\n  arg: BaseType\n): {match: boolean; anytype?: BaseType} {\n  const type = typeSpec.get(typeId);\n\n  if (type.name === \"anytype\") {\n    return {match: true, anytype: arg};\n  }\n\n  if (type.name === \"std::anypoint\") {\n    const descendants = getDescendantNames(typeSpec, typeId);\n    if (descendants.includes(arg.__name__)) {\n      return {match: true, anytype: arg};\n    }\n  }\n\n  if (type.name === \"std::anyenum\") {\n    return {match: arg.__kind__ === TypeKind.enum};\n  }\n\n  if (type.kind === \"scalar\") {\n    arg = (arg as any).__casttype__ ?? arg;\n    return {\n      match:\n        (arg.__kind__ === TypeKind.scalar || arg.__kind__ === TypeKind.enum) &&\n        (arg.__name__ === type.name ||\n          isImplicitlyCastableTo(arg.__name__, type.name)),\n    };\n  }\n  if (type.kind === \"array\") {\n    if (arg.__kind__ === TypeKind.array) {\n      return compareType(\n        typeSpec,\n        type.array_element_id,\n        (arg as any as ArrayType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"range\") {\n    if (arg.__kind__ === TypeKind.range) {\n      return compareType(\n        typeSpec,\n        type.range_element_id,\n        (arg as any as RangeType).__element__ as BaseType\n      );\n    }\n  }\n  if (type.kind === \"object\") {\n    if (arg.__kind__ !== TypeKind.object) return {match: false};\n\n    const objectArg = arg as ObjectType;\n    let match = true;\n\n    // shape comparison\n    for (const ptr of type.pointers) {\n      if (objectArg.__pointers__[ptr.name]) {\n        const argPtr = objectArg.__pointers__[ptr.name];\n        const ptrTarget = typeSpec.get(ptr.target_id);\n        if (\n          ptrTarget.name !== argPtr.target.__name__ ||\n          ptr.real_cardinality !== argPtr.cardinality\n        ) {\n          match = false;\n        }\n      }\n    }\n\n    return {\n      match,\n    };\n  }\n  if (type.kind === \"tuple\") {\n    const items =\n      arg.__kind__ === TypeKind.tuple\n        ? (arg as any).__items__\n        : arg.__kind__ === TypeKind.namedtuple\n        ? (arg as any).__shape__\n        : null;\n    if (items) {\n      const keys = Object.keys(items);\n\n      if (keys.length === type.tuple_elements.length) {\n        let anytype: BaseType | undefined;\n        for (let i = 0; i < keys.length; i++) {\n          if (keys[i] !== type.tuple_elements[i].name) {\n            return {match: false};\n          }\n          const {match: m, anytype: a} = compareType(\n            typeSpec,\n            type.tuple_elements[i].target_id,\n            (items as any)[keys[i]]\n          );\n          if (!m) {\n            return {match: false};\n          }\n          if (a) anytype = a;\n        }\n        return {match: true, anytype};\n      }\n    }\n  }\n\n  return {match: false};\n}\n"},{"path":"globals.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  BaseType,\n  Cardinality,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\n\nexport function makeGlobal<\n  Name extends string,\n  Type extends BaseType,\n  Card extends Cardinality\n>(name: Name, type: Type, card: Card): $expr_Global<Name, Type, Card> {\n  return $expressionify({\n    __name__: name,\n    __element__: type,\n    __cardinality__: card,\n    __kind__: ExpressionKind.Global,\n  });\n}\n\nexport type $expr_Global<\n  Name extends string = string,\n  Type extends BaseType = BaseType,\n  Card extends Cardinality = Cardinality\n> = Expression<{\n  __name__: Name;\n  __element__: Type;\n  __cardinality__: Card;\n  __kind__: ExpressionKind.Global;\n}>;\n"},{"path":"group.ts","content":"import type {\n  Expression,\n  ObjectType,\n  ObjectTypeSet,\n  TypeSet,\n  BaseType,\n  $scopify,\n  PropertyDesc,\n  LinkDesc,\n  // stripSet,\n  // LinkDesc,\n} from \"edgedb/dist/reflection/index\";\nimport {\n  Cardinality,\n  ExpressionKind,\n  TypeKind,\n  makeType,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify, $getScopedExpr} from \"./path\";\n// @ts-ignore\nimport type {$FreeObjectλShape, $str} from \"../modules/std\";\nimport {spec} from \"../__spec__\";\nimport {literal} from \"./literal\";\nimport {resolveShapeElement} from \"./select\";\nimport type {\n  normaliseShape,\n  // normaliseElement,\n  objectTypeToSelectShape,\n} from \"./select\";\n\ntype SingletonSet = Expression<\n  TypeSet<BaseType, Cardinality.One | Cardinality.AtMostOne>\n>;\ntype SimpleGroupElements = {[k: string]: SingletonSet};\ntype GroupModifiers = {by: SimpleGroupElements};\ntype NestedGroupElements = {\n  [k: string]: SingletonSet | GroupingSet;\n};\n\nexport type GroupingSet = {\n  __kind__: \"groupingset\";\n  __settype__: \"set\" | \"tuple\" | \"rollup\" | \"cube\";\n  __elements__: NestedGroupElements;\n  __exprs__: [string, SingletonSet][];\n};\nexport function isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// result is partial to prevent \"X is specified more than once\" errors\n// the return type is a lie, this function returns a grouping set\n// but it pretends to return a SimpleGroupElements\n// to make the static computatation of `key` easier\nconst makeGroupingSet =\n  (prefix: string) =>\n  <T extends SimpleGroupElements>(grps: T): {[k in keyof T]?: T[k]} => {\n    const seenKeys = new Map<string, SingletonSet>();\n    const unfiltered = Object.entries(grps as NestedGroupElements).flatMap(\n      ([k, grp]) =>\n        isGroupingSet(grp)\n          ? grp.__exprs__\n          : ([[k, grp]] as [string, SingletonSet][])\n    );\n    const filtered = unfiltered.filter(([k, expr]) => {\n      if (!seenKeys.has(k)) {\n        seenKeys.set(k, expr);\n        return true;\n      }\n\n      if (expr !== seenKeys.get(k)) {\n        throw new Error(\n          `Cannot override pre-existing expression with key \"${k}\"`\n        );\n      }\n\n      return false;\n    });\n\n    return {\n      [`${Math.round(1000000 * Math.random())}___`]: {\n        __kind__: \"groupingset\",\n        __settype__: prefix,\n        __elements__: grps,\n        __exprs__: filtered,\n      } as GroupingSet,\n    } as any;\n  };\nconst set = makeGroupingSet(\"set\");\nconst tuple = makeGroupingSet(\"tuple\");\nconst rollup = makeGroupingSet(\"rollup\");\nconst cube = makeGroupingSet(\"cube\");\n\nconst setFuncs = {set, tuple, rollup, cube};\n\nexport type $expr_Group<\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Mods extends GroupModifiers = GroupModifiers,\n  Shape extends object = {id: true}\n> = Expression<{\n  __element__: ObjectType<\n    \"std::FreeObject\",\n    $FreeObjectλShape & {\n      // adding free shape elements into __pointers__\n      // because objectTypeToSelectShape doesn't allow shapes on computeds\n      // and setToTsType can't handle that currently\n      grouping: PropertyDesc<$str, Cardinality.Many, false, true, true, false>;\n      key: LinkDesc<\n        ObjectType<\n          \"std::FreeObject\",\n          {\n            // tslint:disable-next-line\n            [k in keyof Mods[\"by\"]]: Mods[\"by\"][k][\"__element__\"] extends ObjectType\n              ? never\n              : PropertyDesc<\n                  Mods[\"by\"][k][\"__element__\"],\n                  Cardinality.AtMostOne\n                >;\n          }\n        >,\n        Cardinality.One,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n      elements: LinkDesc<\n        Expr[\"__element__\"],\n        Cardinality.Many,\n        {},\n        false,\n        true,\n        true,\n        false\n      >;\n    },\n    {\n      // grouping: true;\n      // key: {[k in keyof Mods['by']]: true};\n      // elements: {id: true};\n      grouping: TypeSet<$str, Cardinality.Many>;\n      key: Expression<{\n        __element__: ObjectType<\n          \"std::FreeObject\",\n          $FreeObjectλShape,\n          {\n            [k in keyof Mods[\"by\"]]: Expression<{\n              __element__: Mods[\"by\"][k][\"__element__\"];\n              __cardinality__: Cardinality.AtMostOne;\n            }>;\n          }\n        >;\n        __cardinality__: Cardinality.One;\n      }>;\n      elements: Expression<{\n        __element__: ObjectType<\n          Expr[\"__element__\"][\"__name__\"],\n          Expr[\"__element__\"][\"__pointers__\"],\n          // Omit<normaliseShape<Shape>, \"by\">\n          normaliseShape<Shape, \"by\">\n        >;\n        __cardinality__: Cardinality.Many;\n      }>;\n    }\n  >;\n  __cardinality__: Cardinality.Many;\n  // bit of a lie, this is a GroupingSet at runtime\n  __modifiers__: Mods;\n  __kind__: ExpressionKind.Group;\n  __expr__: Expr;\n  __scope__: ObjectTypeSet;\n}>;\n\n// type modifierKeys = \"by\";\ntype noUndefined<T> = T extends undefined ? never : T;\ntype groupFunc = <\n  Expr extends ObjectTypeSet,\n  // Shape extends GroupModifiers\n  // Grps extends SimpleGroupElements,\n  Shape extends {by?: SimpleGroupElements} & objectTypeToSelectShape<\n    Expr[\"__element__\"]\n  >\n  // Mods extends GroupModifiers = {by: Shape[\"by\"]}\n>(\n  expr: Expr,\n  getter: (arg: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n) => $expr_Group<\n  Expr,\n  {by: noUndefined<Shape[\"by\"]>},\n  normaliseShape<Shape, \"by\">\n>;\n\nconst groupFunc: groupFunc = (expr, getter) => {\n  const {shape, scope, modifiers} = resolveShape(getter, expr);\n  // const scope = $getScopedExpr(expr as any);\n  // const rawGroupings = getter(scope);\n  const groupSet = tuple(modifiers.by);\n\n  // only one key in object returned from makeGroupingSet\n  const key = Object.keys(groupSet)[0];\n  const grouping = groupSet[key] as any as GroupingSet;\n  const keyShape: any = {};\n  const keyPointers: any = {};\n  const keyShapeElement: any = {};\n\n  for (const [k, e] of grouping.__exprs__) {\n    keyShape[k] = $expressionify({\n      __element__: e.__element__,\n      __cardinality__: Cardinality.AtMostOne,\n    } as any);\n    keyPointers[k] = {\n      __kind__: \"property\",\n      target: e.__element__,\n      cardinality: Cardinality.AtMostOne,\n      exclusive: false,\n      computed: false,\n      readonly: false,\n      hasDefault: false,\n    } as PropertyDesc;\n    keyShapeElement[k] = true;\n  }\n\n  const $FreeObject = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n    literal\n  );\n\n  const str = makeType(\n    spec,\n    [...spec.values()].find(s => s.name === \"std::str\")!.id,\n    literal\n  );\n\n  return $expressionify({\n    __element__: {\n      ...$FreeObject,\n      __name__: \"std::FreeObject\",\n      __pointers__: {\n        ...($FreeObject as any).__pointers__,\n        __name__: \"std::FreeObject\",\n        grouping: {\n          __kind__: \"property\",\n          target: str,\n          cardinality: Cardinality.Many,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as PropertyDesc,\n        key: {\n          __kind__: \"link\",\n          target: {\n            ...$FreeObject,\n            __name__: \"std::FreeObject\",\n            __pointers__: {\n              ...($FreeObject as any).__pointers__,\n              ...keyPointers,\n            },\n            __shape__: keyShape,\n          },\n          properties: {},\n          cardinality: Cardinality.One,\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n\n        elements: {\n          __kind__: \"link\",\n          target: expr.__element__,\n          cardinality: Cardinality.Many,\n          properties: {},\n          exclusive: false,\n          computed: false,\n          readonly: false,\n          hasDefault: false,\n        } as LinkDesc,\n      },\n      __shape__: {\n        grouping: $expressionify({\n          __element__: str,\n          __cardinality__: Cardinality.Many,\n        } as any),\n        key: $expressionify({\n          __element__: {\n            ...$FreeObject,\n            __shape__: keyShape,\n          },\n          __cardinality__: Cardinality.One,\n        } as any),\n        elements: $expressionify({\n          __element__: {...expr.__element__, __shape__: shape} as any,\n          __cardinality__: Cardinality.Many,\n        } as any),\n      },\n    },\n\n    __cardinality__: Cardinality.Many,\n    __expr__: expr,\n    __modifiers__: {by: grouping},\n    __kind__: ExpressionKind.Group,\n    __scope__: scope,\n  }) as any;\n};\nObject.assign(groupFunc, setFuncs);\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: {by: SimpleGroupElements}; shape: any; scope: TypeSet} {\n  const modifiers: {by: SimpleGroupElements} = {} as any;\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope = $getScopedExpr(expr as any) as ObjectTypeSet;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (key === \"by\") {\n      modifiers[key] = value as any;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  if (Object.keys(shape).length === 0) {\n    shape.id = true;\n  }\n  if (!modifiers.by) {\n    throw new Error(\"Must provide a `by` key in `e.group`\");\n  }\n  return {shape, modifiers, scope};\n}\nexport const group: typeof setFuncs & groupFunc = groupFunc as any;\n"},{"path":"insert.ts","content":"import {\n  Cardinality,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  ObjectTypeSet,\n  ObjectTypePointers,\n  PropertyDesc,\n  stripBacklinks,\n  stripNonInsertables,\n  typeutil,\n  $scopify,\n  stripSet,\n  TypeSet,\n  TypeKind,\n} from \"edgedb/dist/reflection/index\";\nimport type {pointerToAssignmentExpression} from \"./casting\";\nimport {$expressionify, $getScopedExpr} from \"./path\";\nimport {cast} from \"./cast\";\nimport {set} from \"./set\";\nimport {literal} from \"./literal\";\nimport {$getTypeByName} from \"./literal\";\nimport type {$expr_PathNode} from \"edgedb/dist/reflection/path\";\nimport type {$Object} from \"../modules/std\";\nimport type {scalarLiterals} from \"../castMaps\";\n\nexport type pointerIsOptional<T extends PropertyDesc | LinkDesc> =\n  T[\"cardinality\"] extends\n    | Cardinality.Many\n    | Cardinality.Empty\n    | Cardinality.AtMostOne\n    ? true\n    : false;\n\nexport type InsertShape<Root extends ObjectTypeSet> = typeutil.flatten<\n  RawInsertShape<Root>\n>;\n\nexport type RawInsertShape<Root extends ObjectTypeSet> =\n  // short-circuit infinitely deep\n  $expr_PathNode extends Root\n    ? never\n    : typeutil.stripNever<\n        stripNonInsertables<\n          stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>\n        >\n      > extends infer Shape\n    ? Shape extends ObjectTypePointers\n      ? typeutil.addQuestionMarks<{\n          [k in keyof Shape]:\n            | pointerToAssignmentExpression<Shape[k]>\n            | (pointerIsOptional<Shape[k]> extends true\n                ? undefined | null\n                : never)\n            | (Shape[k][\"hasDefault\"] extends true ? undefined : never);\n        }> & {[k in `@${string}`]: TypeSet | scalarLiterals}\n      : never\n    : never;\n\ninterface UnlessConflict {\n  on: TypeSet | null;\n  else?: TypeSet;\n}\n\ntype InsertBaseExpression<Root extends TypeSet = TypeSet> = {\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: stripSet<Root>;\n  __shape__: any;\n};\nexport type $expr_Insert<\n  Root extends $expr_PathNode = $expr_PathNode\n  // Conflict = UnlessConflict | null\n  // Shape extends InsertShape<Root> = any\n> = Expression<{\n  __kind__: ExpressionKind.Insert;\n  __element__: Root[\"__element__\"];\n  __cardinality__: Cardinality.One;\n  __expr__: Root;\n  __shape__: InsertShape<Root>;\n\n  unlessConflict(): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    {on: null}\n  >;\n  unlessConflict<Conflict extends UnlessConflict>(\n    conflictGetter: (scope: $scopify<Root[\"__element__\"]>) => Conflict\n  ): $expr_InsertUnlessConflict<\n    Expression<{\n      __kind__: ExpressionKind.Insert;\n      __element__: Root[\"__element__\"];\n      __cardinality__: Cardinality.One;\n      __expr__: Root;\n      __shape__: InsertShape<Root>;\n    }>,\n    Conflict\n  >;\n}>;\n\nexport type $expr_InsertUnlessConflict<\n  Root extends InsertBaseExpression = InsertBaseExpression,\n  Conflict extends UnlessConflict = UnlessConflict\n> = Expression<{\n  __kind__: ExpressionKind.InsertUnlessConflict;\n  __element__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__element__\"][\"__name__\"] extends Root[\"__element__\"][\"__name__\"]\n      ? Root[\"__element__\"]\n      : $Object\n    : Root[\"__element__\"];\n  __cardinality__: Conflict[\"else\"] extends TypeSet\n    ? Conflict[\"else\"][\"__cardinality__\"]\n    : Cardinality.AtMostOne;\n  __expr__: Root;\n  __conflict__: Conflict;\n}>;\n\nfunction unlessConflict(\n  this: $expr_Insert,\n  conflictGetter?: (scope: TypeSet) => UnlessConflict\n) {\n  const expr: any = {\n    __kind__: ExpressionKind.InsertUnlessConflict,\n    __element__: this.__element__,\n    __cardinality__: Cardinality.AtMostOne,\n    __expr__: this,\n    // __conflict__: Conflict;\n  };\n\n  if (!conflictGetter) {\n    expr.__conflict__ = {on: null};\n    return $expressionify(expr);\n  } else {\n    const scopedExpr = $getScopedExpr(this.__expr__);\n    const conflict = conflictGetter(scopedExpr);\n    expr.__conflict__ = conflict;\n    if (conflict.else) {\n      expr.__cardinality__ = conflict.else.__cardinality__;\n      if (this.__element__.__name__ !== conflict.else.__element__.__name__) {\n        expr.__element__ = $getTypeByName(\"std::Object\");\n      }\n    }\n    return $expressionify(expr);\n  }\n}\n\nexport function $insertify(\n  expr: Omit<$expr_Insert, \"unlessConflict\">\n): $expr_Insert {\n  (expr as any).unlessConflict = unlessConflict.bind(expr as any);\n  return expr as any;\n}\n\nexport function $normaliseInsertShape(\n  root: ObjectTypeSet,\n  shape: {[key: string]: any},\n  isUpdate: boolean = false\n): {[key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet}} {\n  const newShape: {\n    [key: string]: TypeSet | {\"+=\": TypeSet} | {\"-=\": TypeSet};\n  } = {};\n  for (const [key, _val] of Object.entries(shape)) {\n    let val = _val;\n    let setModify: string | null = null;\n    if (isUpdate && _val != null && typeof _val === \"object\") {\n      const valKeys = Object.keys(_val);\n      if (\n        valKeys.length === 1 &&\n        (valKeys[0] === \"+=\" || valKeys[0] === \"-=\")\n      ) {\n        val = _val[valKeys[0]];\n        setModify = valKeys[0];\n      }\n    }\n\n    const pointer = root.__element__.__pointers__[key];\n\n    // no pointer, not a link property\n    const isLinkProp = key[0] === \"@\";\n    if (!pointer && !isLinkProp) {\n      throw new Error(\n        `Could not find property pointer for ${\n          isUpdate ? \"update\" : \"insert\"\n        } shape key: '${key}'`\n      );\n    }\n\n    // skip undefined vals\n    if (val === undefined) continue;\n\n    // is val is expression, assign to newShape\n    if (val?.__kind__) {\n      // ranges can contain null values, so if the type is 'std::number'\n      // we need to set the type to the exact number type of the pointer\n      // so null casts are correct\n      if (\n        val.__kind__ === ExpressionKind.Literal &&\n        val.__element__.__kind__ === TypeKind.range &&\n        val.__element__.__element__.__name__ === \"std::number\"\n      ) {\n        newShape[key] = (literal as any)(pointer.target, val.__value__);\n      } else {\n        newShape[key] = _val;\n      }\n      continue;\n    }\n\n    // handle link props\n    // after this guard, pointer definitely is defined\n    if (isLinkProp) {\n      throw new Error(\n        `Cannot assign plain data to link property '${key}'. Provide an expression instead.`\n      );\n    }\n\n    // trying to assign plain data to a link\n    if (pointer.__kind__ !== \"property\" && val !== null) {\n      throw new Error(\n        `Must provide subquery when assigning to link '${key}' in ${\n          isUpdate ? \"update\" : \"insert\"\n        } query.`\n      );\n    }\n\n    // val is plain data\n    // key corresponds to pointer or starts with \"@\"\n    const isMulti =\n      pointer.cardinality === Cardinality.AtLeastOne ||\n      pointer.cardinality === Cardinality.Many;\n    if (pointer.__kind__ === \"property\") {\n      if (pointer.target.__name__ === \"std::json\") {\n      }\n    }\n\n    const wrappedVal =\n      val === null\n        ? cast(pointer.target, null)\n        : isMulti && Array.isArray(val)\n        ? val.length === 0\n          ? cast(pointer.target, null)\n          : set(...val.map(v => (literal as any)(pointer.target, v)))\n        : (literal as any)(pointer.target, val);\n    newShape[key] = setModify\n      ? ({[setModify]: wrappedVal} as any)\n      : wrappedVal;\n  }\n  return newShape;\n}\n\nexport function insert<Root extends $expr_PathNode>(\n  root: Root,\n  shape: InsertShape<Root>\n): $expr_Insert<Root> {\n  if (typeof shape !== \"object\") {\n    throw new Error(\n      `invalid insert shape.${\n        typeof shape === \"function\"\n          ? \" Hint: Insert shape is expected to be an object, \" +\n            \"not a function returning a shape object.\"\n          : \"\"\n      }`\n    );\n  }\n  const expr: any = {\n    __kind__: ExpressionKind.Insert,\n    __element__: root.__element__,\n    __cardinality__: Cardinality.One,\n    __expr__: root,\n    __shape__: $normaliseInsertShape(root, shape),\n  };\n  (expr as any).unlessConflict = unlessConflict.bind(expr);\n  return $expressionify($insertify(expr)) as any;\n}\n"},{"path":"json.ts","content":"import {ExpressionKind, ParamType, TypeKind} from \"edgedb/dist/reflection/index\";\nimport type {$expr_WithParams} from \"./params\";\n\nfunction jsonStringify(type: ParamType, val: any): string {\n  if (type.__kind__ === TypeKind.array) {\n    if (Array.isArray(val)) {\n      return `[${val\n        .map(item => jsonStringify(type.__element__, item))\n        .join()}]`;\n    }\n    throw new Error(`Param with array type is not an array`);\n  }\n  if (type.__kind__ === TypeKind.tuple) {\n    if (!Array.isArray(val)) {\n      throw new Error(`Param with tuple type is not an array`);\n    }\n    if (val.length !== type.__items__.length) {\n      throw new Error(\n        `Param with tuple type has incorrect number of items. Got ${val.length} expected ${type.__items__.length}`\n      );\n    }\n    return `[${val\n      .map((item, i) => jsonStringify(type.__items__[i], item))\n      .join()}]`;\n  }\n  if (type.__kind__ === TypeKind.namedtuple) {\n    if (typeof val !== \"object\") {\n      throw new Error(`Param with named tuple type is not an object`);\n    }\n    if (Object.keys(val).length !== Object.keys(type.__shape__).length) {\n      throw new Error(\n        `Param with named tuple type has incorrect number of items. Got ${\n          Object.keys(val).length\n        } expected ${Object.keys(type.__shape__).length}`\n      );\n    }\n    return `{${Object.entries(val)\n      .map(([key, item]) => {\n        if (!type.__shape__[key]) {\n          throw new Error(\n            `Unexpected key in named tuple param: ${key}, expected keys: ${Object.keys(\n              type.__shape__\n            ).join()}`\n          );\n        }\n        return `\"${key}\": ${jsonStringify(type.__shape__[key], item)}`;\n      })\n      .join()}}`;\n  }\n  if (\n    type.__kind__ === TypeKind.scalar\n    // || type.__kind__ === TypeKind.castonlyscalar\n  ) {\n    switch (type.__name__) {\n      case \"std::bigint\":\n        return val.toString();\n      case \"std::json\":\n        return JSON.stringify(val);\n      case \"std::bytes\":\n        return `\"${val.toString(\"base64\")}\"`;\n      case \"cfg::memory\":\n        return `\"${val.toString()}\"`;\n      default:\n        return JSON.stringify(val);\n    }\n  }\n  if (type.__kind__ === TypeKind.enum) {\n    return JSON.stringify(val);\n  }\n  throw new Error(`Invalid param type: ${(type as any).__kind__}`);\n}\n\nexport function jsonifyComplexParams(expr: any, _args: any) {\n  if (_args && expr.__kind__ === ExpressionKind.WithParams) {\n    const args = {..._args};\n    for (const param of (expr as $expr_WithParams).__params__) {\n      if (param.__isComplex__) {\n        args[param.__name__] = jsonStringify(\n          param.__element__ as any,\n          args[param.__name__]\n        );\n      }\n    }\n\n    return args;\n  }\n  return _args;\n}\n"},{"path":"literal.ts","content":"import {\n  Cardinality,\n  ExpressionKind,\n  BaseType,\n  BaseTypeToTsType,\n  makeType,\n  ScalarType,\n} from \"edgedb/dist/reflection/index\";\nimport type {$expr_Literal} from \"edgedb/dist/reflection/literal\";\nimport {$expressionify} from \"./path\";\nimport {spec} from \"../__spec__\";\n\nexport function literal<T extends BaseType>(\n  type: T,\n  value: BaseTypeToTsType<T>\n): $expr_Literal<T> {\n  return $expressionify({\n    __element__: type,\n    __cardinality__: Cardinality.One,\n    __kind__: ExpressionKind.Literal,\n    __value__: value,\n  }) as any;\n}\n\nexport const $nameMapping = new Map<string, string>([\n  ...([...spec.values()].map(type => [type.name, type.id]) as any),\n  [\"std::number\", \"00000000-0000-0000-0000-0000000001ff\"],\n]);\n\nexport function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, id, literal) as any;\n}\n\nexport function $getTypeByName(\n  name: string\n): (val: any) => $expr_Literal<ScalarType> {\n  return makeType(spec, $nameMapping.get(name)!, literal) as any;\n}\n"},{"path":"params.ts","content":"import type {Executor} from \"edgedb\";\nimport {\n  Expression,\n  ExpressionKind,\n  ParamType,\n  Cardinality,\n  setToTsType,\n  TypeSet,\n  TypeKind,\n  BaseTypeToTsType,\n} from \"edgedb/dist/reflection/index\";\nimport {$expressionify} from \"./path\";\n\nexport type $expr_OptionalParam<Type extends ParamType = ParamType> = {\n  __kind__: ExpressionKind.OptionalParam;\n  __type__: Type;\n};\n\nexport function optional<Type extends ParamType>(\n  type: Type\n): $expr_OptionalParam<Type> {\n  return {\n    __kind__: ExpressionKind.OptionalParam,\n    __type__: type,\n  };\n}\n\nexport type QueryableWithParamsExpression<\n  Set extends TypeSet = TypeSet,\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {}\n> = Expression<Set, false> & {\n  run(\n    cxn: Executor,\n    args: paramsToParamArgs<Params>\n  ): Promise<setToTsType<Set>>;\n  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;\n};\n\nexport type $expr_WithParams<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n> = QueryableWithParamsExpression<\n  {\n    __kind__: ExpressionKind.WithParams;\n    __element__: Expr[\"__element__\"];\n    __cardinality__: Expr[\"__cardinality__\"];\n    __expr__: Expr;\n    __params__: $expr_Param[];\n  },\n  Params\n>;\n\ntype paramsToParamArgs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params as Params[key] extends ParamType\n    ? key\n    : never]: Params[key] extends ParamType\n    ? Readonly<BaseTypeToTsType<Params[key]>>\n    : never;\n} & {\n  [key in keyof Params as Params[key] extends $expr_OptionalParam\n    ? key\n    : never]?: Params[key] extends $expr_OptionalParam\n    ? Readonly<BaseTypeToTsType<Params[key][\"__type__\"]> | null>\n    : never;\n};\n\nexport type $expr_Param<\n  Name extends string | number | symbol = string,\n  Type extends ParamType = ParamType,\n  Optional extends boolean = boolean\n> = Expression<{\n  __kind__: ExpressionKind.Param;\n  __element__: Type;\n  __cardinality__: Optional extends true\n    ? Cardinality.AtMostOne\n    : Cardinality.One;\n  __name__: Name;\n  __isComplex__: boolean;\n}>;\n\ntype paramsToParamExprs<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  }\n> = {\n  [key in keyof Params]: Params[key] extends $expr_OptionalParam\n    ? $expr_Param<key, Params[key][\"__type__\"], true>\n    : Params[key] extends ParamType\n    ? $expr_Param<key, Params[key], false>\n    : never;\n};\n\nconst complexParamKinds = new Set([TypeKind.tuple, TypeKind.namedtuple]);\n\nexport function params<\n  Params extends {\n    [key: string]: ParamType | $expr_OptionalParam;\n  } = {},\n  Expr extends Expression = Expression\n>(\n  paramsDef: Params,\n  expr: (params: paramsToParamExprs<Params>) => Expr\n): $expr_WithParams<Params, Expr> {\n  const paramExprs: {[key: string]: $expr_Param} = {};\n  for (const [key, param] of Object.entries(paramsDef)) {\n    const paramType =\n      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;\n    const isComplex =\n      complexParamKinds.has(paramType.__kind__) ||\n      (paramType.__kind__ === TypeKind.array &&\n        complexParamKinds.has(paramType.__element__.__kind__));\n    paramExprs[key] = $expressionify({\n      __kind__: ExpressionKind.Param,\n      __element__: paramType,\n      __cardinality__:\n        param.__kind__ === ExpressionKind.OptionalParam\n          ? Cardinality.AtMostOne\n          : Cardinality.One,\n      __name__: key,\n      __isComplex__: isComplex,\n    }) as any;\n  }\n\n  const returnExpr = expr(paramExprs as any);\n\n  return $expressionify({\n    __kind__: ExpressionKind.WithParams,\n    __element__: returnExpr.__element__,\n    __cardinality__: returnExpr.__cardinality__,\n    __expr__: returnExpr,\n    __params__: Object.values(paramExprs),\n  }) as any;\n}\n"},{"path":"path.ts","content":"import {\n  cardinalityUtil,\n  ObjectTypeSet,\n  TypeSet,\n  Expression,\n  ExpressionKind,\n  TypeKind,\n  LinkDesc,\n  PropertyDesc,\n  Cardinality,\n  BaseType,\n} from \"edgedb/dist/reflection/index\";\nimport type {\n  PathParent,\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $pathify,\n  ExpressionRoot,\n} from \"edgedb/dist/reflection/path\";\nimport {literalToTypeSet} from \"../castMaps\";\nimport {$arrayLikeIndexify, $tuplePathify} from \"./collections\";\nimport {$toEdgeQL} from \"./toEdgeQL\";\nimport {$queryFunc, $queryFuncJSON} from \"./query\";\n\nfunction PathLeaf<\n  Root extends TypeSet,\n  Parent extends PathParent,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathLeaf<Root, Parent, Exclusive> {\n  return $expressionify({\n    __kind__: ExpressionKind.PathLeaf,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  }) as any;\n}\n\nfunction PathNode<\n  Root extends ObjectTypeSet,\n  Parent extends PathParent | null,\n  Exclusive extends boolean = boolean\n>(\n  root: Root,\n  parent: Parent,\n  exclusive: Exclusive,\n  scopeRoot: TypeSet | null = null\n): $expr_PathNode<Root, Parent, Exclusive> {\n  const obj = {\n    __kind__: ExpressionKind.PathNode,\n    __element__: root.__element__,\n    __cardinality__: root.__cardinality__,\n    __parent__: parent,\n    __exclusive__: exclusive,\n    __scopeRoot__: scopeRoot,\n  };\n\n  const shape: any = {};\n  Object.entries(obj.__element__.__pointers__).map(([key, ptr]) => {\n    if (ptr.__kind__ === \"property\") {\n      shape[key] = true;\n    }\n  });\n  Object.defineProperty(obj, \"*\", {\n    writable: false,\n    value: shape,\n  });\n  return $expressionify(obj) as any;\n}\n\nconst _pathCache = Symbol();\nconst _pointers = Symbol();\n\nconst pathifyProxyHandlers: ProxyHandler<any> = {\n  get(target: any, prop: string | symbol, proxy: any) {\n    const ptr = target[_pointers][prop as any] as LinkDesc | PropertyDesc;\n    if (ptr) {\n      return (\n        target[_pathCache][prop] ??\n        (target[_pathCache][prop] = (\n          (ptr.__kind__ === \"property\" ? PathLeaf : PathNode) as any\n        )(\n          {\n            __element__: ptr.target,\n            __cardinality__: cardinalityUtil.multiplyCardinalities(\n              target.__cardinality__,\n              ptr.cardinality\n            ),\n          },\n          {\n            linkName: prop,\n            type: proxy,\n          },\n          ptr.exclusive ?? false,\n          target.__scopeRoot__ ?? (scopeRoots.has(proxy) ? proxy : null)\n        ))\n      );\n    }\n    return target[prop];\n  },\n};\n\nfunction _$pathify<Root extends TypeSet, Parent extends PathParent>(\n  _root: Root\n): $pathify<Root> {\n  if (_root.__element__.__kind__ !== TypeKind.object) {\n    return _root as any;\n  }\n\n  const root: $expr_PathNode<ObjectTypeSet, Parent> = _root as any;\n\n  let pointers = {\n    ...root.__element__.__pointers__,\n  };\n\n  if (root.__parent__) {\n    const {type, linkName} = root.__parent__;\n    const parentPointer = type.__element__.__pointers__[linkName];\n    if (parentPointer?.__kind__ === \"link\") {\n      pointers = {...pointers, ...parentPointer.properties};\n    }\n  }\n\n  for (const [key, val] of Object.entries(\n    root.__element__.__shape__ || {id: true}\n  )) {\n    if (pointers[key]) continue;\n    const valType: BaseType = (val as any)?.__element__;\n    if (!valType) continue;\n\n    pointers[key] = {\n      __kind__: valType.__kind__ === TypeKind.object ? \"link\" : \"property\",\n      properties: {},\n      target: (val as any).__element__,\n      cardinality: (val as any).__cardinality__,\n      exclusive: false,\n      computed: true,\n      readonly: true,\n      hasDefault: false,\n    };\n  }\n\n  (root as any)[_pointers] = pointers;\n  (root as any)[_pathCache] = {};\n\n  return new Proxy(root, pathifyProxyHandlers);\n}\n\nfunction isFunc(this: any, expr: ObjectTypeSet) {\n  return $expressionify({\n    __kind__: ExpressionKind.TypeIntersection,\n    __cardinality__: this.__cardinality__,\n    __element__: {\n      ...expr.__element__,\n      __shape__: {id: true},\n    } as any,\n    __expr__: this,\n  });\n}\n\nfunction assert_single(expr: Expression) {\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: expr.__element__,\n    __cardinality__: cardinalityUtil.overrideUpperBound(\n      expr.__cardinality__,\n      \"One\"\n    ),\n    __name__: \"std::assert_single\",\n    __args__: [expr],\n    __namedargs__: {},\n  }) as any;\n}\n\nconst jsonDestructureProxyHandlers: ProxyHandler<ExpressionRoot> = {\n  get(target: ExpressionRoot, prop: string | symbol, proxy: any) {\n    if (typeof prop === \"string\" && !(prop in target)) {\n      const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;\n      return jsonDestructure.call(proxy, parsedProp);\n    }\n    return (target as any)[prop];\n  },\n};\n\nfunction jsonDestructure(this: ExpressionRoot, path: any) {\n  const pathTypeSet = literalToTypeSet(path);\n  return $expressionify({\n    __kind__: ExpressionKind.Operator,\n    __element__: this.__element__,\n    __cardinality__: cardinalityUtil.multiplyCardinalities(\n      this.__cardinality__,\n      pathTypeSet.__cardinality__\n    ),\n    __name__: \"[]\",\n    __opkind__: \"Infix\",\n    __args__: [this, pathTypeSet],\n  }) as any;\n}\n\nexport function $jsonDestructure(_expr: ExpressionRoot) {\n  if (\n    _expr.__element__.__kind__ === TypeKind.scalar &&\n    _expr.__element__.__name__ === \"std::json\"\n  ) {\n    const expr = new Proxy(_expr, jsonDestructureProxyHandlers) as any;\n\n    expr.destructure = jsonDestructure.bind(expr);\n\n    return expr;\n  }\n\n  return _expr;\n}\n\nexport function $expressionify<T extends ExpressionRoot>(\n  _expr: T\n): Expression<T> {\n  const expr: Expression = _$pathify(\n    $jsonDestructure($arrayLikeIndexify($tuplePathify(_expr)))\n  ) as any;\n\n  expr.run = $queryFunc.bind(expr) as any;\n  expr.runJSON = $queryFuncJSON.bind(expr) as any;\n  expr.is = isFunc.bind(expr) as any;\n  expr.toEdgeQL = $toEdgeQL.bind(expr);\n  expr.assert_single = () => assert_single(expr) as any;\n\n  return Object.freeze(expr) as any;\n}\n\nconst scopedExprCache = new WeakMap<ExpressionRoot, Expression>();\nconst scopeRoots = new WeakSet<Expression>();\n\nexport function $getScopedExpr<T extends ExpressionRoot>(\n  expr: T,\n  existingScopes?: Set<Expression>\n): Expression<T> {\n  let scopedExpr = scopedExprCache.get(expr);\n  if (!scopedExpr || existingScopes?.has(scopedExpr)) {\n    // free objects should not be scopified\n    const isFreeObject =\n      expr.__cardinality__ === Cardinality.One &&\n      expr.__element__.__name__ === \"std::FreeObject\";\n\n    const isInsert = expr.__kind__ === ExpressionKind.Insert;\n    scopedExpr =\n      isFreeObject || isInsert\n        ? (expr as any as Expression<TypeSet<BaseType, Cardinality>>)\n        : $expressionify({\n            ...expr,\n            __cardinality__: Cardinality.One,\n            __scopedFrom__: expr,\n            \"*\": (expr as any)[\"*\"],\n          });\n    scopeRoots.add(scopedExpr);\n    const uncached = !scopedExpr;\n    if (uncached) {\n      scopedExprCache.set(expr, scopedExpr);\n    }\n  }\n  existingScopes?.add(scopedExpr);\n  return scopedExpr as any;\n}\n\nexport {_$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode};\n"},{"path":"query.ts","content":"import type * as edgedb from \"edgedb\";\nimport {Cardinality, ExpressionKind} from \"edgedb/dist/reflection/index\";\nimport {jsonifyComplexParams} from \"./json\";\nimport {select} from \"./select\";\n\nconst runnableExpressionKinds = new Set([\n  ExpressionKind.Select,\n  ExpressionKind.Update,\n  ExpressionKind.Insert,\n  ExpressionKind.InsertUnlessConflict,\n  ExpressionKind.Delete,\n  ExpressionKind.Group,\n  ExpressionKind.For,\n  ExpressionKind.With,\n  ExpressionKind.WithParams,\n]);\n\nconst wrappedExprCache = new WeakMap();\n\nexport async function $queryFunc(this: any, cxn: edgedb.Executor, args: any) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n\n  const _args = jsonifyComplexParams(expr, args);\n\n  const query = expr.toEdgeQL();\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne ||\n    expr.__cardinality__ === Cardinality.Empty\n  ) {\n    return cxn.querySingle(query, _args);\n  } else {\n    return cxn.query(query, _args);\n  }\n}\n\nexport async function $queryFuncJSON(\n  this: any,\n  cxn: edgedb.Executor,\n  args: any\n) {\n  const expr = runnableExpressionKinds.has(this.__kind__)\n    ? this\n    : wrappedExprCache.get(this) ??\n      wrappedExprCache.set(this, select(this)).get(this);\n  const _args = jsonifyComplexParams(expr, args);\n\n  if (\n    expr.__cardinality__ === Cardinality.One ||\n    expr.__cardinality__ === Cardinality.AtMostOne\n  ) {\n    return cxn.querySingleJSON(expr.toEdgeQL(), _args);\n  } else {\n    return cxn.queryJSON(expr.toEdgeQL(), _args);\n  }\n}\n"},{"path":"range.ts","content":"import type {LocalDate, LocalDateTime, Duration} from \"edgedb\";\nimport {Range} from \"edgedb\";\nimport {\n  RangeType,\n  $expr_Literal,\n  TypeKind,\n  getPrimitiveBaseType,\n  TypeSet,\n  $expr_Function,\n  cardinalityUtil,\n  BaseType,\n  ExpressionKind,\n} from \"edgedb/dist/reflection/index\";\n\nimport type {\n  $number,\n  $decimal,\n  $datetime,\n  $duration,\n  $bool,\n} from \"../modules/std\";\nimport type {$local_date, $local_datetime} from \"../modules/cal\";\nimport type {\n  literalToScalarType,\n  mapLiteralToTypeSet,\n  orScalarLiteral,\n} from \"../castMaps\";\nimport {literalToTypeSet} from \"../castMaps\";\nimport {spec} from \"../__spec__\";\nimport {literal, $nameMapping} from \"./literal\";\nimport {$resolveOverload} from \"./funcops\";\nimport {$expressionify} from \"./path\";\n\ntype $anypoint =\n  | $number\n  | $local_date\n  | $decimal\n  | $datetime\n  | $local_datetime\n  | $duration;\n\nfunction range<Element extends $anypoint>(\n  element: Element\n): RangeType<Element>;\nfunction range<T extends number | Date | LocalDate | LocalDateTime | Duration>(\n  val: Range<T>\n): $expr_Literal<RangeType<getPrimitiveBaseType<literalToScalarType<T>>>>;\nfunction range<\n  NamedArgs extends {\n    inc_lower?: orScalarLiteral<TypeSet<$bool>>;\n    inc_upper?: orScalarLiteral<TypeSet<$bool>>;\n    empty?: orScalarLiteral<TypeSet<$bool>>;\n  },\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  namedArgs: NamedArgs,\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  mapLiteralToTypeSet<NamedArgs>,\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.multiplyCardinalities<\n        cardinalityUtil.multiplyCardinalities<\n          cardinalityUtil.multiplyCardinalities<\n            cardinalityUtil.optionalParamCardinality<P1>,\n            cardinalityUtil.optionalParamCardinality<P2>\n          >,\n          cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_lower\"]>\n        >,\n        cardinalityUtil.optionalParamCardinality<NamedArgs[\"inc_upper\"]>\n      >,\n      cardinalityUtil.optionalParamCardinality<NamedArgs[\"empty\"]>\n    >\n  >\n>;\nfunction range<\n  P1 extends orScalarLiteral<TypeSet<$anypoint>> | undefined,\n  P2 extends\n    | orScalarLiteral<\n        TypeSet<\n          BaseType extends literalToScalarType<P1>\n            ? $anypoint\n            : getPrimitiveBaseType<literalToScalarType<P1>>\n        >\n      >\n    | undefined\n>(\n  lower?: P1,\n  upper?: P2\n): $expr_Function<\n  \"std::range\",\n  mapLiteralToTypeSet<[P1, P2]>,\n  {},\n  TypeSet<\n    RangeType<\n      literalToScalarType<P1> extends $anypoint\n        ? literalToScalarType<P1>\n        : literalToScalarType<P2> extends $anypoint\n        ? literalToScalarType<P2>\n        : $anypoint\n    >,\n    cardinalityUtil.multiplyCardinalities<\n      cardinalityUtil.optionalParamCardinality<P1>,\n      cardinalityUtil.optionalParamCardinality<P2>\n    >\n  >\n>;\nfunction range(...args: any[]): any {\n  if (args.length === 1) {\n    const arg = args[0];\n    if (arg instanceof Range) {\n      if (arg.lower === null && arg.upper === null) {\n        throw new Error(\n          `Can't create literal expression from unbounded range. Try this instead:\\n\\n  e.range(e.cast(e.int64, e.set()), e.cast(e.int64, e.set()))`\n        );\n      }\n      if (arg.isEmpty) {\n        throw new Error(`Can't create literal expression from empty range.`);\n      }\n      return literal(\n        range(literalToTypeSet(arg.lower ?? arg.upper).__element__ as any),\n        arg\n      );\n    }\n    if (arg.__kind__ && !arg.__element__) {\n      return {\n        __kind__: TypeKind.range,\n        __name__: `range<${arg.__name__}>`,\n        __element__: arg,\n      } as any;\n    }\n  }\n  const {\n    returnType,\n    cardinality,\n    args: positionalArgs,\n    namedArgs,\n  } = $resolveOverload(\"std::range\", args, spec, [\n    {\n      args: [\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        {\n          typeId: $nameMapping.get(\"std::anypoint\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      ],\n      namedArgs: {\n        inc_lower: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        inc_upper: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n        empty: {\n          typeId: $nameMapping.get(\"std::bool\")!,\n          optional: true,\n          setoftype: false,\n          variadic: false,\n        },\n      },\n      returnTypeId: $nameMapping.get(\"range<std::anypoint>\")!,\n    },\n  ]);\n  return $expressionify({\n    __kind__: ExpressionKind.Function,\n    __element__: returnType,\n    __cardinality__: cardinality,\n    __name__: \"std::range\",\n    __args__: positionalArgs,\n    __namedargs__: namedArgs,\n  }) as any;\n}\n\nexport {range as $range};\n"},{"path":"select.ts","content":"import {\n  LocalDateTime,\n  LocalDate,\n  LocalTime,\n  Duration,\n  RelativeDuration,\n  ConfigMemory,\n  DateDuration,\n} from \"edgedb\";\nimport type {$bool, $number} from \"../modules/std\";\nimport {\n  $expr_PolyShapeElement,\n  $scopify,\n  Cardinality,\n  cardinalityUtil,\n  Expression,\n  ExpressionKind,\n  LinkDesc,\n  makeType,\n  ObjectType,\n  ObjectTypeExpression,\n  ObjectTypePointers,\n  ObjectTypeSet,\n  PrimitiveTypeSet,\n  PropertyDesc,\n  ScalarType,\n  stripSet,\n  TypeKind,\n  TypeSet,\n  typeutil,\n  BaseType,\n} from \"edgedb/dist/reflection/index\";\n\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $linkPropify,\n  ExpressionRoot,\n  PathParent,\n} from \"edgedb/dist/reflection/path\";\nimport type {anonymizeObject} from \"./casting\";\nimport type {$expr_Operator} from \"edgedb/dist/reflection/funcops\";\nimport {$expressionify, $getScopedExpr} from \"./path\";\nimport {$getTypeByName, literal} from \"./literal\";\nimport {spec} from \"../__spec__\";\nimport {\n  scalarLiterals,\n  literalToScalarType,\n  literalToTypeSet,\n} from \"../castMaps\";\n\nexport const ASC: \"ASC\" = \"ASC\";\nexport const DESC: \"DESC\" = \"DESC\";\nexport const EMPTY_FIRST: \"EMPTY FIRST\" = \"EMPTY FIRST\";\nexport const EMPTY_LAST: \"EMPTY LAST\" = \"EMPTY LAST\";\nexport type OrderByDirection = \"ASC\" | \"DESC\";\nexport type OrderByEmpty = \"EMPTY FIRST\" | \"EMPTY LAST\";\n\nexport type OrderByExpr = TypeSet<ScalarType | ObjectType, Cardinality>;\nexport type OrderByObjExpr = {\n  expression: OrderByExpr;\n  direction?: OrderByDirection;\n  empty?: OrderByEmpty;\n};\n\nexport type OrderByExpression =\n  | OrderByExpr\n  | OrderByObjExpr\n  | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];\n\nexport type OffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectFilterExpression = TypeSet<$bool, Cardinality>;\nexport type LimitOffsetExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\nexport type LimitExpression = TypeSet<\n  $number,\n  Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne\n>;\n\nexport type SelectModifierNames = \"filter\" | \"order_by\" | \"offset\" | \"limit\";\n\nexport type SelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByExpression;\n  offset?: OffsetExpression | number;\n  limit?: LimitExpression | number;\n};\n\nexport type UnknownSelectModifiers = {[k in keyof SelectModifiers]: unknown};\n\nexport type NormalisedSelectModifiers = {\n  filter?: SelectFilterExpression;\n  order_by?: OrderByObjExpr[];\n  offset?: OffsetExpression;\n  limit?: LimitExpression;\n};\n\n// type NormaliseOrderByModifier<Mods extends OrderByExpression> =\n//   Mods extends OrderByExpr\n//     ? [{expression: Mods}]\n//     : Mods extends OrderByObjExpr\n//     ? [Mods]\n//     : Mods extends (OrderByExpr | OrderByObjExpr)[]\n//     ? {\n//         [K in keyof Mods]: Mods[K] extends OrderByExpr\n//           ? {expression: Mods[K]}\n//           : Mods[K];\n//       }\n//     : [];\n\n// type NormaliseSelectModifiers<Mods extends SelectModifiers> = {\n//   filter: Mods[\"filter\"];\n//   order_by: Mods[\"order_by\"] extends OrderByExpression\n//     ? NormaliseOrderByModifier<Mods[\"order_by\"]>\n//     : [];\n//   offset: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n//   limit: Mods[\"offset\"] extends number\n//     ? $expr_Literal<ScalarType<\"std::int64\", number, Mods[\"offset\"]>>\n//     : Mods[\"offset\"];\n// };\n\nexport type $expr_Select<Set extends TypeSet = TypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: TypeSet;\n  __kind__: ExpressionKind.Select;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__?: ObjectTypeExpression;\n}>;\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n// & SelectModifierMethods<stripSet<Set>>;\n\nexport interface SelectModifierMethods<Root extends TypeSet> {\n  filter<Filter extends SelectFilterExpression>(\n    filter:\n      | Filter\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => Filter)\n  ): this;\n  order_by(\n    order_by:\n      | OrderByExpression\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OrderByExpression)\n  ): this;\n  offset(\n    offset:\n      | OffsetExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => OffsetExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n  limit(\n    limit:\n      | LimitExpression\n      | number\n      | ((\n          scope: Root extends ObjectTypeSet\n            ? $scopify<Root[\"__element__\"]>\n            : stripSet<Root>\n        ) => LimitExpression | number)\n  ): this;\n  // $expr_Select<{\n  //   __element__: Root[\"__element__\"];\n  //   __cardinality__: cardinalityUtil.overrideLowerBound<\n  //     Root[\"__cardinality__\"],\n  //     \"Zero\"\n  //   >;\n  // }>;\n}\n// Base is ObjectTypeSet &\n// Filter is equality &\n// Filter.args[0] is PathLeaf\n//   Filter.args[0] is __exclusive__ &\n//   Filter.args[0].parent.__element__ === Base.__element__\n//   Filter.args[1].__cardinality__ is AtMostOne or One\n// if Filter.args[0] is PathNode:\n//   Filter.args[0] is __exclusive__ &\n//   if Filter.args[0].parent === null\n//     Filter.args[0].parent.__element__ === Base.__element__\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n//   else\n//     Filter.args[0].type.__element__ === Base.__element__ &\n//     Filter.args[1].__cardinality__ is AtMostOne or One\n\ntype argCardToResultCard<\n  OpCard extends Cardinality,\n  BaseCase extends Cardinality\n> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One]\n  ? Cardinality.AtMostOne\n  : [OpCard] extends [Cardinality.Empty]\n  ? Cardinality.Empty\n  : BaseCase;\n\nexport type InferFilterCardinality<\n  Base extends TypeSet,\n  Filter\n> = Filter extends TypeSet\n  ? // Base is ObjectTypeExpression &\n    Base extends ObjectTypeSet // $expr_PathNode\n    ? // Filter is equality\n      Filter extends $expr_Operator<\"=\", any, infer Args, any>\n      ? // Filter.args[0] is PathLeaf\n        Args[0] extends $expr_PathLeaf\n        ? // Filter.args[0] is unique\n          Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            typeutil.assertEqual<\n              Args[0][\"__parent__\"][\"type\"][\"__element__\"][\"__name__\"],\n              Base[\"__element__\"][\"__name__\"]\n            > extends true\n            ? // Filter.args[1].__cardinality__ is AtMostOne or One\n              argCardToResultCard<\n                Args[1][\"__cardinality__\"],\n                Base[\"__cardinality__\"]\n              >\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Args[0] extends $expr_PathNode<any, any, any>\n        ? Args[0][\"__exclusive__\"] extends true\n          ? //   Filter.args[0].parent.__element__ === Base.__element__\n            Args[0][\"__parent__\"] extends null\n            ? typeutil.assertEqual<\n                Args[0][\"__element__\"][\"__name__\"],\n                Base[\"__element__\"][\"__name__\"]\n              > extends true\n              ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                argCardToResultCard<\n                  Args[1][\"__cardinality__\"],\n                  Base[\"__cardinality__\"]\n                >\n              : Base[\"__cardinality__\"]\n            : Args[0][\"__parent__\"] extends infer Parent\n            ? Parent extends PathParent\n              ? typeutil.assertEqual<\n                  Parent[\"type\"][\"__element__\"][\"__name__\"],\n                  Base[\"__element__\"][\"__name__\"]\n                > extends true\n                ? // Filter.args[1].__cardinality__ is AtMostOne or One\n                  argCardToResultCard<\n                    Args[1][\"__cardinality__\"],\n                    Base[\"__cardinality__\"]\n                  >\n                : Base[\"__cardinality__\"]\n              : Base[\"__cardinality__\"]\n            : Base[\"__cardinality__\"]\n          : Base[\"__cardinality__\"]\n        : Base[\"__cardinality__\"]\n      : Base[\"__cardinality__\"]\n    : Base[\"__cardinality__\"]\n  : Base[\"__cardinality__\"];\n\nexport type InferOffsetLimitCardinality<\n  Card extends Cardinality,\n  Modifers extends UnknownSelectModifiers\n> = Modifers[\"limit\"] extends number | LimitExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Modifers[\"offset\"] extends number | OffsetExpression\n  ? cardinalityUtil.overrideLowerBound<Card, \"Zero\">\n  : Card;\n\nexport type ComputeSelectCardinality<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends UnknownSelectModifiers\n> = InferOffsetLimitCardinality<\n  InferFilterCardinality<Expr, Modifiers[\"filter\"]>,\n  Modifiers\n>;\n\nexport function is<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]>\n>(\n  expr: Expr,\n  shape: Shape\n): {\n  [k in Exclude<keyof Shape, SelectModifierNames>]: $expr_PolyShapeElement<\n    Expr,\n    normaliseElement<Shape[k]>\n  >;\n} {\n  const mappedShape: any = {};\n  for (const [key, value] of Object.entries(shape)) {\n    mappedShape[key] = {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: expr,\n      __shapeElement__: value,\n    };\n  }\n  return mappedShape;\n}\n\nfunction computeFilterCardinality(\n  expr: SelectFilterExpression,\n  cardinality: Cardinality,\n  base: TypeSet\n) {\n  let card = cardinality;\n\n  const filter: any = expr;\n  // Base is ObjectExpression\n  const baseIsObjectExpr = base?.__element__?.__kind__ === TypeKind.object;\n  const filterExprIsEq =\n    filter.__kind__ === ExpressionKind.Operator && filter.__name__ === \"=\";\n  const arg0: $expr_PathLeaf | $expr_PathNode = filter?.__args__?.[0];\n  const arg1: TypeSet = filter?.__args__?.[1];\n  const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;\n  const arg0IsUnique = arg0?.__exclusive__ === true;\n\n  if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {\n    const newCard =\n      arg1.__cardinality__ === Cardinality.One ||\n      arg1.__cardinality__ === Cardinality.AtMostOne\n        ? Cardinality.AtMostOne\n        : arg1.__cardinality__ === Cardinality.Empty\n        ? Cardinality.Empty\n        : cardinality;\n\n    if (arg0.__kind__ === ExpressionKind.PathLeaf) {\n      const arg0ParentMatchesBase =\n        arg0.__parent__.type.__element__.__name__ ===\n        base.__element__.__name__;\n      if (arg0ParentMatchesBase) {\n        card = newCard;\n      }\n    } else if (arg0.__kind__ === ExpressionKind.PathNode) {\n      // if Filter.args[0] is PathNode:\n      //   Filter.args[0] is __exclusive__ &\n      //   if Filter.args[0].parent === null\n      //     Filter.args[0].__element__ === Base.__element__\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      //   else\n      //     Filter.args[0].type.__element__ === Base.__element__ &\n      //     Filter.args[1].__cardinality__ is AtMostOne or One\n      const parent = arg0.__parent__;\n      if (parent === null) {\n        const arg0MatchesBase =\n          arg0.__element__.__name__ === base.__element__.__name__;\n        if (arg0MatchesBase) {\n          card = newCard;\n        }\n      } else {\n        const arg0ParentMatchesBase =\n          parent?.type.__element__.__name__ === base.__element__.__name__;\n        if (arg0ParentMatchesBase) {\n          card = newCard;\n        }\n      }\n    }\n  }\n\n  return card;\n}\n\nexport function $handleModifiers(\n  modifiers: SelectModifiers,\n  rootExpr: TypeSet\n): {modifiers: NormalisedSelectModifiers; cardinality: Cardinality} {\n  const mods = {...modifiers};\n  let card = rootExpr.__cardinality__;\n\n  if (mods.filter && rootExpr.__element__.__kind__ === TypeKind.object) {\n    card = computeFilterCardinality(mods.filter, card, rootExpr);\n  }\n  if (mods.order_by) {\n    const orderExprs = Array.isArray(mods.order_by)\n      ? mods.order_by\n      : [mods.order_by];\n    mods.order_by = orderExprs.map(expr =>\n      typeof (expr as any).__element__ === \"undefined\"\n        ? expr\n        : {expression: expr}\n    ) as any;\n  }\n  if (mods.offset) {\n    mods.offset =\n      typeof mods.offset === \"number\"\n        ? ($getTypeByName(\"std::number\")(mods.offset) as any)\n        : mods.offset;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n  if (mods.limit) {\n    let expr = mods.limit;\n    if (typeof expr === \"number\") {\n      expr = $getTypeByName(\"std::number\")(expr) as any;\n    } else if ((expr as any).__kind__ === ExpressionKind.Set) {\n      expr = (expr as any).__exprs__[0];\n    }\n    mods.limit = expr;\n    card = cardinalityUtil.overrideLowerBound(card, \"Zero\");\n  }\n\n  return {modifiers: mods as NormalisedSelectModifiers, cardinality: card};\n}\n\nexport type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> =\n  Expression<{\n    __kind__: ExpressionKind.Delete;\n    __element__: Root[\"__element__\"];\n    __cardinality__: Root[\"__cardinality__\"];\n    __expr__: Root;\n  }>;\n\nfunction deleteExpr<\n  Expr extends ObjectTypeExpression,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers?: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Modifiers>\n): $expr_Delete<{\n  __element__: ObjectType<\n    Expr[\"__element__\"][\"__name__\"],\n    Expr[\"__element__\"][\"__pointers__\"],\n    {id: true}\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\nfunction deleteExpr(expr: any, modifiersGetter: any) {\n  const selectExpr = select(expr, modifiersGetter);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Delete,\n    __element__: selectExpr.__element__,\n    __cardinality__: selectExpr.__cardinality__,\n    __expr__: selectExpr,\n  }) as any;\n}\n\nexport {deleteExpr as delete};\n\n// Modifier methods removed for now, until we can fix typescript inference\n// problems / excessively deep errors\n\n// function resolveModifierGetter(parent: any, modGetter: any) {\n//   if (typeof modGetter === \"function\" && !modGetter.__kind__) {\n//     if (parent.__expr__.__element__.__kind__ === TypeKind.object) {\n//       const shape = parent.__element__.__shape__;\n//       const _scope =\n//         parent.__scope__ ?? $getScopedExpr(parent.__expr__,\n//           $existingScopes);\n//       const scope = new Proxy(_scope, {\n//         get(target: any, prop: string) {\n//           if (shape[prop] && shape[prop] !== true) {\n//             return shape[prop];\n//           }\n//           return target[prop];\n//         },\n//       });\n//       return {\n//         scope: _scope,\n//         modExpr: modGetter(scope),\n//       };\n//     } else {\n//       return {\n//         scope: undefined,\n//         modExpr: modGetter(parent.__expr__),\n//       };\n//     }\n//   } else {\n//     return {scope: parent.__scope__, modExpr: modGetter};\n//   }\n// }\n\n// function updateModifier(\n//   parent: any,\n//   modName: \"filter\" | \"order_by\" | \"offset\" | \"limit\",\n//   modGetter: any\n// ) {\n//   const modifiers = {\n//     ...parent.__modifiers__,\n//   };\n//   const cardinality = parent.__cardinality__;\n\n//   const {modExpr, scope} = resolveModifierGetter(parent, modGetter);\n\n//   switch (modName) {\n//     case \"filter\":\n//       modifiers.filter = modifiers.filter\n//         ? op(modifiers.filter, \"and\", modExpr)\n//         : modExpr;\n\n//       // methods no longer change cardinality\n//       // cardinality = computeFilterCardinality(\n//       //   modExpr,\n//       //   cardinality,\n//       //   parent.__expr__\n//       // );\n//       break;\n//     case \"order_by\":\n//       const ordering =\n//         typeof (modExpr as any).__element__ === \"undefined\"\n//           ? modExpr\n//           : {expression: modExpr};\n//       modifiers.order_by = modifiers.order_by\n//         ? [...modifiers.order_by, ordering]\n//         : [ordering];\n//       break;\n//     case \"offset\":\n//       modifiers.offset =\n//         typeof modExpr === \"number\" ? _std.number(modExpr) : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//     case \"limit\":\n//       modifiers.limit =\n//         typeof modExpr === \"number\"\n//           ? _std.number(modExpr)\n//           : (modExpr as any).__kind__ === ExpressionKind.Set\n//           ? (modExpr as any).__exprs__[0]\n//           : modExpr;\n//       // methods no longer change cardinality\n//       // cardinality = cardinalityUtil\n//            .overrideLowerBound(cardinality, \"Zero\");\n//       break;\n//   }\n\n//   return $expressionify(\n//     $selectify({\n//       __kind__: ExpressionKind.Select,\n//       __element__: parent.__element__,\n//       __cardinality__: cardinality,\n//       __expr__: parent.__expr__,\n//       __modifiers__: modifiers,\n//       __scope__: scope,\n//     })\n//   );\n// }\n\nexport function $selectify<Expr extends ExpressionRoot>(expr: Expr) {\n  // Object.assign(expr, {\n  //   filter: (filter: any) => updateModifier(expr, \"filter\", filter),\n  //   order_by: (order_by: any) => updateModifier(expr, \"order_by\", order_by),\n  //   offset: (offset: any) => updateModifier(expr, \"offset\", offset),\n  //   limit: (limit: any) => updateModifier(expr, \"limit\", limit),\n  // });\n  return expr;\n}\n\nexport type linkDescToLinkProps<Desc extends LinkDesc> = {\n  [k in keyof Desc[\"properties\"] & string]: $expr_PathLeaf<\n    TypeSet<\n      Desc[\"properties\"][k][\"target\"],\n      Desc[\"properties\"][k][\"cardinality\"]\n    >,\n    {\n      type: $scopify<Desc[\"target\"]>;\n      linkName: k;\n    },\n    Desc[\"properties\"][k][\"exclusive\"]\n  >;\n};\n\nexport type pointersToObjectType<P extends ObjectTypePointers> = ObjectType<\n  string,\n  P,\n  {}\n>;\n\ntype linkDescToShape<L extends LinkDesc> = objectTypeToSelectShape<\n  L[\"target\"]\n> &\n  objectTypeToSelectShape<pointersToObjectType<L[\"properties\"]>> &\n  SelectModifiers;\nexport type linkDescToSelectElement<L extends LinkDesc> =\n  | boolean\n  // | pointerToCastableExpression<Shape[k]>\n  | TypeSet<\n      anonymizeObject<L[\"target\"]>,\n      cardinalityUtil.assignable<L[\"cardinality\"]>\n    >\n  | linkDescToShape<L>\n  | ((\n      scope: $scopify<L[\"target\"]> & linkDescToLinkProps<L>\n    ) => linkDescToShape<L>);\n\n// object types -> pointers\n// pointers -> links\n// links -> target object type\n// links -> link properties\nexport type objectTypeToSelectShape<T extends ObjectType = ObjectType> =\n  // ObjectType extends T\n  //   ? {[k: string]: unknown}\n  //   :\n  Partial<{\n    [k in keyof T[\"__pointers__\"]]: T[\"__pointers__\"][k] extends PropertyDesc\n      ?\n          | boolean\n          | TypeSet<\n              T[\"__pointers__\"][k][\"target\"],\n              cardinalityUtil.assignable<T[\"__pointers__\"][k][\"cardinality\"]>\n            >\n      : T[\"__pointers__\"][k] extends LinkDesc\n      ? linkDescToSelectElement<T[\"__pointers__\"][k]>\n      : any;\n  }> & {[k: string]: unknown};\n\n// incorporate __shape__ (computeds) on selection shapes\n// this works but a major rewrite of setToTsType is required\n// to incorporate __shape__-based selection shapes into\n// result type inference\n// & [k in keyof T[\"__shape__\"]]:\n//    string | number | symbol extends k //   Partial<{ // &\n//       ? unknown\n//       : T[\"__shape__\"][k] extends infer U\n//       ? U extends ObjectTypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 anonymizeObject<U[\"__element__\"]>,\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//             | objectTypeToSelectShape<U[\"__element__\"]>\n//             | ((\n//                 scope: $scopify<U[\"__element__\"]>\n//               ) => objectTypeToSelectShape<U[\"__element__\"]> &\n//                 SelectModifiers)\n//         : U extends TypeSet\n//         ?\n//             | boolean\n//             | TypeSet<\n//                 U[\"__element__\"],\n//                 cardinalityUtil.assignable<U[\"__cardinality__\"]>\n//               >\n//         : unknown\n//       : unknown;\n//   }>\n\nexport type normaliseElement<El> = El extends boolean\n  ? El\n  : El extends TypeSet\n  ? stripSet<El>\n  : El extends (...scope: any[]) => any\n  ? normaliseShape<ReturnType<El>>\n  : El extends object\n  ? normaliseShape<stripSet<El>>\n  : stripSet<El>;\n\nexport type normaliseShape<\n  Shape extends object,\n  Strip = SelectModifierNames\n> = {\n  [k in Exclude<keyof Shape, Strip>]: normaliseElement<Shape[k]>;\n};\n\nconst $FreeObject = makeType(\n  spec,\n  [...spec.values()].find(s => s.name === \"std::FreeObject\")!.id,\n  literal\n);\nconst FreeObject: $expr_PathNode = {\n  __kind__: ExpressionKind.PathNode,\n  __element__: $FreeObject as any,\n  __cardinality__: Cardinality.One,\n  __parent__: null,\n  __exclusive__: true,\n  __scopeRoot__: null,\n} as any;\n\nexport const $existingScopes = new Set<\n  Expression<TypeSet<BaseType, Cardinality>>\n>();\n\nfunction $shape<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers\n>(\n  expr: Expr,\n  _shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): (scope: unknown) => Readonly<Shape>;\nfunction $shape(_a: unknown, b: (...args: any) => any) {\n  return b;\n}\nexport {$shape as shape};\n\nexport function select<Expr extends ObjectTypeExpression>(\n  expr: Expr\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Expr[\"__element__\"][\"__shape__\"] // {id: true}\n  >;\n  __cardinality__: Expr[\"__cardinality__\"];\n}>;\nexport function select<Expr extends TypeSet>(\n  expr: Expr\n): $expr_Select<stripSet<Expr>>;\nexport function select<\n  Expr extends ObjectTypeExpression,\n  Shape extends objectTypeToSelectShape<Expr[\"__element__\"]> & SelectModifiers,\n  Modifiers extends UnknownSelectModifiers = Pick<Shape, SelectModifierNames>\n>(\n  expr: Expr,\n  shape: (\n    scope: $scopify<Expr[\"__element__\"]> &\n      $linkPropify<{\n        [k in keyof Expr]: k extends \"__cardinality__\"\n          ? Cardinality.One\n          : Expr[k];\n      }>\n  ) => Readonly<Shape>\n): $expr_Select<{\n  __element__: ObjectType<\n    `${Expr[\"__element__\"][\"__name__\"]}`, // _shape\n    Expr[\"__element__\"][\"__pointers__\"],\n    Omit<normaliseShape<Shape>, SelectModifierNames>\n  >;\n  __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;\n}>;\n/*\n\nFor the moment is isn't possible to implement both closure-based and plain\nobject overloads without breaking autocomplete on one or the other.\nThis is due to a limitation in TS:\n\nhttps://github.com/microsoft/TypeScript/issues/26892\nhttps://github.com/microsoft/TypeScript/issues/47081\n\n*/\nexport function select<\n  Expr extends PrimitiveTypeSet,\n  Modifiers extends SelectModifiers\n>(\n  expr: Expr,\n  modifiers: (expr: Expr) => Readonly<Modifiers>\n): $expr_Select<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: InferOffsetLimitCardinality<\n    Expr[\"__cardinality__\"],\n    Modifiers\n  >;\n}>;\nexport function select<Shape extends {[key: string]: TypeSet}>(\n  shape: Shape\n): $expr_Select<{\n  __element__: ObjectType<\n    `std::FreeObject`,\n    {\n      [k in keyof Shape]: Shape[k][\"__element__\"] extends ObjectType\n        ? LinkDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            {},\n            false,\n            true,\n            true,\n            false\n          >\n        : PropertyDesc<\n            Shape[k][\"__element__\"],\n            Shape[k][\"__cardinality__\"],\n            false,\n            true,\n            true,\n            false\n          >;\n    },\n    Shape\n  >; // _shape\n  __cardinality__: Cardinality.One;\n}>;\nexport function select<Expr extends scalarLiterals>(\n  expr: Expr\n): $expr_Select<{\n  __element__: literalToScalarType<Expr>;\n  __cardinality__: Cardinality.One;\n}>;\nexport function select(...args: any[]) {\n  const firstArg = args[0];\n\n  if (\n    typeof firstArg !== \"object\" ||\n    firstArg instanceof Buffer ||\n    firstArg instanceof Date ||\n    firstArg instanceof Duration ||\n    firstArg instanceof LocalDateTime ||\n    firstArg instanceof LocalDate ||\n    firstArg instanceof LocalTime ||\n    firstArg instanceof RelativeDuration ||\n    firstArg instanceof DateDuration ||\n    firstArg instanceof ConfigMemory\n  ) {\n    const literalExpr = literalToTypeSet(firstArg);\n    return $expressionify(\n      $selectify({\n        __kind__: ExpressionKind.Select,\n        __element__: literalExpr.__element__,\n        __cardinality__: literalExpr.__cardinality__,\n        __expr__: literalExpr,\n        __modifiers__: {},\n      })\n    ) as any;\n  }\n\n  const exprPair: [TypeSet, (scope: any) => any] =\n    typeof args[0].__element__ !== \"undefined\"\n      ? (args as any)\n      : [FreeObject, () => args[0]];\n\n  let expr = exprPair[0];\n  const shapeGetter = exprPair[1];\n  if (expr === FreeObject) {\n    const freeObjectPtrs: ObjectTypePointers = {};\n    for (const [k, v] of Object.entries(args[0]) as [string, TypeSet][]) {\n      freeObjectPtrs[k] = {\n        __kind__:\n          v.__element__.__kind__ === TypeKind.object ? \"link\" : \"property\",\n        target: v.__element__,\n\n        cardinality: v.__cardinality__,\n        exclusive: false,\n        computed: true,\n        readonly: true,\n        hasDefault: false,\n        properties: {},\n      };\n    }\n    expr = {\n      ...FreeObject,\n      __element__: {\n        ...FreeObject.__element__,\n        __pointers__: {\n          ...FreeObject.__element__.__pointers__,\n          ...freeObjectPtrs,\n        },\n      } as any,\n    };\n  }\n  if (!shapeGetter) {\n    if (expr.__element__.__kind__ === TypeKind.object) {\n      const objectExpr: ObjectTypeSet = expr as any;\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: {\n            __kind__: TypeKind.object,\n            __name__: `${objectExpr.__element__.__name__}`, // _shape\n            __pointers__: objectExpr.__element__.__pointers__,\n            __shape__: objectExpr.__element__.__shape__,\n          } as any,\n          __cardinality__: objectExpr.__cardinality__,\n          __expr__: objectExpr,\n          __modifiers__: {},\n        })\n      ) as any;\n    } else {\n      return $expressionify(\n        $selectify({\n          __kind__: ExpressionKind.Select,\n          __element__: expr.__element__,\n          __cardinality__: expr.__cardinality__,\n          __expr__: expr,\n          __modifiers__: {},\n        })\n      ) as any;\n    }\n  }\n\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const {modifiers: mods, shape, scope} = resolveShape(shapeGetter, expr);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n  return $expressionify(\n    $selectify({\n      __kind__: ExpressionKind.Select,\n      __element__:\n        expr.__element__.__kind__ === TypeKind.object\n          ? {\n              __kind__: TypeKind.object,\n              __name__: `${expr.__element__.__name__}`, // _shape\n              __pointers__: (expr.__element__ as ObjectType).__pointers__,\n              __shape__: shape,\n            }\n          : expr.__element__,\n      __cardinality__: cardinality,\n      __expr__: expr,\n      __modifiers__: modifiers,\n      __scope__:\n        expr !== scope // && expr.__element__.__name__ !== \"std::FreeObject\"\n          ? scope\n          : undefined,\n    })\n  ) as any;\n}\n\nfunction resolveShape(\n  shapeGetter: ((scope: any) => any) | any,\n  expr: TypeSet\n): {modifiers: any; shape: any; scope: TypeSet} {\n  const modifiers: any = {};\n  const shape: any = {};\n\n  // get scoped object if expression is objecttypeset\n  const scope =\n    expr.__element__.__kind__ === TypeKind.object\n      ? $getScopedExpr(expr as any, $existingScopes)\n      : expr;\n\n  // execute getter with scope\n  const selectShape =\n    typeof shapeGetter === \"function\" ? shapeGetter(scope) : shapeGetter;\n\n  for (const [key, value] of Object.entries(selectShape)) {\n    // handle modifier keys\n    if (\n      key === \"filter\" ||\n      key === \"order_by\" ||\n      key === \"offset\" ||\n      key === \"limit\"\n    ) {\n      modifiers[key] = value;\n    } else {\n      // for scalar expressions, scope === expr\n      // shape keys are not allowed\n      if (expr.__element__.__kind__ !== TypeKind.object) {\n        throw new Error(\n          `Invalid select shape key '${key}' on scalar expression, ` +\n            `only modifiers are allowed (filter, order_by, offset and limit)`\n        );\n      }\n      shape[key] = resolveShapeElement(key, value, scope);\n    }\n  }\n  return {shape, modifiers, scope};\n}\n\nexport function resolveShapeElement(\n  key: any,\n  value: any,\n  scope: ObjectTypeExpression\n): any {\n  // if value is a nested closure\n  // or a nested shape object\n  const isSubshape =\n    typeof value === \"object\" &&\n    typeof (value as any).__kind__ === \"undefined\";\n  const isClosure =\n    typeof value === \"function\" &&\n    scope.__element__.__pointers__[key]?.__kind__ === \"link\";\n  // if (isSubshape) {\n  //   // return value;\n  //   const childExpr = (scope as any)[key];\n  //   const {\n  //     shape: childShape,\n  //     // scope: childScope,\n  //     // modifiers: mods,\n  //   } = resolveShape(value as any, childExpr);\n  //   return childShape;\n  // }\n  if (isSubshape || isClosure) {\n    // get child node expression\n    // this relies on Proxy-based getters\n    const childExpr = (scope as any)[key];\n    if (!childExpr) {\n      throw new Error(\n        `Invalid shape element \"${key}\" for type ${scope.__element__.__name__}`\n      );\n    }\n    const {\n      shape: childShape,\n      scope: childScope,\n      modifiers: mods,\n    } = resolveShape(value as any, childExpr);\n\n    // extracts normalized modifiers\n    const {modifiers} = $handleModifiers(mods, childExpr);\n\n    return {\n      __kind__: ExpressionKind.Select,\n      __element__: {\n        __kind__: TypeKind.object,\n        __name__: `${childExpr.__element__.__name__}`,\n        __pointers__: childExpr.__element__.__pointers__,\n        __shape__: childShape,\n      },\n      __cardinality__:\n        scope.__element__.__pointers__?.[key]?.cardinality ||\n        scope.__element__.__shape__?.[key]?.__cardinality__,\n      __expr__: childExpr,\n      __modifiers__: modifiers,\n      __scope__: childExpr !== childScope ? childScope : undefined,\n    };\n  } else if ((value as any)?.__kind__ === ExpressionKind.PolyShapeElement) {\n    const polyElement = value as $expr_PolyShapeElement;\n\n    const polyScope = (scope as any).is(polyElement.__polyType__);\n    return {\n      __kind__: ExpressionKind.PolyShapeElement,\n      __polyType__: polyScope,\n      __shapeElement__: resolveShapeElement(\n        key,\n        polyElement.__shapeElement__,\n        polyScope\n      ),\n    };\n  } else if (typeof value === \"boolean\" && key.startsWith(\"@\")) {\n    const linkProp = (scope as any)[key];\n    if (!linkProp) {\n      throw new Error(\n        (scope as any).__parent__\n          ? `link property '${key}' does not exist on link ${\n              (scope as any).__parent__.linkName\n            }`\n          : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`\n      );\n    }\n    return value ? linkProp : false;\n  } else {\n    return value;\n  }\n}\n"},{"path":"set.ts","content":"import type {\n  ArrayType,\n  BaseTypeTuple,\n  BaseType,\n  NamedTupleType,\n  ObjectTypeSet,\n  TypeSet,\n  TupleType,\n  Expression,\n  ExpressionKind,\n  mergeObjectTypes,\n  ObjectType,\n  Cardinality,\n  getPrimitiveBaseType,\n  SomeType,\n} from \"edgedb/dist/reflection/index\";\nimport {TypeKind, $mergeObjectTypes} from \"edgedb/dist/reflection/index\";\n\n// \"../\" path gets replaced during generation step\n// @ts-ignore\nimport * as castMaps from \"../castMaps\";\n\nexport function getSharedParent(a: SomeType, b: SomeType): SomeType {\n  if (a.__kind__ !== b.__kind__) {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n  if (a.__kind__ === TypeKind.scalar && b.__kind__ === TypeKind.scalar) {\n    return castMaps.getSharedParentScalar(a, b);\n  } else if (\n    a.__kind__ === TypeKind.object &&\n    b.__kind__ === TypeKind.object\n  ) {\n    return $mergeObjectTypes(a, b);\n  } else if (a.__kind__ === TypeKind.tuple && b.__kind__ === TypeKind.tuple) {\n    if (a.__items__.length !== b.__items__.length) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items = a.__items__.map((_, i) => {\n        if (!a.__items__[i] || !b.__items__[i]) {\n          throw new Error();\n        }\n        return getSharedParent(\n          a.__items__[i] as SomeType,\n          b.__items__[i] as SomeType\n        );\n      });\n\n      return {\n        __kind__: TypeKind.tuple,\n        __name__: `tuple<${items.map(item => item.__name__).join(\", \")}>`,\n        __items__: items as BaseTypeTuple,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (\n    a.__kind__ === TypeKind.namedtuple &&\n    b.__kind__ === TypeKind.namedtuple\n  ) {\n    const aKeys = Object.keys(a);\n    const bKeys = new Set(Object.keys(b));\n    const sameKeys =\n      aKeys.length === bKeys.size && aKeys.every(k => bKeys.has(k));\n    if (!sameKeys) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n    try {\n      const items: {[k: string]: BaseType} = {};\n      for (const [i] of Object.entries(a.__shape__)) {\n        if (!a.__shape__[i] || !b.__shape__[i]) {\n          throw new Error();\n        }\n        items[i] = getSharedParent(\n          a.__shape__[i] as SomeType,\n          b.__shape__[i] as SomeType\n        );\n      }\n\n      return {\n        __kind__: TypeKind.namedtuple,\n        __name__: `tuple<${Object.entries(items)\n          .map(([key, val]: [string, any]) => `${key}: ${val.__name__}`)\n          .join(\", \")}>`,\n        __shape__: items,\n      };\n    } catch (err) {\n      throw new Error(\n        `Incompatible tuple types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.array && b.__kind__ === TypeKind.array) {\n    try {\n      const mergedEl: any = getSharedParent(\n        a.__element__ as any,\n        b.__element__ as any\n      );\n      return {\n        __kind__: TypeKind.array,\n        __name__: a.__name__,\n        __element__: mergedEl,\n      } as ArrayType;\n    } catch (err) {\n      throw new Error(\n        `Incompatible array types: ${a.__name__} and ${b.__name__}`\n      );\n    }\n  } else if (a.__kind__ === TypeKind.enum && b.__kind__ === TypeKind.enum) {\n    if (a.__name__ === b.__name__) return a;\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  } else {\n    throw new Error(\n      `Incompatible array types: ${a.__name__} and ${b.__name__}`\n    );\n  }\n}\n\n// @ts-ignore\nexport {set} from \"./setImpl\";\n\nexport type $expr_Set<Set extends LooseTypeSet = LooseTypeSet> = Expression<{\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __exprs__: Expression<Set>[];\n  __kind__: ExpressionKind.Set;\n}>;\n\ntype mergeTypeTuples<AItems, BItems> = {\n  [k in keyof AItems]: k extends keyof BItems\n    ? getSharedParentPrimitive<AItems[k], BItems[k]>\n    : never;\n};\n\n// find shared parent of two primitives\nexport type getSharedParentPrimitive<A, B> = A extends undefined\n  ? B extends undefined\n    ? undefined\n    : B\n  : B extends undefined\n  ? A\n  : A extends ArrayType<infer AEl>\n  ? B extends ArrayType<infer BEl>\n    ? ArrayType<castMaps.getSharedParentScalar<AEl, BEl>>\n    : never\n  : A extends NamedTupleType<infer AShape>\n  ? B extends NamedTupleType<infer BShape>\n    ? NamedTupleType<{\n        [k in keyof AShape & keyof BShape]: castMaps.getSharedParentScalar<\n          AShape[k],\n          BShape[k]\n        >;\n      }>\n    : never\n  : A extends TupleType<infer AItems>\n  ? B extends TupleType<infer BItems>\n    ? mergeTypeTuples<AItems, BItems> extends BaseTypeTuple\n      ? TupleType<mergeTypeTuples<AItems, BItems>>\n      : never\n    : never\n  : castMaps.getSharedParentScalar<A, B>;\n\ntype _getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? _getSharedParentPrimitiveVariadic<\n        [getSharedParentPrimitive<A, B>, ...Rest]\n      >\n    : never;\n\nexport type getSharedParentPrimitiveVariadic<Types extends [any, ...any[]]> =\n  _getSharedParentPrimitiveVariadic<Types>;\n\nexport type LooseTypeSet<\n  T extends any = any,\n  C extends Cardinality = Cardinality\n> = {\n  __element__: T;\n  __cardinality__: C;\n};\n\nexport type {mergeObjectTypes};\n\ntype _mergeObjectTypesVariadic<Types extends [ObjectType, ...ObjectType[]]> =\n  Types extends [infer U]\n    ? U\n    : Types extends [infer A, infer B, ...infer Rest]\n    ? A extends ObjectType\n      ? B extends ObjectType\n        ? mergeObjectTypes<A, B> extends BaseType\n          ? mergeObjectTypesVariadic<[mergeObjectTypes<A, B>, ...Rest]>\n          : never\n        : never\n      : never\n    : never;\n\nexport type mergeObjectTypesVariadic<Types extends [any, ...any[]]> =\n  _mergeObjectTypesVariadic<Types>;\n\nexport type getTypesFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any>\n    ? getPrimitiveBaseType<El>\n    : never;\n};\n\nexport type getTypesFromObjectExprs<\n  Exprs extends [ObjectTypeSet, ...ObjectTypeSet[]]\n> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<infer El, any> ? El : never;\n};\n\nexport type getCardsFromExprs<Exprs extends [TypeSet, ...TypeSet[]]> = {\n  [k in keyof Exprs]: Exprs[k] extends TypeSet<any, infer Card> ? Card : never;\n};\n"},{"path":"syntax.ts","content":"import type {TypeSet, setToTsType} from \"edgedb/dist/reflection/index\";\n\nexport * from \"./literal\";\nexport * from \"./path\";\nexport * from \"./set\";\nexport * from \"./cast\";\nexport * from \"./select\";\nexport * from \"./update\";\nexport * from \"./insert\";\nexport * from \"./group\";\nexport * from \"./collections\";\nexport * from \"./funcops\";\nexport * from \"./for\";\nexport * from \"./with\";\nexport * from \"./params\";\nexport * from \"./globals\";\nexport * from \"./detached\";\nexport * from \"./toEdgeQL\";\nexport * from \"./range\";\n\nexport type $infer<A extends TypeSet> = setToTsType<A>;\n"},{"path":"toEdgeQL.ts","content":"import {\n  Duration,\n  LocalDate,\n  LocalDateTime,\n  LocalTime,\n  RelativeDuration,\n  DateDuration,\n  Range,\n} from \"edgedb\";\nimport {\n  $expr_Array,\n  $expr_NamedTuple,\n  $expr_Tuple,\n  $expr_TuplePath,\n  BaseType,\n  Cardinality,\n  EnumType,\n  ExpressionKind,\n  isArrayType,\n  isNamedTupleType,\n  isObjectType,\n  isTupleType,\n  ObjectType,\n  ObjectTypeSet,\n  OperatorKind,\n  RangeType,\n  TypeKind,\n  TypeSet,\n  util,\n} from \"edgedb/dist/reflection/index\";\nimport type {$expr_Literal} from \"edgedb/dist/reflection/literal\";\nimport type {\n  $expr_PathLeaf,\n  $expr_PathNode,\n  $expr_TypeIntersection,\n} from \"edgedb/dist/reflection/path\";\nimport {reservedKeywords} from \"edgedb/dist/reflection/reservedKeywords\";\nimport type {$expr_Cast} from \"./cast\";\nimport type {$expr_Detached} from \"./detached\";\nimport type {$expr_For, $expr_ForVar} from \"./for\";\nimport type {$expr_Function, $expr_Operator} from \"edgedb/dist/reflection/funcops\";\nimport type {$expr_Insert, $expr_InsertUnlessConflict} from \"./insert\";\nimport type {$expr_Param, $expr_WithParams} from \"./params\";\nimport type {\n  $expr_Delete,\n  $expr_Select,\n  LimitExpression,\n  OffsetExpression,\n} from \"./select\";\nimport type {$expr_Set} from \"./set\";\nimport type {$expr_Update} from \"./update\";\nimport type {$expr_Alias, $expr_With} from \"./with\";\nimport type {$expr_Group, GroupingSet} from \"./group\";\nimport type {$expr_Global} from \"./globals\";\n\nexport type SomeExpression =\n  | $expr_PathNode\n  | $expr_PathLeaf\n  | $expr_Literal\n  | $expr_Set\n  | $expr_Array\n  | $expr_Tuple\n  | $expr_NamedTuple\n  | $expr_TuplePath\n  | $expr_Cast\n  | $expr_Select\n  | $expr_Delete\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_Function\n  | $expr_Operator\n  | $expr_For\n  | $expr_ForVar\n  | $expr_TypeIntersection\n  | $expr_Alias\n  | $expr_With\n  | $expr_WithParams\n  | $expr_Param\n  | $expr_Detached\n  | $expr_Group\n  | $expr_Global;\n\ntype WithScopeExpr =\n  | $expr_Select\n  | $expr_Update\n  | $expr_Insert\n  | $expr_InsertUnlessConflict\n  | $expr_For\n  | $expr_Group;\n\ninterface RenderCtx {\n  // mapping withable expr to list of with vars\n  withBlocks: Map<WithScopeExpr, Set<SomeExpression>>;\n  // metadata about each with var\n  withVars: Map<\n    SomeExpression,\n    {\n      name: string;\n      scope: WithScopeExpr;\n      childExprs: Set<SomeExpression>;\n      scopedExpr?: SomeExpression; // scope vars only\n    }\n  >;\n  renderWithVar?: SomeExpression;\n  forVars: Map<$expr_ForVar, string>;\n  linkProps: Map<SomeExpression, string[]>;\n}\n\nconst toEdgeQLCache = new WeakMap<any, string>();\n\nexport function $toEdgeQL(this: any) {\n  if (toEdgeQLCache.has(this)) {\n    return toEdgeQLCache.get(this)!;\n  }\n\n  const walkExprCtx: WalkExprTreeCtx = {\n    seen: new Map(),\n    rootScope: null,\n  };\n\n  walkExprTree(this, null, walkExprCtx);\n\n  // get variables by block\n  const withBlocks: RenderCtx[\"withBlocks\"] = new Map();\n  // get per-variable metadata\n  const withVars: RenderCtx[\"withVars\"] = new Map();\n  const seen = new Map(walkExprCtx.seen);\n  const linkProps: RenderCtx[\"linkProps\"] = new Map();\n\n  // iterate over all expressions\n  for (const [expr, refData] of seen) {\n    // delete from seen after visitinng\n    seen.delete(expr);\n\n    // convert referenced link props to simple string array\n    if (refData.linkProps.length) {\n      linkProps.set(\n        expr,\n        refData.linkProps.map(linkProp =>\n          linkProp.__parent__.linkName.slice(1)\n        )\n      );\n    }\n\n    // already extracted\n    if (withVars.has(expr)) {\n      continue;\n    }\n\n    // ignore unbound leaves, nodes, and intersections\n    // these should be rendered as is\n    if (\n      !refData.boundScope &&\n      (expr.__kind__ === ExpressionKind.PathLeaf ||\n        expr.__kind__ === ExpressionKind.PathNode ||\n        expr.__kind__ === ExpressionKind.TypeIntersection)\n    ) {\n      continue;\n    }\n\n    // forvars and params should not be hoisted\n    if (\n      expr.__kind__ === ExpressionKind.ForVar ||\n      expr.__kind__ === ExpressionKind.Param\n    ) {\n      continue;\n    }\n\n    // pull out scope variables\n    // from select, update, and group expressions.\n    // these are always rendered in with blocks\n    if (\n      (expr.__kind__ === ExpressionKind.Select ||\n        expr.__kind__ === ExpressionKind.Update ||\n        expr.__kind__ === ExpressionKind.Group) &&\n      expr.__scope__ &&\n      // with var not previously registered\n      !withVars.has(expr.__scope__ as any)\n    ) {\n      const withBlock = expr;\n      const scopeVar = expr.__scope__ as SomeExpression;\n      const scopeVarName = `__scope_${withVars.size}_${\n        scopeVar.__element__.__name__.split(\"::\")[1]\n      }`;\n\n      withVars.set(scopeVar, {\n        name: scopeVarName,\n        scope: withBlock,\n        childExprs: new Set(),\n        scopedExpr:\n          expr.__element__.__kind__ === TypeKind.object\n            ? (expr.__expr__ as any)\n            : undefined,\n      });\n    }\n\n    // expression should be extracted to with block if\n    // - bound with e.with\n    // - refcount > 1\n    // - aliased with e.alias\n    if (\n      refData.refCount > 1 ||\n      refData.boundScope ||\n      refData.aliases.length > 0\n    ) {\n      // first, check if expr is bound to scope\n      let withBlock = refData.boundScope;\n\n      // filter nulls\n      const parentScopes = [...refData.parentScopes].filter(\n        scope => scope !== null\n      ) as WithScopeExpr[];\n\n      // if expression is unbound\n      if (!withBlock) {\n        // if parent scopes haven't all been resolved,\n        // re-add current expr to `seen` to be resolved later\n        if (parentScopes.some(parentScope => seen.has(parentScope))) {\n          seen.set(expr, refData);\n          continue;\n        }\n\n        // set withBlock to top-level parent scope\n        const resolvedParentScopes = parentScopes.map(\n          parentScope => withVars.get(parentScope)?.scope ?? parentScope\n        );\n        withBlock =\n          resolvedParentScopes.find(parentScope => {\n            // loop over parent scopes\n            // get list of children exprs for each parent\n            const childExprs = new Set(\n              walkExprCtx.seen.get(parentScope)!.childExprs\n            );\n            // return true for scope that contains all other scopes\n            return resolvedParentScopes.every(\n              scope => childExprs.has(scope) || scope === parentScope\n            );\n          }) ?? walkExprCtx.rootScope;\n      }\n\n      if (!withBlock) {\n        throw new Error(\n          `Cannot extract repeated expression into 'WITH' block, ` +\n            `query has no 'WITH'able expressions`\n        );\n      }\n\n      if (!withBlocks.has(withBlock)) {\n        withBlocks.set(withBlock, new Set());\n      }\n\n      // check all references and aliases are within this block\n      const validScopes = new Set([\n        withBlock,\n        ...walkExprCtx.seen.get(withBlock)!.childExprs,\n      ]);\n      for (const scope of [\n        ...refData.parentScopes,\n        ...util.flatMap(refData.aliases, alias => [\n          ...walkExprCtx.seen.get(alias)!.parentScopes,\n        ]),\n      ]) {\n        if (scope === null || !validScopes.has(scope)) {\n          throw new Error(\n            refData.boundScope\n              ? `Expr or its aliases used outside of declared 'WITH' block scope`\n              : `Cannot extract repeated or aliased expression into 'WITH' block, ` +\n                `expression or its aliases appear outside root scope`\n          );\n        }\n      }\n\n      for (const withVar of [expr, ...refData.aliases]) {\n        // withVar is an alias already explicitly bound\n        // to an inner WITH block\n        const withVarBoundScope = walkExprCtx.seen.get(withVar)!.boundScope;\n        if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {\n          continue;\n        }\n\n        const withVarName = `__withVar_${withVars.size}`;\n\n        withBlocks.get(withBlock)!.add(withVar);\n        withVars.set(withVar, {\n          name: withVarName,\n          scope: withBlock,\n          childExprs: new Set(walkExprCtx.seen.get(withVar)!.childExprs),\n        });\n      }\n    }\n  }\n\n  let edgeQL = renderEdgeQL(this, {\n    withBlocks,\n    withVars,\n    forVars: new Map(),\n    linkProps,\n  });\n  if (\n    edgeQL.startsWith(\"(\") &&\n    edgeQL.endsWith(\")\") &&\n    !(\n      this.__kind__ === ExpressionKind.Tuple ||\n      this.__kind__ === ExpressionKind.NamedTuple ||\n      this.__kind__ === ExpressionKind.Literal\n    )\n  ) {\n    edgeQL = edgeQL.slice(1, -1);\n  }\n  toEdgeQLCache.set(this, edgeQL);\n\n  return edgeQL;\n}\n\ninterface WalkExprTreeCtx {\n  seen: Map<\n    SomeExpression,\n    {\n      refCount: number;\n      // tracks all withable ancestors\n      parentScopes: Set<WithScopeExpr | null>;\n      // tracks all child exprs\n      childExprs: SomeExpression[];\n      // tracks bound scope from e.with\n      boundScope: WithScopeExpr | null;\n      // tracks aliases from e.alias\n      aliases: SomeExpression[];\n      linkProps: $expr_PathLeaf[];\n    }\n  >;\n  rootScope: WithScopeExpr | null;\n}\n\n// walks entire expression tree\n// populates\nfunction walkExprTree(\n  _expr: TypeSet,\n  parentScope: WithScopeExpr | null,\n  ctx: WalkExprTreeCtx\n): SomeExpression[] {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\n      `Expected a valid querybuilder expression, ` +\n        `instead received ${typeof _expr}${\n          typeof _expr !== \"undefined\" ? `: '${_expr}'` : \"\"\n        }.` +\n        getErrorHint(_expr)\n    );\n  }\n\n  const expr = _expr as SomeExpression;\n\n  function walkShape(shape: object) {\n    for (let param of Object.values(shape)) {\n      if (param.__kind__ === ExpressionKind.PolyShapeElement) {\n        param = param.__shapeElement__;\n      }\n      if (typeof param === \"object\") {\n        if (!!(param as any).__kind__) {\n          // param is expression\n          childExprs.push(...walkExprTree(param as any, expr as any, ctx));\n        } else {\n          walkShape(param);\n        }\n      }\n    }\n  }\n\n  // set root scope\n  if (!ctx.rootScope && parentScope) {\n    ctx.rootScope = parentScope;\n  }\n\n  // return without walking if expression has been seen\n  const seenExpr = ctx.seen.get(expr);\n  if (seenExpr) {\n    seenExpr.refCount += 1;\n    // if (seenExpr.refCount > 1) {\n    // console.log(`###########\\nSEEN ${seenExpr.refCount} times`);\n    // console.log(expr.__kind__);\n    // console.log(expr.__element__.__name__);\n    // const arg = (expr as any)?.__parent__ || (expr as any)?.__name__;\n    // if (arg) console.log(arg);\n    // }\n    seenExpr.parentScopes.add(parentScope);\n    return [expr, ...seenExpr.childExprs];\n  }\n\n  const childExprs: SomeExpression[] = [];\n  ctx.seen.set(expr, {\n    refCount: 1,\n    parentScopes: new Set([parentScope]),\n    childExprs,\n    boundScope: null,\n    aliases: [],\n    linkProps: [],\n  });\n\n  switch (expr.__kind__) {\n    case ExpressionKind.Alias:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      ctx.seen.get(expr.__expr__ as any)!.aliases.push(expr);\n      break;\n    case ExpressionKind.With:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      for (const refExpr of expr.__refs__) {\n        walkExprTree(refExpr, expr.__expr__, ctx);\n        const seenRef = ctx.seen.get(refExpr as any)!;\n        if (seenRef.boundScope) {\n          throw new Error(`Expression bound to multiple 'WITH' blocks`);\n        }\n        seenRef.boundScope = expr.__expr__;\n      }\n      break;\n    case ExpressionKind.Literal:\n    case ExpressionKind.ForVar:\n    case ExpressionKind.Param:\n      break;\n    case ExpressionKind.PathLeaf:\n    case ExpressionKind.PathNode:\n      if (expr.__parent__) {\n        if ((expr.__parent__.type as any).__scopedFrom__) {\n          // if parent is scoped expr then don't walk expr\n          // since it will already be walked by enclosing select/update\n\n          childExprs.push(expr.__parent__.type as any);\n        } else {\n          childExprs.push(\n            ...walkExprTree(expr.__parent__.type, parentScope, ctx)\n          );\n        }\n\n        if (\n          // is link prop\n          expr.__kind__ === ExpressionKind.PathLeaf &&\n          expr.__parent__.linkName.startsWith(\"@\")\n        ) {\n          // don't hoist a linkprop that isn't scoped from parentScope\n          const parentScopeVar = (parentScope as any).__scope__;\n          if (parentScopeVar === expr.__parent__.type) {\n            ctx.seen.get(parentScope!)?.linkProps.push(expr);\n          }\n        }\n      }\n      break;\n    case ExpressionKind.Cast:\n      if (expr.__expr__ === null) break;\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Set:\n      for (const subExpr of expr.__exprs__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Array:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.Tuple:\n      for (const subExpr of expr.__items__) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.NamedTuple:\n      for (const subExpr of Object.values(expr.__shape__)) {\n        childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n      }\n      break;\n    case ExpressionKind.TuplePath:\n      childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));\n      break;\n    case ExpressionKind.Select:\n    case ExpressionKind.Update: {\n      const modifiers = expr.__modifiers__;\n      if (modifiers.filter) {\n        childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));\n      }\n      if (modifiers.order_by) {\n        for (const orderExpr of modifiers.order_by) {\n          childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));\n        }\n      }\n      if (modifiers.offset) {\n        childExprs.push(...walkExprTree(modifiers.offset!, expr, ctx));\n      }\n      if (modifiers.limit) {\n        childExprs.push(...walkExprTree(modifiers.limit!, expr, ctx));\n      }\n\n      if (expr.__kind__ === ExpressionKind.Select) {\n        if (\n          isObjectType(expr.__element__) &&\n          // don't walk shape twice if select expr justs wrap another object\n          // type expr with the same shape\n          expr.__element__.__shape__ !==\n            (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n        ) {\n          walkShape(expr.__element__.__shape__ ?? {});\n        }\n      } else {\n        // Update\n        const shape: any = expr.__shape__ ?? {};\n\n        for (const _element of Object.values(shape)) {\n          let element: any = _element;\n          if (!element.__element__) {\n            if (element[\"+=\"]) element = element[\"+=\"];\n            else if (element[\"-=\"]) element = element[\"-=\"];\n          }\n          childExprs.push(...walkExprTree(element as any, expr, ctx));\n        }\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.Delete: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Insert: {\n      const shape: any = expr.__shape__ ?? {};\n\n      for (const element of Object.values(shape)) {\n        childExprs.push(...walkExprTree(element as any, expr, ctx));\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.InsertUnlessConflict: {\n      // InsertUnlessConflict doesn't create a new scope, the parent scope of\n      // child expressions is the wrapped Insert expr\n      if (expr.__conflict__.on) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.on,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n      if (expr.__conflict__.else) {\n        childExprs.push(\n          ...walkExprTree(\n            expr.__conflict__.else,\n            expr.__expr__ as $expr_Insert,\n            ctx\n          )\n        );\n      }\n\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Group: {\n      const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n      // const groupingSet = expr.__grouping__ as any as GroupingSet;\n      for (const [_k, groupExpr] of groupingSet.__exprs__) {\n        // this prevents recurring grouping elements from being walked twice\n        // this way, these won't get pulled into with blocks,\n        // which is good because they need to be rendered in `using`\n        const seen: Set<any> = new Set();\n        if (!seen.has(expr)) {\n          childExprs.push(...walkExprTree(groupExpr, expr, ctx));\n          seen.add(expr);\n        }\n      }\n\n      if (!expr.__element__.__shape__.elements.__element__.__shape__) {\n        throw new Error(\"Missing shape in GROUP statement\");\n      }\n      walkShape(expr.__element__.__shape__.elements.__element__.__shape__);\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.TypeIntersection:\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    case ExpressionKind.Operator:\n    case ExpressionKind.Function:\n      for (const subExpr of expr.__args__) {\n        if (Array.isArray(subExpr)) {\n          for (const arg of subExpr) {\n            if (arg) childExprs.push(...walkExprTree(arg, parentScope, ctx));\n          }\n        } else {\n          childExprs.push(...walkExprTree(subExpr!, parentScope, ctx));\n        }\n      }\n      if (expr.__kind__ === ExpressionKind.Function) {\n        for (const subExpr of Object.values(expr.__namedargs__)) {\n          childExprs.push(...walkExprTree(subExpr, parentScope, ctx));\n        }\n      }\n      break;\n    case ExpressionKind.For: {\n      childExprs.push(...walkExprTree(expr.__iterSet__ as any, expr, ctx));\n      childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));\n      break;\n    }\n    case ExpressionKind.WithParams: {\n      if (parentScope !== null) {\n        throw new Error(\n          `'withParams' does not support being used as a nested expression`\n        );\n      }\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Detached: {\n      childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));\n      break;\n    }\n    case ExpressionKind.Global:\n      break;\n    default:\n      util.assertNever(\n        expr,\n        new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n      );\n  }\n\n  return [expr, ...childExprs];\n}\n\nfunction renderEdgeQL(\n  _expr: TypeSet,\n  ctx: RenderCtx,\n  renderShape: boolean = true,\n  noImplicitDetached: boolean = false\n): string {\n  if (!(_expr as any).__kind__) {\n    throw new Error(\"Invalid expression.\");\n  }\n  const expr = _expr as SomeExpression;\n\n  // if expression is in a with block\n  // render its name\n  const withVar = ctx.withVars.get(expr);\n\n  if (withVar && ctx.renderWithVar !== expr) {\n    return renderShape &&\n      expr.__kind__ === ExpressionKind.Select &&\n      isObjectType(expr.__element__)\n      ? `(${withVar.name} ${shapeToEdgeQL(\n          (expr.__element__.__shape__ || {}) as object,\n          ctx,\n          null,\n          true // render shape only\n        )})`\n      : withVar.name;\n  }\n\n  // render with block expression\n  function renderWithBlockExpr(\n    varExpr: SomeExpression,\n    _noImplicitDetached?: boolean\n  ) {\n    const withBlockElement = ctx.withVars.get(varExpr)!;\n    let renderedExpr = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      _noImplicitDetached\n    );\n    const renderedExprNoDetached = renderEdgeQL(\n      withBlockElement.scopedExpr ?? varExpr,\n      {\n        ...ctx,\n        renderWithVar: varExpr,\n      },\n      !withBlockElement.scopedExpr, // render shape if no scopedExpr exists\n      true\n    );\n\n    if (ctx.linkProps.has(expr)) {\n      renderedExpr = `(SELECT ${renderedExpr} {\\n${ctx.linkProps\n        .get(expr)!\n        .map(\n          linkPropName =>\n            `  __linkprop_${linkPropName} := ${renderedExprNoDetached}@${linkPropName}`\n        )\n        .join(\",\\n\")}\\n})`;\n    }\n    return `  ${withBlockElement.name} := ${\n      renderedExpr.includes(\"\\n\")\n        ? `(\\n${indent(\n            renderedExpr[0] === \"(\" &&\n              renderedExpr[renderedExpr.length - 1] === \")\"\n              ? renderedExpr.slice(1, -1)\n              : renderedExpr,\n            4\n          )}\\n  )`\n        : renderedExpr\n    }`;\n  }\n\n  // extract scope expression from select/update if exists\n  const scopeExpr =\n    (expr.__kind__ === ExpressionKind.Select ||\n      expr.__kind__ === ExpressionKind.Update ||\n      expr.__kind__ === ExpressionKind.Group) &&\n    ctx.withVars.has(expr.__scope__ as any)\n      ? (expr.__scope__ as SomeExpression)\n      : undefined;\n\n  const scopeExprVar: string[] = [];\n  const unscopedWithBlock: string[] = [];\n  const scopedWithBlock: string[] = [];\n\n  // generate with block if needed\n  if (ctx.withBlocks.has(expr as any) || scopeExpr) {\n    // sort associated vars\n    const sortedBlockVars = topoSortWithVars(\n      ctx.withBlocks.get(expr as any) ?? new Set(),\n      ctx\n    );\n\n    if (!scopeExpr) {\n      // if no scope expression exists, all variables are unscoped\n      unscopedWithBlock.push(\n        ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n      );\n    }\n    // else if (expr.__kind__ === ExpressionKind.Group) {\n    //   // add all vars into scoped with block\n    //   // this is rendered inside the `using` clause later\n    //   // no need for the with/for trick\n    //   scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n    //   scopedWithBlock.push(\n    //     ...sortedBlockVars.map(blockVar => renderWithBlockExpr(blockVar))\n    //   );\n    // }\n    else {\n      // get scope variable\n      const scopeVar = ctx.withVars.get(scopeExpr)!;\n\n      // get list of with vars that reference scope\n      const scopedVars = sortedBlockVars.filter(blockVarExpr =>\n        ctx.withVars.get(blockVarExpr)?.childExprs.has(scopeExpr)\n      );\n      // filter blockvars to only include vars that don't reference scope\n      unscopedWithBlock.push(\n        ...sortedBlockVars\n          .filter(blockVar => !scopedVars.includes(blockVar))\n          .map(blockVar => renderWithBlockExpr(blockVar))\n      );\n\n      // when rendering `with` variables that reference current scope\n      // they are extracted into computed properties defining in a for loop\n      if (!scopedVars.length) {\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n      } else {\n        const scopeName = scopeVar.name;\n\n        // render a reference to scoped path (e.g. \".nemesis\")\n        scopeVar.name = scopeName + \"_expr\";\n        scopeExprVar.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));\n        // scopedWithBlock.push(\n        //   renderWithBlockExpr(scopeExpr, noImplicitDetached)\n        // );\n\n        // render a for loop containing all scoped block vars\n        // as computed properties\n        scopeVar.name = scopeName + \"_inner\";\n        scopeExprVar.push(\n          `  ${scopeName} := (FOR ${scopeVar.name} IN {${\n            scopeName + \"_expr\"\n          }} UNION (\\n    WITH\\n${indent(\n            scopedVars\n              .map(blockVar => renderWithBlockExpr(blockVar))\n              .join(\",\\n\"),\n            4\n          )}\\n    SELECT ${scopeVar.name} {\\n${scopedVars\n            .map(blockVar => {\n              const name = ctx.withVars.get(blockVar)!.name;\n              return `      ${name} := ${name}`;\n            })\n            .join(\",\\n\")}\\n    }\\n  ))`\n        );\n\n        // change var name back to original value\n        scopeVar.name = scopeName;\n\n        // reassign name for all scoped block vars\n        for (const blockVarExpr of scopedVars) {\n          const blockVar = ctx.withVars.get(blockVarExpr)!;\n          blockVar.name = `${scopeName}.${blockVar.name}`;\n        }\n      }\n    }\n  }\n\n  const withBlockElements = [\n    ...unscopedWithBlock,\n    ...scopeExprVar,\n    ...scopedWithBlock,\n  ];\n  const withBlock = withBlockElements.length\n    ? `WITH\\n${withBlockElements.join(\",\\n\")}\\n`\n    : \"\";\n\n  if (expr.__kind__ === ExpressionKind.With) {\n    return renderEdgeQL(expr.__expr__, ctx);\n  } else if (expr.__kind__ === ExpressionKind.WithParams) {\n    return `(WITH\\n${expr.__params__\n      .map(param => {\n        const optional =\n          param.__cardinality__ === Cardinality.AtMostOne ? \"OPTIONAL \" : \"\";\n        return `  __param__${param.__name__} := ${\n          param.__isComplex__\n            ? `<${param.__element__.__name__}>to_json(<${optional}str>$${param.__name__})`\n            : `<${optional}${param.__element__.__name__}>$${param.__name__}`\n        }`;\n      })\n      .join(\",\\n\")}\\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Alias) {\n    const aliasedExprVar = ctx.withVars.get(expr.__expr__ as any);\n    if (!aliasedExprVar) {\n      throw new Error(\n        `Expression referenced by alias does not exist in 'WITH' block`\n      );\n    }\n    return aliasedExprVar.name;\n  } else if (\n    expr.__kind__ === ExpressionKind.PathNode ||\n    expr.__kind__ === ExpressionKind.PathLeaf\n  ) {\n    if (!expr.__parent__) {\n      return `${noImplicitDetached ? \"\" : \"DETACHED \"}${\n        expr.__element__.__name__\n      }`;\n    } else {\n      const isScopedLinkProp =\n        expr.__parent__.linkName.startsWith(\"@\") &&\n        ctx.withVars.has(expr.__parent__.type as any);\n      const linkName = isScopedLinkProp\n        ? `__linkprop_${expr.__parent__.linkName.slice(1)}`\n        : expr.__parent__.linkName;\n      const parent = renderEdgeQL(\n        expr.__parent__.type,\n        ctx,\n        false,\n        noImplicitDetached\n      );\n      return `${parent}${linkName.startsWith(\"@\") ? \"\" : \".\"}${q(linkName)}`;\n    }\n  } else if (expr.__kind__ === ExpressionKind.Literal) {\n    return literalToEdgeQL(expr.__element__, expr.__value__);\n  } else if (expr.__kind__ === ExpressionKind.Set) {\n    const exprs = expr.__exprs__;\n\n    if (\n      exprs.every(ex => ex.__element__.__kind__ === TypeKind.object) ||\n      exprs.every(ex => ex.__element__.__kind__ !== TypeKind.object)\n    ) {\n      if (exprs.length === 0) return `<${expr.__element__.__name__}>{}`;\n      return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(\", \")} }`;\n    } else {\n      throw new Error(\n        `Invalid arguments to set constructor: ${exprs\n          .map(ex => ex.__element__.__name__)\n          .join(\", \")}`\n      );\n    }\n  } else if (expr.__kind__ === ExpressionKind.Array) {\n    return `[${expr.__items__\n      .map(item => renderEdgeQL(item, ctx))\n      .join(\", \")}]`;\n  } else if (expr.__kind__ === ExpressionKind.Tuple) {\n    return `(\\n${expr.__items__\n      .map(\n        item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached)\n      )\n      .join(\",\\n\")}${expr.__items__.length === 1 ? \",\" : \"\"}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.NamedTuple) {\n    return `(\\n${Object.keys(expr.__shape__)\n      .map(\n        key =>\n          `  ${key} := ${renderEdgeQL(\n            expr.__shape__[key],\n            ctx,\n            renderShape,\n            noImplicitDetached\n          )}`\n      )\n      .join(\",\\n\")}\\n)`;\n  } else if (expr.__kind__ === ExpressionKind.TuplePath) {\n    return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;\n  } else if (expr.__kind__ === ExpressionKind.Cast) {\n    const typeName =\n      expr.__element__.__name__ === \"std::number\"\n        ? \"std::float64\"\n        : expr.__element__.__name__;\n    if (expr.__expr__ === null) {\n      return `<${typeName}>{}`;\n    }\n    return `<${typeName}>(${renderEdgeQL(expr.__expr__, ctx)})`;\n  } else if (expr.__kind__ === ExpressionKind.Select) {\n    const lines: string[] = [];\n    if (isObjectType(expr.__element__)) {\n      const selectionTarget = renderEdgeQL(\n        expr.__scope__ ?? expr.__expr__,\n        ctx,\n        false\n      );\n\n      lines.push(\n        `SELECT${\n          selectionTarget === \"DETACHED std::FreeObject\"\n            ? \"\"\n            : ` ${selectionTarget}`\n        }`\n      );\n\n      if (\n        expr.__element__.__shape__ !==\n        (expr.__expr__ as ObjectTypeSet).__element__.__shape__\n      ) {\n        lines.push(\n          shapeToEdgeQL(\n            (expr.__element__.__shape__ || {}) as object,\n            ctx,\n            expr.__element__\n          )\n        );\n      }\n    } else {\n      // non-object/non-shape select expression\n      const needsScalarVar =\n        (expr.__modifiers__.filter ||\n          expr.__modifiers__.order_by ||\n          expr.__modifiers__.offset ||\n          expr.__modifiers__.limit) &&\n        !ctx.withVars.has(expr.__expr__ as any);\n\n      lines.push(\n        `SELECT ${needsScalarVar ? \"_ := \" : \"\"}${renderEdgeQL(\n          expr.__expr__,\n          ctx\n        )}`\n      );\n\n      if (needsScalarVar) {\n        ctx = {...ctx, withVars: new Map(ctx.withVars)};\n        ctx.withVars.set(expr.__expr__ as any, {\n          name: \"_\",\n          childExprs: new Set(),\n          scope: expr,\n        });\n      }\n    }\n\n    const modifiers: string[] = [];\n\n    if (expr.__modifiers__.filter) {\n      modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);\n    }\n    if (expr.__modifiers__.order_by) {\n      modifiers.push(\n        ...expr.__modifiers__.order_by.map(\n          ({expression, direction, empty}, i) => {\n            return `${i === 0 ? \"ORDER BY\" : \"  THEN\"} ${renderEdgeQL(\n              expression,\n              ctx\n            )}${direction ? \" \" + direction : \"\"}${empty ? \" \" + empty : \"\"}`;\n          }\n        )\n      );\n    }\n    if (expr.__modifiers__.offset) {\n      modifiers.push(\n        `OFFSET ${renderEdgeQL(\n          expr.__modifiers__.offset as OffsetExpression,\n          ctx\n        )}`\n      );\n    }\n    if (expr.__modifiers__.limit) {\n      modifiers.push(\n        `LIMIT ${renderEdgeQL(\n          expr.__modifiers__.limit as LimitExpression,\n          ctx\n        )}`\n      );\n    }\n\n    return (\n      \"(\" +\n      withBlock +\n      lines.join(\" \") +\n      (modifiers.length ? \"\\n\" + modifiers.join(\"\\n\") : \"\") +\n      \")\"\n    );\n  } else if (expr.__kind__ === ExpressionKind.Update) {\n    return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${\n      expr.__modifiers__.filter\n        ? `\\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\\n`\n        : \" \"\n    }SET ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.Delete) {\n    return `(${withBlock}DELETE ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      undefined,\n      noImplicitDetached\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Insert) {\n    return `(${withBlock}INSERT ${renderEdgeQL(\n      expr.__expr__,\n      ctx,\n      false,\n      true\n    )} ${shapeToEdgeQL(expr.__shape__, ctx, null, false, false)})`;\n  } else if (expr.__kind__ === ExpressionKind.InsertUnlessConflict) {\n    const $on = expr.__conflict__.on;\n    const $else = expr.__conflict__.else;\n    const clause: string[] = [];\n    if (!$on) {\n      clause.push(\"\\nUNLESS CONFLICT\");\n    }\n    if ($on) {\n      clause.push(\n        `\\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`\n      );\n    }\n    if ($else) {\n      clause.push(`\\nELSE (${renderEdgeQL($else, ctx, true, true)})`);\n    }\n    return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(\n      1,\n      -1\n    )} ${clause.join(\"\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Group) {\n    const groupingSet = expr.__modifiers__.by as any as GroupingSet;\n    const elementsShape =\n      expr.__element__.__shape__.elements.__element__.__shape__;\n\n    const selectStatement: string[] = [];\n    const groupStatement: string[] = [];\n\n    const groupTarget = renderEdgeQL(expr.__scope__, ctx);\n    groupStatement.push(`GROUP ${groupTarget}`);\n\n    // render scoped withvars in using\n    const combinedBlock = [\n      // ...scopedWithBlock,\n      // this is deduplicated in e.group\n      ...groupingSet.__exprs__.map(\n        ([k, v]) => `  ${k} := ${renderEdgeQL(v, ctx)}`\n      ),\n    ];\n    groupStatement.push(`USING\\n${combinedBlock.join(\",\\n\")}`);\n\n    let by = renderGroupingSet(groupingSet).trim();\n    if (by[0] === \"(\" && by[by.length - 1] === \")\") {\n      by = by.slice(1, by.length - 1);\n    }\n    groupStatement.push(`BY ` + by);\n\n    // clause.push(withBlock.trim());\n\n    // render scope var and any unscoped withVars in with block\n    const selectTarget = `${groupTarget}_groups`;\n    selectStatement.push(\n      `WITH\\n${[\n        ...unscopedWithBlock,\n        ...scopeExprVar,\n        // ...scopedWithBlock,\n      ].join(\",\\n\")},\n  ${selectTarget} := (\n${indent(groupStatement.join(\"\\n\"), 4)}\n)`\n    );\n\n    // rename scope var to fix all scope references that\n    // occur in the `elements` subshape\n    const scopeVar = ctx.withVars.get(expr.__scope__ as any);\n\n    // replace references to __scope__ with\n    // .elements reference\n    const elementsShapeQuery = indent(\n      shapeToEdgeQL(elementsShape as object, {...ctx}, expr.__element__),\n      2\n    )\n      .trim()\n      .split(scopeVar!.name + \".\")\n      .join(`${selectTarget}.elements.`);\n\n    selectStatement.push(`SELECT ${selectTarget} {\n  key: {${groupingSet.__exprs__.map(e => e[0]).join(\", \")}},\n  grouping,\n  elements: ${elementsShapeQuery}\n}`);\n    return `(${selectStatement.join(\"\\n\")})`;\n  } else if (expr.__kind__ === ExpressionKind.Function) {\n    const args = expr.__args__.map(arg => `${renderEdgeQL(arg!, ctx, false)}`);\n    for (const [key, arg] of Object.entries(expr.__namedargs__)) {\n      args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);\n    }\n    return `${expr.__name__}(${args.join(\", \")})`;\n  } else if (expr.__kind__ === ExpressionKind.Operator) {\n    const operator = expr.__name__;\n    const args = expr.__args__;\n    switch (expr.__opkind__) {\n      case OperatorKind.Infix:\n        if (operator === \"[]\") {\n          let index = \"\";\n          if (Array.isArray(args[1])) {\n            const [start, end] = args[1];\n            if (start) {\n              index += renderEdgeQL(start, ctx);\n            }\n            index += \":\";\n            if (end) {\n              index += renderEdgeQL(end, ctx);\n            }\n          } else {\n            index = renderEdgeQL(args[1], ctx);\n          }\n\n          return `${renderEdgeQL(args[0], ctx)}[${index}]`;\n        }\n        return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(\n          args[1],\n          ctx\n        )})`;\n      case OperatorKind.Postfix:\n        return `(${renderEdgeQL(args[0], ctx)} ${operator})`;\n      case OperatorKind.Prefix:\n        return `(${operator} ${renderEdgeQL(args[0], ctx)})`;\n      case OperatorKind.Ternary:\n        if (operator === \"if_else\") {\n          return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(\n            args[1],\n            ctx\n          )} ELSE ${renderEdgeQL(args[2], ctx)})`;\n        } else {\n          throw new Error(`Unknown operator: ${operator}`);\n        }\n      default:\n        util.assertNever(\n          expr.__opkind__,\n          new Error(`Unknown operator kind: ${expr.__opkind__}`)\n        );\n    }\n  } else if (expr.__kind__ === ExpressionKind.TypeIntersection) {\n    return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${\n      expr.__element__.__name__\n    }]`;\n  } else if (expr.__kind__ === ExpressionKind.For) {\n    ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);\n    return `(${withBlock}FOR ${ctx.forVars.get(\n      expr.__forVar__\n    )} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}\nUNION (\\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\\n))`;\n  } else if (expr.__kind__ === ExpressionKind.ForVar) {\n    const forVar = ctx.forVars.get(expr);\n    if (!forVar) {\n      throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);\n    }\n    return forVar;\n  } else if (expr.__kind__ === ExpressionKind.Param) {\n    return `__param__${expr.__name__}`;\n  } else if (expr.__kind__ === ExpressionKind.Detached) {\n    return `(DETACHED ${renderEdgeQL(\n      expr.__expr__,\n      {\n        ...ctx,\n        renderWithVar: expr.__expr__ as any,\n      },\n      undefined,\n      true\n    )})`;\n  } else if (expr.__kind__ === ExpressionKind.Global) {\n    return `(GLOBAL ${expr.__name__})`;\n  } else {\n    util.assertNever(\n      expr,\n      new Error(`Unrecognized expression kind: \"${(expr as any).__kind__}\"`)\n    );\n  }\n}\n\nfunction isGroupingSet(arg: any): arg is GroupingSet {\n  return arg.__kind__ === \"groupingset\";\n}\n\n// recursive renderer\nfunction renderGroupingSet(set: GroupingSet): string {\n  const contents = Object.entries(set.__elements__)\n    .map(([k, v]) => {\n      return isGroupingSet(v) ? renderGroupingSet(v) : k;\n    })\n    .join(\", \");\n  if (set.__settype__ === \"tuple\") {\n    return `(${contents})`;\n  } else if (set.__settype__ === \"set\") {\n    return `{${contents}}`;\n  } else if (set.__settype__ === \"cube\") {\n    return `cube(${contents})`;\n  } else if (set.__settype__ === \"rollup\") {\n    return `rollup(${contents})`;\n  } else {\n    throw new Error(`Unrecognized set type: \"${set.__settype__}\"`);\n  }\n}\n\nfunction shapeToEdgeQL(\n  shape: object | null,\n  ctx: RenderCtx,\n  type: ObjectType | null = null,\n  keysOnly: boolean = false,\n  injectImplicitId: boolean = true\n) {\n  const pointers = type?.__pointers__ || null;\n  const isFreeObject = type?.__name__ === \"std::FreeObject\";\n  if (shape === null) {\n    return ``;\n  }\n\n  const lines: string[] = [];\n  const addLine = (line: string) =>\n    lines.push(`${keysOnly ? \"\" : \"  \"}${line}`);\n\n  const seen = new Set();\n\n  for (const key in shape) {\n    if (!shape.hasOwnProperty(key)) continue;\n    if (seen.has(key)) {\n      // tslint:disable-next-line\n      console.warn(`Invalid: duplicate key \"${key}\"`);\n      continue;\n    }\n    seen.add(key);\n    let val = (shape as any)[key];\n    let operator = \":=\";\n    let polyType: SomeExpression | null = null;\n\n    if (typeof val === \"object\" && !val.__element__) {\n      if (!!val[\"+=\"]) {\n        operator = \"+=\";\n        val = val[\"+=\"];\n      } else if (!!val[\"-=\"]) {\n        operator = \"-=\";\n        val = val[\"-=\"];\n      }\n    }\n    if (val.__kind__ === ExpressionKind.PolyShapeElement) {\n      polyType = val.__polyType__;\n      val = val.__shapeElement__;\n    }\n    const polyIntersection = polyType\n      ? `[IS ${polyType.__element__.__name__}].`\n      : \"\";\n\n    // For computed properties in select shapes, inject the expected\n    // cardinality inferred by the query builder. This ensures the actual\n    // type returned by the server matches the inferred return type, or an\n    // explicit error is thrown, instead of a silent mismatch between\n    // actual and inferred type.\n    // Add annotations on FreeObjects, despite the existence of a pointer.\n    const ptr = pointers?.[key];\n    const addCardinalityAnnotations = pointers && (!ptr || isFreeObject);\n\n    const expectedCardinality =\n      addCardinalityAnnotations && val.hasOwnProperty(\"__cardinality__\")\n        ? val.__cardinality__ === Cardinality.Many ||\n          val.__cardinality__ === Cardinality.AtLeastOne\n          ? \"multi \"\n          : \"single \"\n        : \"\";\n\n    // if selecting a required multi link, wrap expr in 'assert_exists'\n    const wrapAssertExists = ptr?.cardinality === Cardinality.AtLeastOne;\n\n    if (typeof val === \"boolean\") {\n      if (\n        !pointers?.[key] &&\n        key[0] !== \"@\" &&\n        type &&\n        type?.__name__ !== \"std::FreeObject\" &&\n        !polyIntersection\n      ) {\n        throw new Error(`Field \"${key}\" does not exist in ${type?.__name__}`);\n      }\n      if (val) {\n        addLine(`${polyIntersection}${q(key)}`);\n      }\n      continue;\n    }\n\n    if (typeof val !== \"object\") {\n      throw new Error(`Invalid shape element at \"${key}\".`);\n    }\n\n    const valIsExpression = val.hasOwnProperty(\"__kind__\");\n\n    // is subshape\n    if (!valIsExpression) {\n      addLine(\n        `${polyIntersection}${q(key, false)}: ${indent(\n          shapeToEdgeQL(val, ctx, ptr?.target),\n          2\n        ).trim()}`\n      );\n      continue;\n    }\n\n    // val is expression\n\n    // is computed\n    if (keysOnly) {\n      addLine(\n        q(key, false) +\n          (isObjectType(val.__element__)\n            ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`\n            : \"\")\n      );\n      continue;\n    }\n    const renderedExpr = renderEdgeQL(val, ctx);\n\n    addLine(\n      `${expectedCardinality}${q(key, false)} ${operator} ${\n        wrapAssertExists ? \"assert_exists(\" : \"\"\n      }${\n        renderedExpr.includes(\"\\n\")\n          ? `(\\n${indent(\n              renderedExpr[0] === \"(\" &&\n                renderedExpr[renderedExpr.length - 1] === \")\"\n                ? renderedExpr.slice(1, -1)\n                : renderedExpr,\n              4\n            )}\\n  )`\n          : renderedExpr\n      }${wrapAssertExists ? \")\" : \"\"}`\n    );\n  }\n\n  if (lines.length === 0 && injectImplicitId) {\n    addLine(\"id\");\n  }\n  return keysOnly ? `{${lines.join(\", \")}}` : `{\\n${lines.join(\",\\n\")}\\n}`;\n}\n\nfunction topoSortWithVars(\n  vars: Set<SomeExpression>,\n  ctx: RenderCtx\n): SomeExpression[] {\n  if (!vars.size) {\n    return [];\n  }\n\n  const sorted: SomeExpression[] = [];\n\n  const unvisited = new Set(vars);\n  const visiting = new Set<SomeExpression>();\n\n  for (const withVar of unvisited) {\n    visit(withVar);\n  }\n\n  function visit(withVar: SomeExpression): void {\n    if (!unvisited.has(withVar)) {\n      return;\n    }\n    if (visiting.has(withVar)) {\n      throw new Error(`'WITH' variables contain a cyclic dependency`);\n    }\n\n    visiting.add(withVar);\n\n    for (const child of ctx.withVars.get(withVar)!.childExprs) {\n      if (vars.has(child)) {\n        visit(child);\n      }\n    }\n\n    visiting.delete(withVar);\n    unvisited.delete(withVar);\n\n    sorted.push(withVar);\n  }\n  return sorted;\n}\n\nconst numericalTypes: Record<string, boolean> = {\n  \"std::number\": true,\n  \"std::int16\": true,\n  \"std::int32\": true,\n  \"std::int64\": true,\n  \"std::float32\": true,\n  \"std::float64\": true,\n};\n\nfunction literalToEdgeQL(type: BaseType, val: any): string {\n  let skipCast = false;\n  let stringRep;\n  if (type.__name__ === \"std::json\") {\n    skipCast = true;\n    stringRep = `to_json($$${JSON.stringify(val)}$$)`;\n  } else if (typeof val === \"string\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n      stringRep = val;\n    } else if (type.__kind__ === TypeKind.enum) {\n      skipCast = true;\n      const vals = (type as EnumType).__values__;\n      if (vals.includes(val)) {\n        skipCast = true;\n        if (val.includes(\" \")) {\n          stringRep = `<${type.__name__}>\"${val}\"`;\n        } else {\n          stringRep = `${type.__name__}.${val}`;\n        }\n      } else {\n        throw new Error(\n          `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n        );\n      }\n    } else {\n      if (type.__name__ === \"std::str\") {\n        skipCast = true;\n      }\n      stringRep = JSON.stringify(val);\n    }\n  } else if (typeof val === \"number\") {\n    if (numericalTypes[type.__name__]) {\n      skipCast = true;\n    } else {\n      throw new Error(`Unknown numerical type: ${type.__name__}!`);\n    }\n    stringRep = `${val.toString()}`;\n  } else if (typeof val === \"boolean\") {\n    stringRep = `${val.toString()}`;\n    skipCast = true;\n  } else if (typeof val === \"bigint\") {\n    stringRep = `${val.toString()}n`;\n  } else if (Array.isArray(val)) {\n    skipCast = val.length !== 0;\n    if (isArrayType(type)) {\n      stringRep = `[${val\n        .map(el => literalToEdgeQL(type.__element__ as any, el))\n        .join(\", \")}]`;\n    } else if (isTupleType(type)) {\n      stringRep = `( ${val\n        .map((el, j) => literalToEdgeQL(type.__items__[j] as any, el))\n        .join(\", \")}${type.__items__.length === 1 ? \",\" : \"\"} )`;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else if (val instanceof Date) {\n    stringRep = `'${val.toISOString()}'`;\n  } else if (\n    val instanceof LocalDate ||\n    val instanceof LocalDateTime ||\n    val instanceof LocalTime ||\n    val instanceof Duration ||\n    val instanceof RelativeDuration ||\n    val instanceof DateDuration\n  ) {\n    stringRep = `'${val.toString()}'`;\n  } else if (val instanceof Buffer) {\n    stringRep = bufferToStringRep(val);\n    skipCast = true;\n  } else if (val instanceof Range) {\n    const elType = (type as RangeType).__element__;\n\n    // actual type will be inferred from\n    // defined value\n    const elTypeName =\n      elType.__name__ === \"std::number\" ? \"std::int64\" : elType.__name__;\n\n    return `std::range(${\n      val.lower === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.lower)\n    }, ${\n      val.upper === null\n        ? `<${elTypeName}>{}`\n        : literalToEdgeQL(elType, val.upper)\n    }, inc_lower := ${val.incLower}, inc_upper := ${val.incUpper})`;\n  } else if (typeof val === \"object\") {\n    if (isNamedTupleType(type)) {\n      stringRep = `( ${Object.entries(val).map(\n        ([key, value]) =>\n          `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`\n      )} )`;\n      skipCast = true;\n    } else {\n      throw new Error(\n        `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n      );\n    }\n  } else {\n    throw new Error(\n      `Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`\n    );\n  }\n  if (skipCast) {\n    return stringRep;\n  }\n  return `<${type.__name__}>${stringRep}`;\n}\n\nfunction indent(str: string, depth: number) {\n  return str\n    .split(\"\\n\")\n    .map(line => \" \".repeat(depth) + line)\n    .join(\"\\n\");\n}\n\n// backtick quote identifiers if needed\n// https://github.com/edgedb/edgedb/blob/master/edb/edgeql/quote.py\nfunction q(ident: string, allowBacklinks: boolean = true): string {\n  if (\n    !ident ||\n    ident.startsWith(\"@\") ||\n    (allowBacklinks && (ident.startsWith(\"<\") || ident.includes(\"::\")))\n  ) {\n    return ident;\n  }\n\n  const isAlphaNum = /^([^\\W\\d]\\w*|([1-9]\\d*|0))$/.test(ident);\n  if (isAlphaNum) {\n    const lident = ident.toLowerCase();\n    const isReserved =\n      lident !== \"__type__\" &&\n      lident !== \"__std__\" &&\n      reservedKeywords.includes(lident);\n\n    if (!isReserved) {\n      return ident;\n    }\n  }\n\n  return \"`\" + ident.replace(/`/g, \"``\") + \"`\";\n}\n\nfunction bufferToStringRep(buf: Buffer): string {\n  let stringRep = \"\";\n  for (const byte of buf) {\n    if (byte < 32 || byte > 126) {\n      // non printable ascii\n      switch (byte) {\n        case 8:\n          stringRep += \"\\\\b\";\n          break;\n        case 9:\n          stringRep += \"\\\\t\";\n          break;\n        case 10:\n          stringRep += \"\\\\n\";\n          break;\n        case 12:\n          stringRep += \"\\\\f\";\n          break;\n        case 13:\n          stringRep += \"\\\\r\";\n          break;\n        default:\n          stringRep += `\\\\x${byte.toString(16).padStart(2, \"0\")}`;\n      }\n    } else {\n      stringRep +=\n        (byte === 39 || byte === 92 ? \"\\\\\" : \"\") + String.fromCharCode(byte);\n    }\n  }\n  return `b'${stringRep}'`;\n}\n\nfunction getErrorHint(expr: any): string {\n  let literalConstructor: string | null = null;\n  switch (typeof expr) {\n    case \"string\":\n      literalConstructor = \"e.str()\";\n      break;\n    case \"number\":\n      literalConstructor = Number.isInteger(expr)\n        ? \"e.int64()\"\n        : \"e.float64()\";\n      break;\n    case \"bigint\":\n      literalConstructor = \"e.bigint()\";\n      break;\n    case \"boolean\":\n      literalConstructor = \"e.bool()\";\n      break;\n  }\n  switch (true) {\n    case expr instanceof Date:\n      literalConstructor = \"e.datetime()\";\n      break;\n    case expr instanceof Duration:\n      literalConstructor = \"e.duration()\";\n      break;\n    case expr instanceof LocalDate:\n      literalConstructor = \"e.cal.local_date()\";\n      break;\n    case expr instanceof LocalDateTime:\n      literalConstructor = \"e.cal.local_datetime()\";\n      break;\n    case expr instanceof LocalTime:\n      literalConstructor = \"e.cal.local_time()\";\n      break;\n    case expr instanceof RelativeDuration:\n      literalConstructor = \"e.cal.relative_duration()\";\n      break;\n    case expr instanceof DateDuration:\n      literalConstructor = \"e.cal.date_duration()\";\n      break;\n  }\n\n  return literalConstructor\n    ? `\\nHint: Maybe you meant to wrap the value in ` +\n        `a '${literalConstructor}' expression?`\n    : \"\";\n}\n"},{"path":"update.ts","content":"import {\n  Expression,\n  ExpressionKind,\n  ObjectTypePointers,\n  TypeSet,\n  ObjectTypeSet,\n  stripBacklinks,\n  stripNonUpdateables,\n  typeutil,\n  ObjectTypeExpression,\n  $scopify,\n  Cardinality,\n} from \"edgedb/dist/reflection/index\";\nimport type {pointerToAssignmentExpression} from \"./casting\";\nimport {$expressionify, $getScopedExpr} from \"./path\";\nimport {\n  SelectModifiers,\n  NormalisedSelectModifiers,\n  ComputeSelectCardinality,\n  $existingScopes,\n  $handleModifiers,\n} from \"./select\";\nimport {$normaliseInsertShape, pointerIsOptional} from \"./insert\";\n\n/////////////////\n/// UPDATE\n/////////////////\n\nexport type $expr_Update<\n  Set extends TypeSet = TypeSet,\n  Expr extends ObjectTypeSet = ObjectTypeSet,\n  Shape extends UpdateShape<Expr> = any\n> = Expression<{\n  __kind__: ExpressionKind.Update;\n  __element__: Set[\"__element__\"];\n  __cardinality__: Set[\"__cardinality__\"];\n  __expr__: Expr;\n  __shape__: Shape;\n  __modifiers__: NormalisedSelectModifiers;\n  __scope__: ObjectTypeExpression;\n}>;\n\nexport type UpdateShape<Root extends ObjectTypeSet> = typeutil.stripNever<\n  stripNonUpdateables<stripBacklinks<Root[\"__element__\"][\"__pointers__\"]>>\n> extends infer Shape\n  ? Shape extends ObjectTypePointers\n    ? {\n        [k in keyof Shape]?:\n          | (\n              | pointerToAssignmentExpression<Shape[k]>\n              | (Shape[k][\"cardinality\"] extends\n                  | Cardinality.Many\n                  | Cardinality.AtLeastOne\n                  ?\n                      | {\"+=\": pointerToAssignmentExpression<Shape[k], true>}\n                      | {\"-=\": pointerToAssignmentExpression<Shape[k], true>}\n                  : never)\n            )\n          | (pointerIsOptional<Shape[k]> extends true\n              ? undefined | null\n              : never);\n      }\n    : never\n  : never;\n\nexport function update<\n  Expr extends ObjectTypeExpression,\n  Shape extends {\n    filter?: SelectModifiers[\"filter\"];\n    order_by?: SelectModifiers[\"order_by\"];\n    limit?: SelectModifiers[\"limit\"];\n    offset?: SelectModifiers[\"offset\"];\n    set: UpdateShape<Expr>;\n  }\n  // SetShape extends UpdateShape<Expr>,\n  // Modifiers extends Pick<SelectModifiers, \"filter\">\n>(\n  expr: Expr,\n  shape: (scope: $scopify<Expr[\"__element__\"]>) => Readonly<Shape>\n): $expr_Update<\n  {\n    __element__: Expr[\"__element__\"];\n    __cardinality__: ComputeSelectCardinality<Expr, Shape>;\n  },\n  Expr,\n  Shape[\"set\"]\n> {\n  const cleanScopedExprs = $existingScopes.size === 0;\n\n  const scope = $getScopedExpr(expr as any, $existingScopes);\n\n  const resolvedShape = shape(scope);\n\n  if (cleanScopedExprs) {\n    $existingScopes.clear();\n  }\n\n  const mods: any = {};\n  let updateShape: any | null;\n  for (const [key, val] of Object.entries(resolvedShape)) {\n    if (key === \"filter\") {\n      mods[key] = val;\n    } else if (key === \"set\") {\n      updateShape = val;\n    } else {\n      throw new Error(\n        `Invalid update shape key '${key}', only 'filter', ` +\n          `and 'set' are allowed`\n      );\n    }\n  }\n\n  if (!updateShape) {\n    throw new Error(`Update shape must contain 'set' shape`);\n  }\n\n  const {modifiers, cardinality} = $handleModifiers(mods, expr);\n\n  return $expressionify({\n    __kind__: ExpressionKind.Update,\n    __element__: expr.__element__,\n    __cardinality__: cardinality,\n    __expr__: expr,\n    __shape__: $normaliseInsertShape(expr, updateShape, true),\n    __modifiers__: modifiers,\n    __scope__: scope,\n  }) as any;\n}\n"},{"path":"with.ts","content":"import {Expression, ExpressionKind, TypeSet} from \"edgedb/dist/reflection/index\";\nimport type {$expr_Select} from \"./select\";\nimport type {$expr_For} from \"./for\";\nimport type {$expr_Insert} from \"./insert\";\nimport type {$expr_Update} from \"./update\";\nimport type {$expr_Group} from \"./group\";\nimport {$expressionify} from \"./path\";\n\nexport type $expr_Alias<Expr extends TypeSet = TypeSet> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.Alias;\n  __expr__: Expr;\n}>;\n\nexport function alias<Expr extends Expression>(expr: Expr): $expr_Alias<Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.Alias,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __expr__: expr,\n  }) as any;\n}\n\nexport type WithableExpression =\n  | $expr_Select\n  | $expr_For\n  | $expr_Insert\n  | $expr_Update\n  | $expr_Group;\n\nexport type $expr_With<\n  Refs extends TypeSet[] = TypeSet[],\n  Expr extends WithableExpression = WithableExpression\n> = Expression<{\n  __element__: Expr[\"__element__\"];\n  __cardinality__: Expr[\"__cardinality__\"];\n  __kind__: ExpressionKind.With;\n  __expr__: Expr;\n  __refs__: Refs;\n}>;\n\nfunction _with<Refs extends Expression[], Expr extends WithableExpression>(\n  refs: Refs,\n  expr: Expr\n): $expr_With<Refs, Expr> {\n  return $expressionify({\n    __kind__: ExpressionKind.With,\n    __element__: expr.__element__,\n    __cardinality__: expr.__cardinality__,\n    __refs__: refs,\n    __expr__: expr as any,\n  }) as any;\n}\n\nexport {_with as with};\n"}]}